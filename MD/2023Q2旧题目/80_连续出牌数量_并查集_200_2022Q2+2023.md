**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

>   *
> 手里给一副手牌，数字从0-9，有r(红色),，g(绿色），b(蓝色)，y(黄色)四种颜色，出牌规则为每次打出的牌必须跟上一张的数字或者颜色相同，否则不能抽选。
>   * 选手应该怎么选才能使得抽选的次数最大，并且输出这个最大次数。
>

>
> **输入描述**
>
>   * 第一行 牌的数值n (1<=n<=9)
>   * 第二行 牌的颜色（r,g,b,y四种颜色表示)
>

>
> **输出描述**
>
>   * 输出最大出牌数量
>

>
> **示例 1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `1 4 3 4 5`
>
> `r y b b r`
>
> **输出**
>
> `3`
>
> **说明**
>
> 如果打（1, r）-> (5, r)，那么能打两张。
>
> 如果打（4，y) -> (4, b) -> (3, b)，那么能打三张。

# 思路

> 1：搜索遍历类的题目，往BFS或者DFS 上靠。这题用DFS。
>
> 2：从每张开始，根据它的颜色或者数字往下遍历，找到他的一致的卡片，保留最大值即可。

# 考点

> 1：DFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def dfs(numbers, colors,last_num,last_color, card):
        maxdepth = 0
        for i in range(len(card)):
            if card[i] !=0:
                if numbers[i] == last_num or colors[i] == last_color:
                    card[i] = 0
                    maxdepth = max(dfs(numbers, colors, numbers[i], colors[i], card), maxdepth)
                    card[i] = 1
        return maxdepth + 1
    
    number_str = input().split(' ')
    color_str = input().split(' ')
    cards = [1 for i in range(len(number_str))]
    maxiter = 0
    for i in range(len(number_str)):
        cards[i] = 0
        maxiter = max(dfs(number_str, color_str, number_str[i], color_str[i], cards), maxiter)
        cards[i] = 1
    print(maxiter) 
    

