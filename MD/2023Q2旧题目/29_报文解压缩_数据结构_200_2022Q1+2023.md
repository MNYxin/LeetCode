**目录**

题目

思路

考点

Code

* * *

# 题目

>   * 为了提升数据传输的效率，会对传输的报文进行压缩处理。
>   * 输入一个压缩后的报文，请返回它解压后的原始报文。
>   * 压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。
>   * 注意 n 为正整数（0 < n <= 100），str只包含小写英文字母，不考虑异常情况。
>

>
> **输入描述:**
>
> **输入压缩后的报文：**
>
> 1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；
>
> 2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；
>
> **输出描述:**
>
> 解压后的原始报文
>
> **注：**
>
> 1）原始报文长度不会超过1000，不考虑异常的情况
>
> **示例 1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3[k]2[mn]`
>
> **输出**
>
> `kkkmnmn`
>
> **说明**
>
> k 重复3次，mn 重复2次，最终得到 kkkmnmn
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3[m2[c]]`
>
> **输出**
>
> `mccmccmcc`
>
> **说明**
>
> m2[c] 解压缩后为 mcc，重复三次为 mccmccmcc

# 思路

> 1：遍历字符串的同时保持原先的状态，由于还有嵌套的结构，因此想到了使用栈这个数据结构。
>
> 2：四种情况需要考虑
>
>   * 数字
>   * 字母
>   * [ 符号
>   * ] 符号
>

# 考点

> 1：栈
>
> 2：字符串处理

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    
    def dfs(pos):
        num, char = '', ''
        for pos in range(pos, len(s)):
            if s[pos].isalnum():
                num += s[pos]
            if s[pos] == '[':
                j = pos + 1
                while j < len(s):
                    if s[j].isalpha():
                        char += s[j]
                        j += 1
                    elif  s[j] == ']':
                        return j +1,char * int(num)
                    elif s[j].isalnum():
                        new, sub = dfs(j)
                        j, char = new, char + sub
    
    s = input().strip()
    ans, i = '', 0
    while True:
        if i >= len(s):
            break
        i, ret = dfs(i)
        ans += ret
    print(ans)
    

