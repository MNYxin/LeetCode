**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给一个字符串，表示用’, \’分开的人名。然后给定一个字符串，进行快速人名查找，符合要求的输出。
>
> 快速人名查找要求︰人名的每个单词的连续前几位能组成给定字符串，一定要用到每个单词。
>
> 输入描述：
>
> 第一行是人名，用’, \’分开的人名  
>  第二行是 查找字符串  
>  输出描述：输出满足要求的人名
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `zhang san,zhang san san`  
> `zs`
>
> **输出**
>
> `zhang san`
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `zhang san san,zhang an sa,zhang hang,zhang seng,zhang sen a`  
> `zhas`
>
> **输出**
>
> `zhang an sa,zhang seng`

# 思路

> 1：首先想到的就是暴力方法，按照逗号切割以后，去一个一个匹配。
>
> 2：使用正则表达式中的表达式" .* " _（作用：匹配任意长度的字母数字字符串）将匹配式query分割成和姓名字数一致的几部分，如果分割后
> 的表达式中的某个能和当前姓名匹配，并且姓名的首字母以”._ "分割后也能和query匹配，那当前姓名就是查找到的姓名中的一个。

# 考点

> 1：正则表达式

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
        
    
     
    # 处理输入
    # 按逗号分割多个名字
    names = input().split(",")
    query = input()
    result = []
    for name in names:
         # 按空格将姓名分割, 取出首字母, 构成正则pattern
        pattern = ".*".join([i[0] for i in name.split(" ") ]) 
        #print(pattern)
    
        # 可以插入（匹配任意长度字符串的表达式".*"）的位置有哪些, 直接一个排列组合
        insert_add_list = list(combinations([i for i in range(1, len(query))], len(name.split(" ")) - 1))
        #print(insert_add_list)
        for i in insert_add_list:
            formatted_query = query
            cz = 0
            #插入所有的匹配表达式 .*
            for j in sorted(i):
                formatted_query = formatted_query[:j+cz] + ".*" + formatted_query[j+cz:]
                cz += 2
            formatted_query += ".*"
    
            #匹配则当前姓名满足条件
            if match("^" + pattern + ".*$", query) and match(formatted_query, name):
                result.append(name)
                break
    
    print(",".join(result))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

