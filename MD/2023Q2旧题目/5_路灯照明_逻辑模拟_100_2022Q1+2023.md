**所有题目均有 JAVA、C++ 、Python 的三种实现。**

[Python 题目目录](https://blog.csdn.net/misayaaaaa/category_12111005.html "Python
题目目录")

[C++
题库目录](https://blog.csdn.net/misayaaaaa/category_12036814.html?spm=1001.2014.3001.5482
"C++ 题库目录")

[Java 题库目录](https://blog.csdn.net/misayaaaaa/category_12111006.html "Java
题库目录")

# 题目

> 【路灯照明】
>
> 一条长l的笔直的街道上有n个路灯，若这条街的起点为0，终点为l，第i个路灯坐标为a[i] ，每盏灯可以覆盖到的最远距离为d，
>
> 为了照明需求，所有灯的灯光必须覆盖整条街，但是为了省电，要使这个d最小，请找到这个最小的d。
>
> 输入描述:
>
> 每组数据第一行两个整数n和l（n大于0小于等于1000，l小于等于1000000000大于0）。
>
> 第二行有n个整数(均大于等于0小于等于l)，为每盏灯的坐标，多个路灯可以在同一点。
>
> 输出描述:
>
> 输出答案，保留两位小数。
>
> 示例1 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 输入
>
> 7 15  
>  15 5 3 7 9 14 0
>
> 输出
>
> 2.50  
>

# 思路

> 1：这个题目只要理解了还是比较简单的，由于 **两个路灯之间的距离可以分担照明**
> ，那么就说明拿出每两个路灯之间距离的一半取出最大值即可，这样就能保证灯光必须覆盖整条街。
>
> 2： **特殊情况就是第一个和最后一个路灯距离起点和终点的距离不能减半** 。
>
> 3：最后再注意输出的要求，要保留两位小数。

# 考点

> 1：想明白保证灯光覆盖整条路的边界条件
>
> 2：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
        
    
     
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    l = params[1]
    coords = [int(x) for x in input().split(" ")]
    
    
    # 两盏路灯之间的距离
    d1 = 0.0
    coords = sorted(coords)
    for i in range(n):
        temp = coords[i] - coords[i-1]
        if d1<temp:
            d1 = temp
    
    d1 = float(d1)/2
    
    # 与两端点的距离
    temp2 = l-coords[n-1];
    if coords[0]<temp2:
        d2 = temp2
    else:
        d2 = coords[0]
    
    if d1<d2:
        print("%.2f" % d2)
    else:
        print("%.2f" % d1)
    

