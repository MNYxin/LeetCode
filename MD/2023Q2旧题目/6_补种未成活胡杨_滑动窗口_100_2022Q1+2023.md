# 题目

> 近些年来，我国防沙治沙取得显著成果。某沙漠新种植N棵胡杨（编号1-N），排成一排。
>
> 一个月后，有M棵胡杨未能成活。
>
> 现可补种胡杨K棵，请问如何补种（只能补种，不能新种），可以得到最多的连续胡杨树？
>
> **输入描述**
>
> N 总种植数量
>
> M 未成活胡杨数量
>
> M 个空格分隔的数，按编号从小到大排列
>
> K 最多可以补种的数量
>
> **其中：**
>
> 1 <= N <= 100000
>
> 1 <= M <= N
>
> 0 <= K <= M
>
> **输出描述**
>
> 最多的连续胡杨棵树
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5`
>
> `2`
>
> `2 4`
>
> `1`
>
> **输出**
>
> `3`
>
> **说明**
>
> 补种到2或4结果一样，最多的连续胡杨棵树都是3。
>
> **示例2**  
>  **输入**  
>  10  
>  3  
>  2 4 7  
>  1  
>  **输出**  
>  6  
>  **说明**  
>  补种第7棵树，最多的连续胡杨棵树为6(5,6,7,8,9,10)

# 思路

> 1：拿到题先在纸上画一画，对于示例来说，只有 1、3、5 号三棵树成活了，只能补种 1
> 棵树，那么补种到2或4结果一样，最多的连续胡杨棵树都是3。理解了题目逻辑之后，就好办了。
>
> 2：明显可以使用经典的 **滑动窗口法** ，设定好左边界和右边界，并且保证中间有K棵树可以补种，求左边界和右边界的最大差值即可。
>
> 3：需要注意不能新种，只能补种，意味着 **K 个树苗，只能放置在未存活树苗的位置上** 。
>
> 4：题目参考链接：[OD2022Q2算法题-补种未成活胡杨，输出最多的连续胡杨树数-PYTHON解法_槐序廿八·晓的博客-
> CSDN博客](https://blog.csdn.net/hx_28/article/details/125281185 "OD2022Q2算法题-
> 补种未成活胡杨，输出最多的连续胡杨树数-PYTHON解法_槐序廿八·晓的博客-CSDN博客")

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
     
    
    n = int(input())
    m = int(input())
    death = [int(x) for x in input().split(" ")]
    k = int(input())
    s = '1'*n   
    for i in death:
        s = s[0:i-1] + '0' + s[i:]    
    tmp = [str(x) for x in s.split("0")]
    res = 0   
    for i in range(len(tmp)-k):    
        l = 0    
        for j in range(i,i+k+1):
            l += len(tmp[j])
        res = max(res,l+k)    
    print(res)

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

