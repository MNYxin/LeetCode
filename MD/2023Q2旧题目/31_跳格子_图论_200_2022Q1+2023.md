**目录**

题目

思路

输入输出

Code

要求

* * *

## 题目

>
> 地上共有N个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组steps数组给出，steps[0]表示前一个格子,steps[1]表示steps[0]可以开启的格子:
>
> 比如[0,1]表示从跳完第0个格子以后第1个格子就开启了，比如[2,1]，[2,3]表示跳完第2个格子后第1个格子和第3个格子就被开启了
>
> 请你计算是否能由给出的steps数组跳完所有的格子,如果可以输出yes，否则输出no
>
> 说明：
>
> 1.你可以从一个格子跳到任意一个开启的格子
>
> 2.没有前置依赖条件的格子默认就是开启的
>
> 3.如果总数是N，则所有的格子编号为[0,1,2,3…N-1]连续的数组
>
> **输入描述:**
>
> 输入一个整数N表示总共有多少个格子，接着输入多组二维数组steps表示所有格子之间的依赖关系
>
> **输出描述:**
>
> 如果能按照steps给定的依赖顺序跳完所有的格子输出yes
>
> 否则输出no
>
> **示例1**
>
> 输入
>
> 3
>
> 0 1
>
> 0 2
>
> 输出
>
> yes
>
> 说明
>
>
> 总共有三个格子[0,1,2]，跳完0个格子后第1个格子就开启了，跳到第0个格子后第2个格子也被开启了，按照0->1->2或者0->2->1的顺序都可以跳完所有的格子
>
> **示例2**
>
> 输入
>
> 2
>
> 1 0
>
> 0 1
>
> 输出
>
> no
>
> 说明
>
> 总共有2个格子，第1个格子可以开启第0格子，但是第1个格子又需要第0个格子才能开启，相互依赖，因此无法完成
>
> **示例3**
>
> 输入
>
> 6
>
> 0 1
>
> 0 2
>
> 0 3
>
> 0 4
>
> 0 5
>
> 输出
>
> yes
>
> 说明
>
> 总共有6个格子，第0个格子可以开启第1,2,3,4,5个格子，所以跳完第0个格子之后其他格子都被开启了，之后按任何顺序可以跳完剩余的格子
>
> **示例4**
>
> 输入
>
> 5
>
> 4 3
>
> 0 4
>
> 2 1
>
> 3 2
>
> 输出
>
> yes
>
> 说明
>
>
> 跳完第0个格子可以开启格子4，跳完格子4可以开启格子3，跳完格子3可以开启格子2，跳完格子2可以开启格子1，按照0->4->3->2->1这样就跳完所有的格子
>
> **示例5**
>
> 输入
>
> 4
>
> 1 2
>
> 1 0
>
> 输出
>
> yes
>
> 说明
>
>
> 总共4个格子[0,1,2,3]，格子1和格子3没有前置条件所以默认开启，格子1可以开启格子0和格子2，所以跳到格子1之后就可以开启所有的格子，因此可以跳完所有格子

# 思路

> # 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    # 输入获取
    n = int(input())
    steps = []
    while True:
        try:
            line = input()
            if "" == line:
                break
            steps.append([int(x) for x in line.split(" ")])
        except:
            break
    input_info = [0 for x in range(n)]
    step_map = {}
    for j in range(len(steps)):
        input_info[steps[j][1]] += 1
        if steps[j][0] in step_map:
            step_map[steps[j][0]].append(steps[j][1])
        else:
            step_map[steps[j][0]] = []
            step_map[steps[j][0]].append(steps[j][1])
    
    start_steps = []
    for i in range(n):
        if input_info[i] == 0:
            start_steps.append(i)
    
    count = 0
    flag = True
    while (True):
        if (len(start_steps)<=0):
            if count == n :
                print("YES")
                flag = False
            break
        else:
            start = start_steps[-1]
            start_steps.pop()
            count += 1
    
            if start in step_map and len(step_map[start])!=0:
                i=0
                while(True):
                    if(i>=len(step_map[start])):
                        break;
                    else:
                        input_info[step_map[start][i]] -= 1
                        if input_info[step_map[start][i]] == 0:
                            start_steps.append(step_map[start][i])
                    i+=1
    if flag:
        print("NO")
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

