**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 对一个数据a进行分类，分类方法为:此数据a ( **四个字节大小)的四个字节相加对一个给定的值b取模，如果得到的结果**
> 小于一个给定的值c，则数据a为有效类型，其类型为取模的值;如果得到的结果大于或者等于c，则数据a为无效类型。  
>  比如一个数据a=0x01010101，b=3，按照分类方法计算(0x01+0x01+0x01+0x01)
> %3=1，所以如果c=2.则此a为有效类型，其类型为1，如果c=1，则此a为无效类型:  
>  又比如一个数据a=0x01010103，b=3，按照分类方法计算(0x01+0x01+0x01+0x03)
> %3=0，所以如果c=2，则此a为有效类型，其类型为0，如果c=0，则此a为无效类型  
>  输入12个数据，第一个数据为C，第二个数据为b，剩余10个数据为需要分类的数据，请找到有效类型中包含数据最多的类型，并输出该类型含有多少个数据。
>
> **输入描述:**  
>  输入12个数据，用空格分隔，第一个数据为c，第二个数据为b，剩余10个数据为需要分类的数据。  
>  **输出描述:**  
>  输出最多数据的有效类型有多少个数据  
>  **示例1  
>  输入:**  
>  3 4 256 257 258 259 260 261 262 263 264 265  
>  输出:  
>  3  
>  说明:  
>  10数提4个字节相加后的结里分别为12 3 45 67 89 10.故对4取模的结果为1230123012C为3，所以0
> 12都是有效类型，类型为1和2的有3个数据，类型为0的只有2个数据，故输出3
>
> **示例2  
>  输入:**  
>  1 4 256 257 258 259 269 261 262 263 264 265  
>  输出:
>
> 2  
>  说明:10个数据4个字节相加后的结果分别为12 3 45 6 78 9 10，故对4取模的结果为1 230 123 0
> 12，为1，所以只有0是有效类型类型为0的有2个数据，故输出2  
>  解题思路:  
>  这道题其实没啥难度，最主要的还是要读懂题目意思。通过题目给出的 0x01010101，我们可以判断出这是十六进制数据，而根据
> (0x01+0x01+0x01+0x01) %3=1，可以看出是将十六进制中的8位数平分为4个两位数然后进行相加。

# 思路

> 1：其实就是照着题目中说的逻辑算个数而已。对16进制比较熟悉的应该是没压力了。

#

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
    
    data = [int(x) for x in input().split(" ")]
    
    c = data[0]
    b = data[1]
    a = data[2:]
    data_map={}
    for i in a:
        tmp=str(i)
        tmp="0"*(8-len(tmp))+tmp
        sum=0
        for j in range(0,len(tmp),2):
            g=tmp[j:j+2]
            sum+=int(g,16)
        s=sum%b
        if s<c:
            if s not in data_map.keys() :
                data_map[s]=0
            data_map[s]+=1
     
     
     
    print(sorted(data_map.items(),key = lambda x:x[1],reverse = True)[0][1])

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

