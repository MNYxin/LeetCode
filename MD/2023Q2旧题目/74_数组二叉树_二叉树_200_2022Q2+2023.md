# 题目

>
> 二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1，对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2N和2N+1，并且我们用值-1代表一个节点为空。
>
> 给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。
>
> **输入描述**  
>  输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分隔。  
>  注意第一个元素即为根节点的值，即数组的第N个元素对应下标N，下标0在树的表示中没有使用，所以我们省略了。  
>  输入的树最多为7层。  
>  **输出描述**  
>  输出从根节点到最小叶子节点的路径上，各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。
>
> **示例 1：**  
>  输入  
>  3 5 7 -1 -1 2 4  
>  输出  
>  3 7 2  
>  说明  
>  最小叶子节点的路径为3 7 2
>
> **示例 2：**  
>  输入  
>  5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6  
>  输出  
>  5 8 7 6  
>  说明  
>  最小叶子节点的路径为5 8 7 6，注意数组仅存储至最后一个非空节点，故不包含节点“7”右子节点的-1
>
> ![](https://img-blog.csdnimg.cn/d9fb087afbed4094ba1042d27a375156.png)

# 思路

> 1：树的递归操作，先找到最小的根节点，注意二叉树是用数组表示的，用 2N和2N+1来表示左右子树。
>
> 2：然后根据这个根节点去推导路径

# 考点

> 1：二叉树
>
> 2：递归法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    nums = [int(x) for x in input().split(" ")]
    min_value = float('inf')
    
    def dfs(nums, idx): 
        #超出数组范围或为-1则为叶子节点
        if ((2 * idx + 1 >= len(nums) or nums[2 * idx + 1] == -1)
                and (2 * idx + 2 >= len(nums) or nums[2 * idx + 2] == -1)):
            return idx
        else:
            idx_left = dfs(nums, 2 * idx + 1) 
            idx_right = dfs(nums, 2 * idx + 2) 
            #比较找最小
            if (idx_left >= len(nums) or nums[idx_left] == -1):
                return idx_right
            elif (idx_right >= len(nums) or nums[idx_right] == -1): 
                return idx_left
            else: 
                if(nums[idx_left] < nums[idx_right]):
                    return idx_left
                else:
                    return idx_right
                
            
    #找到最小子节点
    idx = dfs(nums, 0)
    
    #保存这个节点所对应的路径
    path = []
    while (idx > 0):
        path.append(nums[idx])
        idx = int((idx - 1) / 2)
    
    path.append(nums[0])
    output_str =""
    for i in range(len(path)):
        if (i == len(path) - 1):
            output_str += str(path[i])
        else:
            output_str += str(path[i]) + " "
    print(output_str[::-1])
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
>
> **【华为od机试真题Python+JS+Java合集】【超值优惠】： ** ** ** ** ** ** ** ** ** ** ** ** **
> ** **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")********************************
>
> **【华为od机试真题Python】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")********************************
>
> **【华为od机试真题JavaScript】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")********************************
>
> **【华为od机试真题Java】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")********************************
>
> **【华为od机试真题C++】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")********************************
>
> **【华为od机试真题C语言】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")********************************
>
> **【华为od面试手撕代码题库】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")********************************

