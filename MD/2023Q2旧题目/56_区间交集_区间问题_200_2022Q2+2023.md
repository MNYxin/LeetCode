**目录**

题目

思路

考点

Code

* * *

# 题目

> 给定一组闭区间，其中部分区间存在交集。
>
> 任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。
>
> 公共区间之间若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。
>
> 按升序排列输出合并后的区间列表。
>
> **输入描述**
>
> 一组区间列表，区间数为 N: 0<=N<=1000;区间元素为 X: -10000<=X<=10000。
>
> **输出描述**
>
> 升序排列的合并区间列表
>
> **备注:**
>
> 1、区间元素均为数字，不考虑字母、符号等异常输入。
>
> 2、单个区间认定为无公共区间。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> 0 3
>
> 1 3
>
> 3 5
>
> 3 6
>
> **输出**
>
> 1 5
>
> **说明**
>
>
> [0,3]和[1,3]的公共区间为[1,3]，[0,3]和[3,5]的公共区间为[3,3]，[0,3]和[3,6]的公共区间为[3,3]，[1,3]和[3,5]的公共区间为[3,3]，[1,3]和[3,6]的公共区间为[3,3]，[3,5]和[3,6]的公共区间为[3,5]，公共区间列表为[[1,3],[3,3],[3,5]]；[1,3],[3,3],[3,5]存在交集，须合并为[1,5]。

# 思路

> 1：注意审题，是 **公共区间之间若存在交集，再合并** ，不是之前的区间合并。

# 考点

> 1：数据结构
>
> 2：排序

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    # input
    ranges = []
    for line in sys.stdin:
        a = line.split()
        left = int(a[0])
        right = int(a[1])
        ranges.append((left, right))
    
    ORI_LEN = len(ranges)
    LEN = len(ranges)
    pre_LEN = LEN + 1
    
    
    # find out intersection
    new_ranges = set()
    for i in range(LEN):
        for j in range(i + 1, LEN):
            if ranges[i][1] >= ranges[j][0]:
                left = max(ranges[i][0], ranges[j][0])
                right = min(ranges[i][1], ranges[j][1])
                if left <= right:
                    new_ranges.add((left, right))
    
    
    ranges = list(new_ranges)
    ranges.sort()
    
    # find out union
    new_ranges = set()
    LEN = len(ranges)
    for i in range(LEN):
        if ranges[i] == None:
            continue
        left = ranges[i][0]
        right = ranges[i][1]
        for j in range(i + 1,  LEN):
            if ranges[j] == None:
                continue
            
            if ranges[j][0] <= right:
                right = max(right, ranges[j][1])
                ranges[j] = None
            else:
                break
        new_ranges.add((left, right))
    
    ranges = list(new_ranges)
    ranges.sort()
    
    if len(ranges) == 0:
        print("None")
    else:
        for l, r in ranges:
            print(f"{l} {r}")
              
    
    

