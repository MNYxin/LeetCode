**目录**

题目

思路

考点

Code

* * *

# 题目

>
> 在做物理实验时，为了计算物体移动的速率，通过相机等工具周期性的采样物体移动能离。由于工具故障，采样数据存在误差甚至相误的情况。需要通过一个算法过滤掉不正确的采样值，不同工具的故意模式存在差异，算法的各关门限会根据工具类型做相应的调整，请实现一个算法，计算出给定一组采样值中正常值的最长连续周期。
>
>  
>  判断第1个周期的采样数据s0是否正确的规则如下(假定物体移动速率不超过10个单元前一个采样周期S[i-1]):
>
>   * S[i]<=0，即为错误值
>   * S[i]<S[i-1]，即为错误值
>   * S[i]-S[i-1]>=10，即为错误值·其它情况为正常值
>

>
> 判断工具是否故障的规则如下:
>
>   * 在M个周期内，采样数据为错误值的次数为T(次数可以不连续)，则工具故障
>

>
> 判断故障恢复的条件如下:
>
>   * 产生故障后的P个周期内，采样数据一直为正常值，则故障恢复
>

>
> 错误采样数据的处理方式
>
>   * 检测到故障后，丢弃从故障开始到故障恢复的采样数据
>   * 在检测到工具故障之前，错误的采样数据，则由最近一个正常值代替;如果前面没有正常的采样值，则丢弃此采样数据
>

>
> 给定一段周期的采样数据列表S，计算正常值的最长连续周期。
>
>  
> **输入描述:**  
>  故障确认周期数和故障次数门限分别为M和T，故障恢复周期数为P。第i个周期，检测点的状态为S[i]
>
> 输入为两行，格式如下:
>
> M T F  
>  s1 s2 s3 ...  
>  M、t 和 e的取值范围为[1100000]  
>  s1取值范围为[0，100000]，从0开始编号  
>  **输出描述**  
>  一行，输出正常值的最长连续周期
>
> **示例：**
>
> **输入：**
>
> 10 6 3
>
> -1 1 2 3 100 10 13 9 10
>
> **输出：**
>
> **8**

# 思路

> 1：读懂题目的话这题就解了。三种情况：
>
> 数据异常：三个条件
>
> 工具故障：数据异常一定条件下，工具故障
>
> 故障恢复：数据正常后的一定条件下，故障恢复。
>
> 2：在这三种情况之下，错误数据有两种处理方式：
>
> 丢弃故障开始到故障恢复的采样数据
>
> 故障开启之前的数据如果故障数据它之前有正常值，则替代，若无正常值，则丢弃。
>
> 3：这题就是条件多，分支多。

# 考点

> 1：过程模拟

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    m, t, p = list(map(int, input().split()))
    s_list = list(map(int, input().split()))
    items = [0 for _ in range(len(s_list))]
    for i in range(len(s_list)):
        if s_list[i] <= 0:
            items[i] = 0
        elif i > 0 and ((s_list[i] - s_list[i - 1] >= 10) or s_list[i] < s_list[i - 1]):
            items[i] = 0
        else:
            items[i] = 1
    i = 0
    
    while i < len(s_list):
        if items[i] == 0 and i > 0 and items[i - 1] == 1:
            s_list[i], items[i] = s_list[i - 1], 1
        error_num, corrent, j = 0, 0, i
        while m > 0 and j < len(s_list):
            if items[j] == 0:
                error_num += 1
                if error_num >= t:
                    corrent = j - 1 if j > 0 else 0
            j += 1
        if error_num >= t:
            pos, k = False, 0
            while k < i and items[k] != 1:
                k += 1
            else:
                pos = True
            if i + t == len(s_list) - 1:
                k = i
                while k < corrent + 1:
                    s_list[k], items[k] = s_list[i - 1], 1
                    k += 1
                break
            elif i + m <= len(s_list):
                for k in range(i, len(s_list)):
                    if k < corrent +1:
                        s_list[k] = s_list[i-1] if i > 0 else s_list[0]
                        items[k] = 1
                    else:
                        items[k] = 0
            else:
                for k in range(i, i + m):
                    if k < corrent + 1:
                        s_list[k] = s_list[i -1]
                        items[k] = 1
                    else:
                        items[k] = 0
                if i + m + p >= len(s_list) + 1:
                    for k in range(i, len(s_list)):
                        items[k] = 0
                    else:
                        items[k], i = 0, k +p
        else:
            i += 1
    res, location = 0, 0
    for item in range(len(items)):
        if items[item] != 1:
            if location > res:
                res = location
            location = 0
        else:
            location += 1
    print(max(res, location))

