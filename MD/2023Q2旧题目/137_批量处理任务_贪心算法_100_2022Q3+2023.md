**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 某实验室计算机待处理任务以 [start,end,period] 格式记于二维数组 tasks，表示完成该任务的时间范围为起始时间 start
> 至结束时间 end 之间，需要计算机投入 period 的时长，注意：
>
> period 可为不连续时间  
>  首尾时间均包含在内  
>  处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。
>
> **示例 1：**
>
> 输入：tasks = [[1,3,2],[2,5,3],[5,6,2]]
>
> 输出：4
>
> 解释：  
>  tasks[0] 选择时间点 2、3；  
>  tasks[1] 选择时间点 2、3、5；  
>  tasks[2] 选择时间点 5、6；  
>  因此计算机仅需在时间点 2、3、5、6 四个时刻保持开机即可完成任务。
>
> **示例 2：**
>
> 输入：tasks = [[2,3,1],[5,5,1],[5,6,2]]
>
> 输出：3
>
> 解释：  
>  tasks[0] 选择时间点 2 或 3；  
>  tasks[1] 选择时间点 5；  
>  tasks[2] 选择时间点 5、6；  
>  因此计算机仅需在时间点 2、5、6 或 3、5、6 三个时刻保持开机即可完成任务。
>
> 提示：
>
> 2 <= tasks.length <= 10^5  
>  tasks[i].length == 3  
>  0 <= tasks[i][0] <= tasks[i][1] <= 10^9  
>  1 <= tasks[i][2] <= tasks[i][1]-tasks[i][0] + 1

# 思路

> 1：这题是leetcode的原题，还是比较难的。自己写的太丑陋了，给出大神的两个解法吧。
>
> 第一个解法是依赖的贪心+优先队列：[优先队列贪心-C++/Java/Python/Rust/Kotlin/Go - 批量处理任务 -
> 力扣（LeetCode）](https://leetcode.cn/problems/t3fKg1/solution/you-xian-dui-lie-
> tan-xin-rust-by-lucifer-4spv/ "优先队列贪心-C++/Java/Python/Rust/Kotlin/Go -
> 批量处理任务 - 力扣（LeetCode）")
>
> 第二个解法是依赖的前缀和的思想：
>
> [C++20行代码，使用map手动维护前缀和，时间复杂度O(nlog(n))；另附spfa代码 - 批量处理任务 -
> 力扣（LeetCode）](https://leetcode.cn/problems/t3fKg1/solution/cshi-yong-
> mapshou-dong-wei-hu-qian-zhui-xcqge/
> "C++20行代码，使用map手动维护前缀和，时间复杂度O\(nlog\(n\)\)；另附spfa代码 - 批量处理任务 -
> 力扣（LeetCode）")
>
> 都非常牛逼，我这里只参考第一种给出一个小例子吧。

#

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
    
    
    def processTasks(tasks):
        n = len(tasks)
        #[左端点,右端点,前缀和] 
        q = [[-1, -1, 0] for _ in range(n + 1)]
        now = 1
        # 按右端点排序
        tasks.sort(key=lambda x: (x[1], x[0]))
        q[1][0] = tasks[0][1] - tasks[0][2] + 1 
        q[1][1] = tasks[0][1]
        q[1][2] = tasks[0][2]
        for i in range(1, len(tasks)):
            left = 0
            right = now
            pos = -1
            # 二分找到序列中当前任务区间覆盖的位置
            while left <= right:
                mid = (left + right) // 2
                if tasks[i][0] <= q[mid][1]:
                    pos = mid
                    right = mid - 1
                else:
                    left = mid + 1
            # 计算还需安排的开机时间
            if pos == -1:
                u = tasks[i][2]
            else:
                u = tasks[i][2] - (q[now][2] - q[pos][2]) - min(q[pos][1] - q[pos][0] + 1, q[pos][1] - tasks[i][0] + 1)
            if u <= 0:
                continue
            # 贪心从右到左安排开机时间
            r = tasks[i][1]
            delta = min(r - q[now][1], u)
            u -= delta
            l = r - delta + 1
            while u > 0:
                l = q[now][0]
                now -= 1
                delta = min(l - q[now][1] - 1, u)
                u -= delta
                l = l - delta
            # 将当前开机区间插入序列
            now += 1
            q[now][0] = l
            q[now][1] = r
            q[now][2] = q[now - 1][2] + r - l + 1
        return q[now][2]
    
    print(processTasks([[1,3,2],[2,5,3],[5,6,2]]))
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

