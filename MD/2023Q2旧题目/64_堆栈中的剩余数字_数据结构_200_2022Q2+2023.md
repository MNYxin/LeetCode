**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 向一个空栈中依次存入正整数， 假设入栈元素 n(1<=n<=2^31-1)按顺序依次为 nx…n4、 n3、n2、 n1, 每当元素入栈时，如果
> n1=n2+…+ny(y 的范围[2,x]， 1<=x<=1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)。
>
> 如：依次向栈存入 6、 1、 2、 3, 当存入 6、 1、 2 时，栈底至栈顶依次为[6、 1、 2]；当存入 3时， 3=2+1， 3、 2、 1
> 全部出栈，重新入栈元素 6(6=2*3)，此时栈中有元素 6；
>
> 因为 6=6，所以两个 6 全部出栈，存入 12，最终栈中只剩一个元素 12。
>
> **输入描述:**
>
> 使用单个空格隔开的正整数的字符串，如”5 6 7 8″， 左边的数字先入栈，输入的正整数个数为 x， 1<=x<=1000。
>
> **输出描述:**
>
> 最终栈中存留的元素值，元素值使用空格隔开，如”8 7 6 5″， 栈顶数字在左边。 6 1 2 3
>
> **示例 1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5 10 20 50 85 1`
>
> **输出**
>
> `1 170`
>
> **说明**
>
> 5+10+20+50=85， 输入 85 时， 5、 10、 20、 50、 85 全部出栈，入栈 170，最终依次出栈的数字为 1 和 170。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `6 7 8 13 9`
>
> **输出**
>
> `9 13 8 7 6`
>
> **示例3** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `1 2 5 7 9 1 2 2`
>
> **输出**
>
> `4 1 9 14 1`

# 思路

> 1：模拟整个入栈出栈的过程即可

# 考点

> 1：模拟过程

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    nums = [int(x) for x in input().split(" ")]
    n = len(nums)
     
    dp = [0] * n
    dp[0] = nums[0]
    for i in range(1, n):
        dp[i] = dp[i - 1] + nums[i]
    
    for i in range(1, n):
        if dp[i - 1] == nums[i]:
            nums[i] *= 2
            for j in range(0, i):
                nums[j] = 0
                dp[j] = 0
            continue
    
        if dp[i - 1] > nums[i]:
            pre_sum = dp[i - 1] - nums[i]
            for j in range(i - 1):
                if dp[j] == pre_sum:
                    nums[i] *= 2
                    for k in range(j + 1, i):
                        nums[k] = 0
                        dp[k] = dp[j]
                    break
    
                if dp[j] > pre_sum:
                    break
    
    result = list(filter(lambda x: x != 0, nums))
    result.reverse()
    print(" ".join([str(x) for x in result]))
     

