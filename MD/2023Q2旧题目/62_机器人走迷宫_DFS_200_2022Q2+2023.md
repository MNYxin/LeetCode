# 题目

> 机器人走一个迷宫，给出迷宫的x和y(x*y的迷宫)并且迷宫中有障碍物,输入k表示障碍物有k个，并且会将障碍物的坐标挨个输入。
>
> 机器人从0,0的位置走到x,y的位置并且只能向x,y增加的方向走，不能回退，
>
> 如代码类注释展示的样子，#表示可以走的方格，0代表障碍，机器人从0,0的位置只能向下或者向前走到出口，
>
> 其中会有不可达方格和陷阱方格。
>
> 不可达方格为第四行前三个，该机器人在行走路径上不可能走到的方格，陷阱方格如第一行最后两个，走进之后则不能抵达终点。
>
> ![](https://img-blog.csdnimg.cn/9f54cfe74709482ca23ec88b1591e564.png)
>
> 要求: 输出陷阱和不可达方格方格数量。
>
> **输入描述：**
>
> 1）第一行为房间的X 和Y （0<=X/Y <=1000）
>
> 2) 第一行为房间中的墙壁障碍物个数 N，0<= N <=X*Y ）
>
> 3) 接下来会有N行墙壁的坐标，同一行中若有多个障碍物，以空格隔开，所有数据输入均合法。
>
> **输出描述：**
>
> 陷阱方格与不可达方格数量，以空格隔开。
>
> **示例1：**
>
> 输入：
>
> 6 4
>
> 5
>
> 0 2
>
> 1 2
>
> 2 2
>
> 4 1
>
> 5 1
>
> 输出：
>
> 2 3

# 思路

> 1：典型的路径问题，DFS即可解决。（也有用动态规划的，我觉的不好想出来）
>
> 2：设置方格的状态，0为不可达，1为障碍物，2为可达到，3为陷阱。
>
> 3：先按照输入将固定位置上置为1，然后从左下角开始走即可。
>
> 深度优先遍历图的方法是，从图中某顶点v出发：
>
> （1）访问顶点v；
>
> （2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
>
> （3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。

# 考点

> 1：DFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    matrix = []
    for i in range(m):
        matrix.append([])
        for j in range(n):
            matrix[i].append(0)
    matrix[m - 1][n - 1] = 2
    
    cnt = int(input())
    walls = []
    for i in range(cnt):
        walls.append([int(x) for x in input().split(" ")])
    
    for i in range(cnt):
        matrix[walls[i][0]][walls[i][1]] = 1  
    
    def dfs(matrix, m,n,i,j):
        if i >= m or j >= n or matrix[i][j] in [1,3]:
            return 0
        
        if matrix[i][j] in [2]:
            return 1
     
        if matrix[i][j] == 0:
            flag1 = dfs(matrix, m,n,i+1,j)
            flag2 = dfs(matrix, m,n,i,j+1)
            if flag1 or flag2:
                matrix[i][j] = 2  
            else:
                matrix[i][j] = 3
     
        if(matrix[i][j] == 2):
            return 1
        return 0
    
    
    def cal(matrix, m, n, target):
        cnt = 0
        for i in range(m):
            for j in range(n):
                if(matrix[i][j] == target):
                    cnt+=1
        return cnt
    
    
    dfs(matrix, m, n, 0, 0)
    print(str(cal(matrix, m, n, 0)) + " " + str(cal(matrix, m, n, 3)))
    
    
    

> **【华为od机试真题Python+JS+Java合集】【超值优惠】： ** ** ** ** ** ** ** ** ** ** ** ** **
> ** **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")********************************
>
> **【华为od机试真题Python】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")********************************
>
> **【华为od机试真题JavaScript】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")********************************
>
> **【华为od机试真题Java】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")********************************
>
> **【华为od机试真题C++】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")********************************
>
> **【华为od机试真题C语言】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")********************************
>
> **【华为od面试手撕代码题库】： ** ** ** ** ** ** ** ** ** ** ** ** ** **
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")********************************

