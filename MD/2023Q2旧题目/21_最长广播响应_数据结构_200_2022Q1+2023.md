**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

>   * 某通信网络中有N个网络结点，用1到N进行标识。
>   * 网络中的结点互联互通，且结点之间的消息传递有时延，相连结点的时延均为一个时间单位。
>   * 现给定网络结点的连接关系link[i]={u，v}，其中u和v表示网络结点。
>   *
> 当指定一个结点向其他结点进行广播，所有被广播结点收到消息后都会在原路径上回复一条响应消息，请计算发送结点至少需要等待几个时间单位才能收到所有被广播结点的响应消息。
>

>
> **注：**
>
>   1. N的取值范围为[1，100];
>   2. 连接关系link的长度不超过3000，且1 <= u,v <= N;
>   3. 网络中任意结点间均是可达的;
>

>
> **输入描述：**
>
>   * 输入的第一行为两个正整数，分别表示网络结点的个数N，以及时延列表的长度T；
>   * 接下来的T行输入，表示结点间的连接关系列表；
>   * 最后一行的输入为一个正整数，表示指定的广播结点序号；
>

>
> **输出描述：**
>
>   * 输出一个整数，表示发送结点接收到所有响应消息至少需要等待的时长。
>   * 示例
>
> **输入**
>  
>     >     5 7
>     1 4
>     2 1
>     2 3
>     2 4
>     3 4
>     3 5
>     4 5
>     2
>  
>
>

>
> **输出**
>
>   * >     4
>  
>
>   * 说明
>
> 结点2到5的最小时延为2，到剩余结点的最小时延均为1，所以至少要等待2*2=4s。
>
>

# 思路

> 1：单源最短路径问题，找到起始节点到其他节点的最短路径的最大值 * 2即可。
>
> 2：典型的 BFS 问题。

# 考点

> 1：BFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    n, m = map(int, input().split())
    ref = {i + 1: {} for i in range(n)}
    for i in range(m):
        u, v = map(int, input().split())
        ref[u][v] = 1
        ref[v][u] = 1
    begin = int(input())
    seen = [0] * (n + 1)
    seen[begin] = 1
    count, q = 0, [begin]
    while True:
        temp = list()
        for item in q:
            for key in ref[item]:
                if seen[key] == 0:
                    seen[key] = 2
                    temp.append(key)
        if not temp:
            break
        q, count = temp, count + 1
    print(count * 2)

