**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定一个正整数数组，设为nums，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。
>
> **要求：**
>
>   1. 第一步必须从第一元素开始，且1<=第一步的步长<len/2;（len为数组的长度，需要自行解析）。
>   2. 从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少, 如果目标不可达返回 **-1** ，只输出最少的步骤数量。
>   3. 只能向数组的尾部走，不能往回走。
>

>
> **输入描述:**
>
>   * 由正整数组成的数组，以空格分隔，数组长度小于100， **请自行解析数据数量** 。
>

>
> **输出描述:**
>
>   * 正整数，表示最少的步数，如果不存在输出 **-1**
>

>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `7 5 9 4 2 6 8 3 5 4 3 9`
>
> **输出**
>
> `2`
>
> **说明**
>
> 第一步： 第一个可选步长选择2，从第一个成员7开始走2步，到达9；
>
> 第二步： 从9开始，经过自身数字9对应的9个成员到最后。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `1 2 3 7 1 5 9 3 2 1`
>
> **输出**
>
> `-1`

# 思路

> 1：看到题目里写了长度小于100，我感觉暴力法又可以上了，遍历每一种走法找出最小即可。复杂度就是O(n^2)，直接递归往前跳即可。
>
> 2：还有一个方法也可行，就是从后往前找，从最后一步，逐个往前遍历，往前递归的过程要省去很多的无效跳步，动态规划。

# 考点

> 1：动态规划的思想

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    import math
    
    str = input()
    strs = str.split(" ")
    arr = [int(item) for item in strs]
    
    num = len(arr)
    max_int=1<<31
    dp =[max_int for i in range(num)]
    dp[0] = 0
    for i in range(1,int(num/2)):
        dp[i]=1
        
        if(i+arr[i]<num):
            dp[i+arr[i]] = min(2, dp[i+arr[i]])
    for i in range(int(num/2),num):
        if(i+arr[i]<num):
            dp[i+arr[i]] = min(dp[i+arr[i]],dp[i]+1)
            
    if dp[num-1]==max_int:
        print(-1)
    else:
        print(dp[num-1])

