**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 有M*N的节点矩阵，每个节点可以向8个方向（上、下、左、右及四个斜线方向）转发数据包，每个节点转发时会消耗固定时延，
>
> 连续两个相同时延可以减少一个时延值（即当有K个相同时延的节点连续转发时可以减少K- 1个时延值），
>
> 求左上角（0，0）开始转发数据包到右下角（M-1，N- 1）并转发出的最短时延。
>
> **输入描述**
>
> 第一行两个数字，M、N，接下来有M行，每行有N个数据，表示M* N的矩阵。
>
> **输出描述**
>
> 最短时延值。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 3 3  
>  0 2 2  
>  1 2 1  
>  2 2 1
>
> 输出
>
> 3
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 3 3  
>  2 2 2  
>  2 2 2  
>  2 2 2
>
> 输出：
>
> 4

# 思路

> 1：关于图相关问题的解法，不是BFS 就是DFS，这里参考了大神 BFS 封装好的方法。思路是从一个顶点V0V0开始，辐射状地优先遍历其周围较广的区域。
>
> 2： **广度优先搜索BFS** （Breadth First Search）也称为宽度优先搜索，它是一种先生成的结点先扩展的策略。
>
>
> 在广度优先搜索算法中，解答树上结点的扩展是按它们在树中的层次进行的。首先生成第一层结点，同时检查目标结点是否在所生成的结点中，如果不在，则将所有的第一层结点逐一扩展，得到第二层结点，并检查第二层结点是否包含目标结点，……，对层次为n+1的任一结点进行扩展之前，必须先考虑层次完层次为n的结点的每种可能的状态。因此，对于同一层结点来说，求解问题的价值是相同的，可以按任意顺序来扩展它们。通常采用的原则是先生成的结点先扩展。
>
> 为了便于进行搜索，要设置一个表存储所有的结点。由于在广度优先搜索算法中，要满足先生成的结点先扩展的原则，所以存储结点的表一般采用队列这种数据结构。
>
> 在编写程序时，可用数组q模拟队列。front和rear分别表示队头指针和队尾指针，初始时front=rear=0。
>
> 元素x入队操作为 q[rear++]=x;
>
> 元素x出队操作为 x =q[front++];
>
> 广度优先搜索算法的搜索步骤一般是：
>
> （1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。
>
>
> （2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。
>
> （3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。
>
> 最终可能产生两种结果：找到目标结点，或扩展完所有结点而没有找到目标结点。
>
>
> 如果目标结点存在于解答树的有限层上，广度优先搜索算法一定能保证找到一条通向它的最佳路径，因此广度优先搜索算法特别适用于只需求出最优解的问题。当问题需要给出解的路径，则要保存每个结点的来源，也就是它是从哪一个节点扩展来的。
>
> 对于广度优先搜索算法来说，问题不同则状态结点的结构和结点扩展规则是不同的，但搜索的策略是相同的。广度优先搜索算法的框架一般如下：
>
> void BFS（）
>
> {
>
> 队列初始化；
>
> 初始结点入队；
>
> while （队列非空）
>
> {
>
> 队头元素出队，赋给current；
>
> while （current 还可以扩展）
>
> {
>
> 由结点current扩展出新结点new；
>
> if （new 重复于已有的结点状态） continue;
>
> new结点入队；
>
> if (new结点是目标状态)
>
> {
>
> 置flag= true; break;
>
> }
>
> }
>
> }
>
> }
>
>
> 对于不同的问题，用广度优先搜索法的算法基本上都是一样的。但表示问题状态的结点数据结构、新结点是否为目标结点和是否为重复结点的判断等方面则有所不同。对具体的问题需要进行具体分析，这些函数要根据具体问题进行编写。

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def bfs(m):
        M = len(m)
        N = len(m[0])
        dp = [[0 for x in range(N)] for y in range(M)]
        
       
        dp[0][0] = m[0][0]
        # 初始化第0列（它只可能从上面转换而来）
        for i in range(1,M):
            if(m[i][0] != m[i-1][0]):    # 当前值和上一个值不一样
                dp[i][0] = m[i][0] +  dp[i - 1][0] # 那么它需要在dp[i - 1][0]的基础上+自己的耗费
            else:
                dp[i][0] = m[i][0] +  dp[i - 1][0] - 1
            
        
    
        #初始化第1列（它只可能从左边转换而来）
        for j in range(1,N):
            if(m[0][j] != m[0][j - 1]):
                dp[0][j] = m[0][j] + dp[0][j - 1]
            else:
                dp[0][j] = m[0][j] + dp[0][j - 1] - 1
            
        
    
        for i in range(1,M):
            for j in range(1,N):
                up = m[i][j] + dp[i - 1][j] # 从上面走来
                if(m[i][j] == m[i - 1][j]):  
                    up = up - 1  
                
    
                left = m[i][j] + dp[i][j - 1]  # 从左边来
                if(m[i][j] == m[i][j - 1]):
                    left = left - 1
                
    
                tri = m[i][j] + dp[i - 1][j - 1] # 从上斜边来
                if(m[i][j] == m[i][j - 1]):
                    tri = tri - 1
                
                dp[i][j] = min(left, min(up, tri))
            
        
            
        return dp[M - 1][N - 1]
    
    
    
    # 输入获取
    input_param = [int(x) for x in input().split(" ")]
    m =input_param[0]
    n = input_param[1]
    edges = []
    for i in range(m):
        edges.append([int(x) for x in input().split(" ")])
    print(bfs(edges))
     

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

