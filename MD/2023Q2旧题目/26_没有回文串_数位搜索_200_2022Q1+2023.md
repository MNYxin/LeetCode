>
> 回文串的定义：正读和反读都一样的字符串现在已经存在一个不包含回文串的字符串，字符串的字符都是在英语字母的前N个,且字符串不包含任何长度大于等于2的回文串；
>
> 请找出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串。
>
> 如果不存在，请输出NO。
>
> **输入描述**
>
> 输入包括两行。
>
> 第一行有一个整数:N（1<=N<=26），表示字符串的每个字符范围都是前N的英语字母。
>
> 第二行输入一个字符串（输入长度<=10000），输入保证这个字符串是合法的并且没有包含回文串。
>
> **输出描述**
>
> 输出下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串；
>
> 如果不存在,请输出”NO“。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3`
>
> `cba`
>
> **输出**
>
> `NO`
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4`
>
> `abcd`
>
> **输出**
>
> `abda`

> 1：这题目描述就很绕，好好理解理解
>
>   * 第一个核心点：它只由前N个小写字母组成（不一定全部用），如果输入4，那么这个字符串只会有abcd四个字母组合而成。
>   * 第二个核心点：下一个字典序的不包含回文串的、字符都是在英语字母的前N个、且长度相同的字符串。输出要求翻译一下就是：
> **下一个字典序、不包含回文串、也使用前N个字母，长度相同** 。
>

>
> 2： **字符串不包含任何长度大于等于2的回文串** 。
>
>   1. 长度为2的回文串，aa, 也就是说整个字符串没有两个相邻的字符是相同的。
>   2. 如果没有长度为3的子回文串，aba, 这种情况也是不会出现了。
>

>
> 综上，只要保证任意位置连续三个字母均不想等，那么这个字符串肯定不是回文串。
>
> 3： **下一个字典序** ，比如aba -> abb就是下一个字典序，也就是 **最右边的字母往字典序后开始遍历** 。
>
>
> 4：因为输入的字符串就是不包含回文串的，所以从最后一个字母按照字典序开始遍历的时候，只要满足和i-1，i-2位均不相同，那么此时也是一个满足条件的字符串。
    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def dfs(input_chars, index, flag, target, container):
        if index == len(input_chars):
            output_str = ""
            i=0
            while(True):
                if(i>=len(container)):
                    break
                else:
                    output_str += chr(container[i])
                i+=1
            return output_str
     
        if flag:
            small = input_chars[index]
        else:
            small = 97
        j = small
        while(True):
            if(j>target):
                break
            else:
                if (flag and index == len(input_chars) - 1 and j == small) or \
                    (index >= 1 and j == container[index - 1]) or  \
                    (index >= 2 and j == container[index - 2]):
                    target = target
                else:
                    container.append(j)
                    result = dfs(input_chars, index + 1, flag and j == small, target, container)
                    if result is None:
                        container.pop()
                    else:
                        return result
            j+=1
        return None
     
    n = int(input())
    print(dfs([ord(x) for x in input()], 0, True, 96 + n, []) or "NO")

