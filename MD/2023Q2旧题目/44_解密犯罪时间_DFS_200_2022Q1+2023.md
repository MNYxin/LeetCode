**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。
>
> 根据警察和线人的约定，为了隐蔽，该时间是修改过的，
>
> 解密规则为：利用当前出现过的数字，构造下一个距离当前时间最近的时刻，则该时间为可能的犯罪时间。
>
> 每个出现数字都可以被无限次使用。
>
> **输入描述**
>
> 形如HH:SS字符串，表示原始输入。
>
> **输出描述**
>
> 形如HH:SS的字符串，表示推理处理的犯罪时间。
>
> **备注**
>
> 1.可以保证现任给定的字符串一定是合法的。
>
> 例如，“01:35”和“11:08”是合法的，“1:35”和“11:8”是不合法的。
>
> 2.最近的时刻可能在第二天。
>
> * * *
>
> **示例**
>
> 20:12得到20:20
>
> 23:59得到22:22
>
> 12:58得到15:11
>
> 18:52得到18:55
>
> 23:52得到23:53
>
> 09:17得到09:19
>
> 07:08得到08:00

# 思路

> 1：先搞明白题目吧，这题目第一遍看还挺绕，就是 **只能用输入的四个数组组装成下一个最近的时间，且数字可以重复使用** 。
>
> 2：如果只有四个数字，可以重复使用，那么最多也就4^4种情况，我们分别算出各个组合的时间大小，转成分钟数之后，比较一下就行。
>
> 3：注意一些特殊情况，比如时间的各位置上的取值范围。

# ![在这里插入图片描述](https://img-
blog.csdnimg.cn/4eeae77ba43048a4bd81227a69c7ab5a.png)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def cal(s):
        nums_list = [int(i) for i in s if i != ":"]
        H, M = [int(i) for i in s.split(":")]
        time = []
        for i in nums_list:
            for j in nums_list:
                time.append(str(i) + str(j))
        # 存放分钟
        time1=[]
        # 存放小时
        time2=[]
        for i in range(len(time)):
            if int(time[i]) > M and int(time[i]) <= 59: 
                time1.append(time[i])
     
        if len(time1)>0:
            time1.sort()
            if H < 10: 
                return '0'+str(H) +":"+ time1[0]
            else:
                return  str(H) + ":" + time1[0]
        else:
            for i in range(len(time)):
                if int(time[i]) > H  and int(time[i]) <=23 :
                    time2.append(time[i])
            if len(time2)>0:
                time2.sort()
                return str(time2[0]) +":"+ str(min(time))
            else:
                return str(min(time)) + ":" + str(min(time))
     
    s = input()
    print(cal(s))
    
    
     
    
      
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

