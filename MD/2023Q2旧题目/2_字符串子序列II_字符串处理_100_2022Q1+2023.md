**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定字符串 target 和 source，判断 target是否为 source 的子序列。你可以认为target和 source
> 中仅包含英文小写字母。
>
> 字符串 source 可能会很长（长度~=500,000），而 target是个短字符串（长度<=100)。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。
>
> （例如，”abc”是”aebycd”的一个子序列，而”ayb”不是）。
>
> 请找出最后一个子序列的起始位置。
>
> **输入描述：**
>
> 第一行为target，短字符串（长度 <=100）  
>  第二行为source，长字符串（长度 ~= 500,000）
>
> **输出描述：**
>
> 最后一个子序列的起始位置，即最后一个子序列首字母的下标
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `abc`  
> `abcaybec`
>
> **说明**
>
> 这里有两个abc的子序列满足，取下标较大的，故返回3。
>
> **备注：**
>
> 若在source中找不到target，则输出-1。

# 思路

> 1：经典的双指针法，既然要找最后一个子序列，那么就分别从 target 和 source
> 的末尾往前遍历即可，如果指针所指位置字符相等，两个指针都左移一位，否则只将source指针左移一位，直到target的指针指向头部结束。
> **复杂度O(n^2)**
>
> 2：记得最后找不到 target，需要返回 -1.

# 考点

> 1：双指针法
>
> 2：字符串匹配

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    s1, s2 = input(), input()
    idx, ans = 1, -1
    i = len(s1) - 1
    while i > -1:
        for j in range(len(s2) - idx, -1, -1):
            idx += 1
            if s1[i] == s2[j]:
                if i == 0:
                    ans = j
                break
        i -= 1
    print(ans)
    

