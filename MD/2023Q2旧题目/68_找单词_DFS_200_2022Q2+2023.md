**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

>
> 给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串“N”。
>
> 1.需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。
>
> 2.同一个单元格内的字母不允许被重复使用。
>
> 3.假定在数组中最多只存在一个可能的匹配。
>
> **输入描述:**
>
> 1\. 第1行为一个数字N指示二维数组在后续输入所占的行数。
>
> 2\. 第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。
>
> 3\. 第N+2行为待查找的字符串，由大写字符组成。
>
> 4\. 二维数组的大小为N*N，0<N<=100。
>
> 5\. 单词长度K，0<K<1000。
>
> **输出描述:**
>
> 输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,”+第2个字符行下标+”,”+第2个字符列下标…
> +”,”+第N个字符行下标+”,”+第N个字符列下标。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4`  
> `A,C,C,F`  
> `C,D,E,D`  
> `B,E,S,S`  
> `F,E,C,A`  
> `ACCESS`
>
> **输出**
>
> `0,0,0,1,0,2,1,2,2,2,2,3`
>
> **说明**
>
> ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标位置。

# 思路

> 1：这题同样是一个搜索题目，DFS 即可，但是有一点不一样的是，他要输出每个字符所在的位置，这就要我们创建一个额外的数据结构来保存下来所有的位置。

# 考点

> 1：DFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    
    def get_res(matrix, word):
        m, n, w = len(matrix), len(matrix[0]), len(word)
    
        def dfs(i, j, k):
            if not 0 <= i < m or not 0 <= j < n or matrix[i][j] != word[k]:
                return False
            if k == w - 1:
                path.append((i, j))
                ans = list()
                for a, b in path:
                    ans.extend([str(a), str(b)])
                print(",".join(ans))
                return True
            matrix[i][j] = ""
            path.append((i, j))
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j - 1, k + 1) or dfs(i, j + 1, k + 1)
            matrix[i][j] = word[k]
            path.remove((i, j))
            return res
    
        for i in range(m):
            for j in range(n):
                if dfs(i, j, 0):
                    return True
        return False
    
    
    
    row = int(input())
    matrix = [input().split(",") for _ in range(row)]
    word = input()
    path = list()
    if not get_res(matrix, word):
        print("N")
    

