**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

>   * 请实现一个简易内存池,根据请求命令完成内存分配和释放。
>   * 内存池支持两种操作命令，REQUEST和RELEASE，其格式为：
>   * REQUEST=请求的内存大小
> 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error。
>   * RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。
>

>
> * * *
>
> **注意：**
>
>   1. 内存池总大小为100字节。
>   2. 内存池地址分配必须是连续内存，并优先从低地址分配。
>   3. 内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。
>   4. 不会释放已申请的内存块的中间地址。
>   5. 释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。
>

>
> **解答要求**
>
>   * 时间限制: 1000ms, 内存限制: 256MB
>

>
> 首行为整数 N , 表示操作命令的个数，取值范围：0 < N <= 100。
>
> 接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”分割。
>
> **样例1：**
>
> **输入**
>
> `2`
>
> `REQUEST=10`
>
> `REQUEST=20`
>
> **输出**
>
> `0`
>
> `10`
>
> **样例2：**
>
> `5`
>
> `REQUEST=10`
>
> `REQUEST=20`
>
> `RELEASE=0`
>
> `REQUEST=20`
>
> `REQUEST=10`
>
> **输出样例2：**
>
> `0`
>
> `10`
>
> `30`
>
> `0`
>
> **提示说明：**
>
> 第一条指令，申请地址0~9的10个字节内存，返回首地址0
>
> 第二条指令，申请地址10~29的20字节内存，返回首地址10
>
> 第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出
>
> 第四条指令，申请20字节内存，09地址内存连续空间不足20字节，往后查找到3049地址，返回首地址30
>
> 第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0

# 思路

> 1：读完题，考察的核心还是数据结构。 **怎么保存已经使用多少内存？怎么保存已经使用内存的结构信息？**
>
> 2：知道怎么保存状态以后，就是怎么分配和释放内存了，其实就是操作数据结构。

#

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    class Solution:
        def __init__(self):
            self.allow = {}
            self.head=0
            self.end=100
        def request(self,size):
            addressHead = self.head
            if size<=0 or size>100:
                return 'error'
            if len(self.allow)==0:
                self.allow[self.head]=size
            else:
                headList = [k for k,v in self.allow.items()]
                for i in range(len(headList)):
                    if headList[i]-addressHead >= size:
                        self.allow[addressHead]=addressHead+size
                    else:
                        addressHead = self.allow.get(headList[i])
                if size<=(self.end-addressHead):
                    self.allow[addressHead]=addressHead+size
                else:
                    return 'error'
            return str(addressHead)
        def release(self,startAddress):
            try:
                self.allow[startAddress]
                del self.allow[startAddress]
                return True
            except Exception as e:
                return False
    
    so = Solution()
    x=int(input())
    for i in range(x):
        temp = input().split("=")
        if temp[0]=='REQUEST':
            print(so.request(int(temp[1])))
        else:
            ret = so.release(int(temp[1]))
            if not ret:
                print('error')
    
    
    
    
     
    
      
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

