**目录**

题目

思路

考点

Code

* * *

# 题目

> 考古问题，假设以前的石碑被打碎成了很多块，每块上面都有一个或若干个字符，请你写个程序来把之前石碑上文字可能的组合全部写出来，按升序进行排列。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3`
>
> `a b c`
>
> **输出**
>
> `abc`
>
> `acb`
>
> `bac`
>
> `bca`
>
> `cab`
>
> `cba`
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3`
>
> `a b a`
>
> **输出**
>
> `aab`
>
> `aba`
>
> `baa`

# 思路

> 1：排列组合问题，简单的 DFS 应用。 **全排列** ，是 **含有重复元素的全排列** 的问题，按任意顺序返回所有不重复的全排列。
>
> 2： **剪枝算法，在遍历的过程中，一边遍历一遍检测，在一定会产生重复结果集的地方剪枝** 。
>
>
> 如果要比较两个列表是否一样，一个容易想到的办法是对列表分别排序，然后逐个比对。既然要排序，我们就可以在搜索之前就对候选数组排序，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复列表。

# 考点

> 1：回溯算法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def fac(strs, lis, result):
        for i in range(len(lis)):
            str_i = strs + lis[i]
            lis_i = lis[0:i] + lis[(i+1):]
            if not lis_i:
                if str_i not in result:
                    result.append(str_i)
            else:
                fac(str_i,lis_i,result)
    
    
    result = []
    num = int(input())
    list_n = input().split(' ')
    fac('',list_n,result)
    result.sort()
    for s in result:
        print(s)

