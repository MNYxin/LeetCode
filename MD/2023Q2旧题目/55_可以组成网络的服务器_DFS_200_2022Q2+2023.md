**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 在一个机房中，服务器的位置标识在 nm 的整数矩阵网格中，1 表示单元格上有服务器，0 表示没有。如果两台服务器位于同一行或者
> 同一列中紧邻的位置，则认为它们之间可以组成一个局域网。 请你统计机房中最大的局域网包含的服务器个数。
>
>  
> **输入描述：**  
>  第一行输入两个正整数，n和m，0<n,m<=100 之后为nm的二维数组，代表服务器信息  
>  **输出描述：**  
>  最大局域网包含的服务器个数。
>
>  
> **示例1：**  
>  **输入**  
>  2 2  
>  1 0  
>  1 1  
>  **输出**  
>  3

# 思路

> 1：其实和之前的题目类似，可以用BFS找到所有相邻且为 1 的节点，合并为一个区域。这里就不再赘述了。
>
> 2：和leetcode里面找岛屿个数的题很像。
>
> 3:
>
> 一般需求最优解的时候用广搜。
>
> 搜索过程是：从初始节点S0开始逐层向下扩展，在第n层节点还没有全部搜索完之前，不进入第n+1层节点的搜索。
>
> 假设有两个表：Open表存放待处理节点，Closed表存放处理完节点
>
> Open表中的节点总是按进入的先后排序，先进入Open表的节点排在前面，后进入Open表的节点排在后面。
>
> 广度优先搜索算法如下：（用 QUEUE）
>
> (1) 把初始节点S0放入Open表中；
>
> (2) 如果Open表为空，则问题无解，失败退出；
>
> (3) 把Open表的第一个节点取出放入Closed表，并记该节点为n；
>
> (4) 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
>
> (5) 若节点n不可扩展，则转第(2)步；
>
> (6) 扩展节点n，将其子节点放入Open表的尾部，并为每一个子节点设置指向父节点的指针，然后转第(2)步。
>
> 代码框架：
>
> BFS()
>
> {
>
> 初始化队列
>
> while(队列不为空且未找到目标节点)
>
> {
>
> 取队首节点扩展，并将扩展出的节点放入队尾；
>
> 必要时要记住每个节点的父节点；
>
> }
>
> }

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    import math
    
    def cal(node, network):
        x, y = node
        if node in network:
            network.remove(node)
            group[-1].append(node)
            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                new_x, new_y = x + dx, y + dy
                if (new_x, new_y) in network:
                    cal((new_x, new_y), network)
    
    
    
    n, m = list(map(int, input().split()))
    server = [list(map(int, input().split())) for _ in range(n)]
    network = list()
    for i, x in enumerate(server):
        network.extend([(i, j) for j, y in enumerate(x) if y == 1])
    group = []
    for node in network:
        group.append([])
        cal(node, network)
    print(max([len(i) for i in group]))

