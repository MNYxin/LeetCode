**目录**

题目

思路

考点

Code

* * *

# 题目

> 在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]，
>
> 第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j > i)。
>
> 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。
>
> 小朋友人数范围是 [0, 40000]。
>
> **输入描述**
>
> 第一行输入N，N表示有N个小朋友
>
> 第二行输入N个小朋友的身高height[i]，都是整数
>
> **输出描述**
>
> 输出N个小朋友的好朋友的位置
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `2`  
> `100 95`
>
> **输出**
>
> `0 0`
>
> **说明**
>
> 第一个小朋友身高100，站在队尾位置，向队首看，没有比他身高高的小朋友，所以输出第一个值为0。
>
> 第二个小朋友站在队首，前面也没有比他身高高的小朋友，所以输出第二个值为0。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `8`  
> `123 124 125 121 119 122 126 123`
>
> **输出**
>
> `1 2 6 5 5 6 0 0`
>
> **说明**
>
> 123的好朋友是1位置上的124  
>  124的好朋友是2位置上的125  
>  125的好朋友是6位置上的126  
>  以此类推

# 思路

> 1：暴力解法就是两层循环即可，但是只能通过95%的用例，也就是得不到100分。
>
> 2：经典的单调栈问题，
> **用一个栈来保存所有小于栈顶元素的位置，遇到每个数字，都比较一下栈顶数字与当前数字的大小。如果栈顶位置的数字小于当前数字，则栈顶位置的朋友就是当前位置，将栈顶位置的朋友设置完后，弹出栈顶数字，继续下一轮比较。直到栈顶位置不小于当前数字，或者栈为空。**

# 考点

> 1：单调栈
>
> 2：暴力循环

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    
    n = int(input())
    a = list(map(int,input().split()))
    q = []
    ans =[0]*n
    for i in range(n-1,-1,-1):
        while q and a[q[-1]] <= a[i]:
            q.pop()
        if q:
            ans[i] = q[-1]
        q.append(i)
    print(*ans)
    

