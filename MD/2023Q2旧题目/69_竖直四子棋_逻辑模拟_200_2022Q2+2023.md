**所有题目均有三种语言实现。**[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")、[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")、[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")

# 题目

> **题目描述**  
>  竖直四子棋的棋盘是竖立起来的，双方轮流选择棋盘的一列下子，棋子因重力落到棋盘底部或者其他棋子之上，当一列的棋子放满时，无法再在这列上下子。  
>  一方的4个棋子横、竖或者斜方向连成一线时获胜。  
>  现给定一个棋盘和红蓝对弈双方的下子步骤，判断红方或蓝方是否在某一步获胜。  
>  下面以一个6×5的棋盘图示说明落子过程：
>
> ![](https://img-blog.csdnimg.cn/cba469be954f45ac9375c8380f0b4e1d.png)
>
> 下面给出横、竖和斜方向四子连线的图示：
>
> ![](https://img-blog.csdnimg.cn/eb9baf973c0048848427a7c6c2ece1c1.png)
>
> **输入描述**  
>  输入为2行，第一行指定棋盘的宽和高，为空格分隔的两个数字；  
>  第二行依次间隔指定红蓝双方的落子步骤，第1步为红方的落子，第2步为蓝方的落子，第3步为红方的落子，以此类推。  
>  步骤由空格分隔的一组数字表示，每个数字为落子的列的编号（最左边的列编号为1，往右递增）。用例保证数字均为32位有符号数。  
>  **输出描述**  
>  如果落子过程中红方获胜，输出 N,red ；  
>  如果落子过程中蓝方获胜，输出 N,blue ；  
>  如果出现非法的落子步骤，输出 N,error。  
>  N为落子步骤的序号，从1开始。如果双方都没有获胜，输出 0,draw 。  
>  非法落子步骤有两种，一是列的编号超过棋盘范围，二是在一个已经落满子的列上落子。  
>  N和单词red、blue、draw、error之间是英文逗号连接。  
>  **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例  
>  输入  
>  5 5  
>  1 1 2 2 3 3 4 4  
>  输出  
>  7,red  
>  说明  
>  在第7步，红方在第4列落下一子后，红方的四个子在第一行连成一线，故红方获胜，输出 7,red。  
>  **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例  
>  输入  
>  5 5  
>  0 1 2 2 3 3 4 4  
>  输出  
>  1,error  
>  说明  
>  第1步的列序号为0，超出有效列编号的范围，故输出 1,error。

# 思路

> 1：分支判定

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    def check(matrix, x, y):
        h = len(matrix)    #数组有h行
        l = len(matrix[0]) #数组有l列
        count = 0  #统计相同的棋子（3即可）
        jishu = 3  #四个棋子只要统计三次
    
        if (x < h - 3):  #纵向四棋子
            a = x
            while ((jishu != 0) and matrix[a][y] == matrix[++a][y]):
                count+=1
                jishu-=1
            
            if (count == 3):
                return True
            
            count = 0
            jishu = 3
    
        if (y >= 3):   #左边横向四棋子
            b = y
            while ((jishu != 0) and matrix[x][b] == matrix[x][--b]):
                count+=1
                jishu-=1
            
            if (count == 3):
                return True
            
            count = 0
            jishu = 3
    
        if (y < l - 3):  #右边横向四棋子
            b = y
            while ((jishu != 0) and matrix[x][b] == matrix[x][++b]):
                count+=1
                jishu-=1
            
            if (count == 3):
                return True
            
            count = 0
            jishu = 3
    
        if (x < h - 3 and y >= 3):  #左边斜向四棋子
            a = x
            b = y
            while ((jishu != 0) and matrix[a][b] == matrix[++a][--b]):
                count+=1
                jishu-=1
            
            if (count == 3):
                return True
            
            count = 0
            jishu = 3
    
        if (x < h - 3 and y < l - 3): #右边斜向四棋子
            a = x
            b = y
            while ((jishu != 0) and matrix[a][b] == matrix[++a][++b]):
                count+=1
                jishu-=1
            
            return count == 3
    
        return False
    
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    
    nums = [int(x) for x in input().split(" ")]
    matrix = [[0 for i in range(m)] for j in range(n)]
    isOver = False
    for i in range(len(nums)):
        index = -1
        color = 1
        num = nums[i]
        if (num <= 0 or num > m or matrix[0][num - 1] != 0):
            isOver = True
            print(str(i) + str(1) + ",error")
            break
        
        #偶数下标为red，用1表示, 奇数下标为blue，用2表示
        if (i % 2 != 0): 
            color = 2 
        j = n -1
        while(j>=0):
            if (matrix[j][num - 1] == 0):
                index = j  
                matrix[j][num - 1] = color
                break
            j -= 1
            
        
        if (index == -1):
            isOver = True
            print(str(i) + str(1) + ",error")
            break
        
        #第七个棋子开始才能符合四棋子
        if (i >= 6 and check(matrix, index, num - 1)):   
            if (color == 1):
                isOver = True
                print(str(i+1) + ",red")
                break
            else:
                isOver = True
                print(str(i+1) + ",blue")
                break
            
        
    
    if (not isOver):
        print("0,draw")
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

