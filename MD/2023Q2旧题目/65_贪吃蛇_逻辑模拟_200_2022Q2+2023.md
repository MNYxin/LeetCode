**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。
>
> 蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。
>
> 下面让我们来完成贪吃蛇游戏的模拟。
>
> 给定一个N*M的数组arr，代表N*M个方格组成的版图，贪吃蛇每次移动一个方格。
>
> 若arr[i][j] == ‘H’，表示该方格为贪吃蛇的起始位置；
>
> 若arr[i][j] == ‘F’，表示该方格为食物，
>
> 若arr[i][j] == ‘E’，表示该方格为空格。
>
> 贪吃蛇初始长度为1，初始移动方向为向左。
>
> 为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时蛇的长度。
>
> 贪吃蛇移动、吃食物和碰撞处理的细节见下面图示：
>
> 图1：截取了贪吃蛇移动的一个中间状态，H表示蛇头，F表示食物，数字为蛇身体各节的编号，蛇为向左移动，此时蛇头和食物已经相邻
>
> 图2：蛇头向左移动一格，蛇头和食物重叠，注意此时食物的格子成为了新的蛇头，第1节身体移动到蛇头位置，第2节身体移动到第1节身体位置，以此类推，
>
> 最后添加第4节身体到原来第3节身体的位置。
>
> 图3：蛇头继续向左移动一格，身体的各节按上述规则移动，此时蛇头已经和边界相邻，但还未碰撞。
>
> 图4：蛇头继续向左移动一格，此时蛇头已经超过边界，发生碰撞，游戏结束。
>
> 图5和图6给出一个蛇头和身体碰撞的例子，蛇为向上移动。
>
> 图5时蛇头和第7节身体相邻，但还未碰撞；
>
> 图6蛇头向上移动一格，此时蛇头和第8节身体都移动到了原来第7节身体的位置，发生碰撞，游戏结束。
>
> * * *
>
> ![](https://img-blog.csdnimg.cn/3c4c2b02c9664579ac09f6610be17ac0.png)
>
> * * *
>
> **输入描述**
>
>   * 输入第一行为空格分隔的字母，代表贪吃蛇的移动操作。
>   * 字母取值为U、D、L、R和G，
>   * U、D、L、R分别表示贪吃蛇往上、下、左、右和转向，转向时贪吃蛇不移动 ，G表示贪吃蛇按当前的方向移动一格。
>   * 用例保证输入的操作正确。
>   * 第二行为空格分隔的两个数，指定N和M，为数组的行和列数。
>   * 余下N行每行是空格分隔的M个字母。字母取值为H、F和E，H表示贪吃蛇的起始位置，F表示食物，E表示该方格为空。
>   * 用例保证有且只有一个H，而F和E会有多个。
>

>
> **输出描述**
>
>   * 输出一个数字，为蛇的长度。
>

>
> **示例 1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> D G G
>
> 3 3
>
> F F F
>
> F F H
>
> E F E
>
> **输出**
>
> 1
>
> * * *
>
> **_地图表示为：_**
>
> 蛇头 H(Head)
>
> 食物 F(Food)
>
> E表示该方格为空
>
> **_四个方向分别表示为：_**
>
> 向上 U(up)
>
> 向下 D(down)
>
> 向左 L(Left)
>
> 向右 R(Right)

# 思路

> 1：说实话遇到这种题，读完题理解题都需要耗费很长时间，并且在实现上要模拟它的多个条件分支，写起来实在是复杂。
>
> 2：需要非常细心的考虑 **各种分支和边界条件** ，这题就考察一个做题的 **耐心和细心** ，难度倒还好。

# 考点

> 1：分支+边界

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    import math
    
    orders = input().split()
    n, m = map(int, input().split())
    if n == 0 or m == 0:
        print(0)
    else:
        matrix = [input().split() for _ in range(n)]
        x, y = 0, 0
        for i in range(n):
            for j in range(m):
                if matrix[i][j] == "H":
                    x, y = i, j
                    break
        res, command = 1, "L"
        for order in orders:
            ref = {"U": [-1, 0], "D": [1, 0], "L": [0, -1], "R": [0, 1]}
            if order == "G":
                if command in ref:
                    dx, dy = ref[command]
                    x, y = x + dx, y + dy
                if x < 0 or x >= n or y < 0 or y >= m or matrix[x][y] == "S":
                    break
                if matrix[x][y] == "F":
                    res += 1
                    matrix[x][y] = "S"
            else:
                command = order
        print(res)
    

