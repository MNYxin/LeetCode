**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定一个随机的整数（可能存在正整数和负整数）数组 nums，请你在该数组中找出两个数，其和的绝对值( **|nums[x]+nums[y]|**
> )为最小值，并返回这个两个数（按从小到大返回）以及绝对值。
>
> 每种输入只会对应一个答案。
>
> 但是，数组中同一个元素不能使用两遍。
>
> **输入描述**
>
> 一个通过空格分割的有序整数序列字符串，最多1000个整数，且整数数值范围是 [-65535, 65535]。
>
> **输出描述**
>
> 两数之和绝对值最小值
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `-1 -3 7 5 11 15`
>
> **输出**
>
> `-3 5 2`
>
> **说明**
>
> 因为 |nums[0] + nums[2]| = |-3 + 5| = 2 最小，所以返回 -3 5 2。

# 思路

> 1：两个数字的之和绝对值最小，那么有以下几种情况
>
>   * **两个数字都是负数** ，那么是最大的俩负数的和的绝对值最小。
>   *  **两个数字都是正数** ，那么是最小的俩整数的和的绝对值最小。
>   *  **一个数是负数一个数是正数** ，此时情况需要特殊处理。因为需要绝对值最小，那么对于一个负数 -N 显然想找 +N ,
> 我们遇到一个负数x，需要 **找非负数区的最接近于|x|的的那个数** 。
>

>
> 2：分类讨论完之后就简单了，先给数组排好序。对于第一种和第二种情况，一个比较核心的操作： **找到最靠近或者等于0的位置**
> 。因为只有找到绝对值最小的位置，后面才好判断选哪个数。
>
> 3：可以看到上面三种情况可以抽象出一个方法， **找到一个排序数组中最靠近目标数target的位置- > 明显就退化成比较简单的二分查找问题**。
>
> 4： **二分查找的基本工作原理：将要查找的元素一分为两半然后一半一半的查找**
>
> 通过不停的缩小查找范围，改变L,R M,，直到它们三在一个元素上，并且这个元素等于查找元素，每次L和R移动的步长为1，我们这里是找到最靠近的即可。

# 考点

> 1：二分查找

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    
    def min_abs(s):
        arr = [int(x) for x in str(s).split(" ")]
        a = arr[0]
        b = arr[1]
        min = abs(a + b)
        for i in range(len(arr) - 1):
            for j in range(i + 1, len(arr)):
                if abs(arr[i] + arr[j]) < min:
                    a = arr[i]
                    b = arr[j]
                    min = abs(a + b)
        return a, b, min
    print(input())
    
    
    
    

