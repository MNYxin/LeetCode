## 题目

> 定义一个二维数组 N*M ，如 5 × 5 数组下所示：  
>  int maze[5][5] = {  
>  0, 1, 0, 0, 0,  
>  0, 1, 1, 1, 0,  
>  0, 0, 0, 0, 0,  
>  0, 1, 1, 1, 0,  
>  0, 0, 0, 1, 0,  
>  };  
>
> 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。  
>  数据范围： 2≤n,m≤10 ， 输入的内容只包含 0≤val≤1。
>
> **输入描述：**  
>
> 输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。
>
> **输出描述：**  
>  左上角到右下角的最短路径，格式如样例所示。
>
> **示例1**
>
> **输入：**
>
> 5 5  
>  0 1 0 0 0  
>  0 1 1 1 0  
>  0 0 0 0 0  
>  0 1 1 1 0  
>  0 0 0 1 0
>
> **输出：**
>
> (0,0)  
>  (1,0)  
>  (2,0)  
>  (2,1)  
>  (2,2)  
>  (2,3)  
>  (2,4)  
>  (3,4)  
>  (4,4)
>
> **示例2**
>
> **输入：**
>
> 5 5  
>  0 1 0 0 0  
>  0 1 0 1 0  
>  0 0 0 0 1  
>  0 1 1 1 0  
>  0 0 0 0 0
>
> **输出：**
>
> (0,0)  
>  (1,0)  
>  (2,0)  
>  (3,0)  
>  (4,0)  
>  (4,1)  
>  (4,2)  
>  (4,3)  
>  (4,4)
>
> 说明：注意：不能斜着走！！！

# 思路

> 1：典型的一个搜索类问题，最短路径用DFS。

# ![](https://img-blog.csdnimg.cn/903f0041854a44c09af9d3562e233ebf.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    m = params[1]
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
     
    result = []
    def dfs(x, y, path):
        global result
        if x == n - 1 and y == m - 1:
            result.extend(path)
            return
        
        if(x+1<n):
            if(matrix[x+1][y] == 0):
                path.append([x, y])
                matrix[x][y] = 2 
                dfs(x+1, y, path)
                path.pop()
        if(x-1>=0):
            if(matrix[x-1][y] == 0):
                path.append([x, y])
                matrix[x][y] = 2 
                dfs(x-1, y, path)
                path.pop()
        if(y+1<m):
            if(matrix[x][y+1] == 0):
                path.append([x, y])
                matrix[x][y] = 2 
                dfs(x, y+1, path)
                path.pop()
    
        if(y-1>=0):
            if(matrix[x][y-1] == 0):
                path.append([x, y])
                matrix[x][y] = 2 
                dfs(x, y-1, path)
                path.pop()
    
    dfs(0, 0, [])
    result.append([params[0] - 1, params[1] - 1])
    
    output_str = ""
    i=0
    while(True):
        if(i>=len(result)):
            break
        else:
            temp_str = "("
            for ele in result[i]:
                temp_str +=  str(ele) + "," 
            temp_str =temp_str[:-1]
            temp_str += ")"
            output_str += temp_str + "\n"
        i+=1
    print(output_str[:-1])

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
>
> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

