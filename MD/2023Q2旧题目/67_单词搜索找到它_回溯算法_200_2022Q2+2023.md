## 题目

> 找到它是一个小游戏，你需要在一个矩阵中找到给定的单词。
>
> 假设给定单词 HELLOWORD，在矩阵中只要能找到 H->E->L->L->O->W->O->R->L->D连成的单词，就算通过。
>
> 注意区分英文字母大小写，并且您只能上下左右行走，不能走回头路。
>
> **输入描述**
>
> 输入第 1 行包含两个整数 n、m (0 < n,m < 21) 分别表示 n 行 m 列的矩阵，
>
> 第 2 行是长度不超过100的单词 W (在整个矩阵中给定单词 W 只会出现一次)，
>
> 从第 3 行到第 n+2 行是指包含大小写英文字母的长度为 m 的字符串矩阵。
>
> **输出描述**
>
> 如果能在矩阵中连成给定的单词，则输出给定单词首字母在矩阵中的位置(第几行 第几列)，
>
> 否则输出“NO”。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> 5 5
>
> HELLOWORLD
>
> CPUCY
>
> EKLQH
>
> CHELL
>
> LROWO
>
> DGRBC
>
> **输出**
>
> 3 2

# 思路

> 1：关于搜索类的题目，不是BFS 就是DFS，套路都是一样的。这一题属于一道比较简单的搜索题。
>
> 2：注意两个变量，第一个、布尔数组变量visited，判断是否搜索过。第二个、布尔变量判断是否找到。

# ![](https://img-blog.csdnimg.cn/69aaa5ba5d4d457083b931ea5dc3923c.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def bfs(i, j,index,n,m,matrix,visited,target) :
        if (index == len(target)):
            return True
        else:
            if (i < 0 or i >= n or j < 0 or j >= m or visited[i][j] or matrix[i][j] != target[index]):
                return False
            
        
        visited[i][j] = 1
        flag = False
        if (i-1>=0):
            flag = (flag or bfs(i - 1, j, index+1,n,m,matrix,visited,target))
        
        if (i+1<n):
            flag = (flag or bfs(i + 1, j, index+1,n,m,matrix,visited,target))
        
        if (j-1>=0):
            flag = (flag or bfs(i, j-1, index+1,n,m,matrix,visited,target))
        
        if (j+1<m):
            flag = (flag or bfs(i, j+1, index+1,n,m,matrix,visited,target))
        
        visited[i][j] = 0
        return flag
      
    
    input_param = [int(x) for x in input().split(" ")]
    n = input_param[0]
    m = input_param[1]
    target = input()
    matrix = []
    for i in range(n):
        matrix.append(input())
    visited = []
    for i in range(n):
        temp = []
        for j in range(m):
            temp.append(0)
        visited.append(temp)
    
    flag = False
    pos_x = 0
    pos_y = 0
    for i in range(n):
        for j in range(m):
            if (bfs(i, j, 0,n,m,matrix,visited,target)) :
                pos_x = i+1
                pos_y = j+1
                flag = True
                break
            else:
                continue
        if(flag):
            break
    output_str = "NO"
    if flag:
        output_str = ""
        output_str += str(pos_x) + "," + str(pos_y)
    print(output_str)
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
>
> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

