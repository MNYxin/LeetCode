**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 给定非空字符串s，将该字符串分割成一些子串，使 **每个子串** 的ASCII码值的和均为水仙花数。
>
> 1、若分割不成功，则返回0；
>
> 2、若分割成功且分割结果不唯一，则返回-1；
>
> 3、若分割成功且分割结果唯一，则返回分割后子串的数目。
>
> **输入描述**
>
> 输入字符串的最大长度为200
>
> **输出描述**
>
> 根据题目描述中情况，返回相应的结果。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `abc`
>
> **输出**
>
> `0`
>
> **说明**
>
> 分割不成功
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 输入 f3@d5a8  
>  输出 -1  
>  说明 分割成功但分割结果不唯一，可以分割为两组，  
>  一组：""f3"" 和 ""@d5a8""  
>  另一组: ""f3@d5"" 和 ""a8""
>
> ### 示例3
>
> 输入 AXdddF  
>  输出 2  
>  说明 分割成功且结果唯一，可以分割为AX""(153) 和""dddF""(370)
>
> 备注：此题表示 “水仙花数”是指一个三位数，每位上数字的立方和等于该数字本身，如371是'水仙花数'，因371=3^3+7^3+1^3

# 思路

> 1：首先要记住题目中的意思，“水仙花数”是指一个三位数！！！这样的话处理起来就方便多了。
>
> 2：利用递归的方式，来进行切分即可，index逐个向后移动，判断是否满足水仙花数的条件。

#

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    #nums = [int(x) for x in input().split(" ")]
    
    def check(num):
        if num <= 99 or num >= 1000:
            return False
     
        x, y, z = [int(c) for c in str(num)]
     
        return num == x ** 3 + y ** 3 + z ** 3
     
    
    def recur(preSum, n, start, count, res):
        if start == n:
            res.append(count)
            return
     
        for end in range(start + 1, n + 1):
            if check(preSum[end] - preSum[start]):
                recur(preSum, n, end, count + 1, res)
    
    char_arr = [ord(c) for c in input()]
    n = len(char_arr)
    # 前缀和
    preSum = [0] * (n + 1)
    for index in range(1, n + 1):
        preSum[index] = preSum[index - 1] + char_arr[index - 1]
    
    res = []
    recur(preSum, n, 0, 0, res)
    
    if len(res) == 0:
        print(0)
    elif len(res) == 1:
        print(res[0])
    else:
        print(-1)

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

