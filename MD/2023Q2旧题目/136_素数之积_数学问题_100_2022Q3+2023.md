**目录**

题目

思路

考点

Code

* * *

# 题目

> RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。
>
> 给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。
>
> **输入描述**
>
> 一个正整数num
>
> 0 < num <= 2147483647
>
> **输出描述**
>
> 如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `15`
>
> **输出**
>
> `3 5`
>
> **说明**
>
> 因数分解后，找到两个素数3和5，使得3*5=15，按从小到大排列后，输出3 5。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `27`
>
> **输出**
>
> `-1 -1`
>
> **说明**
>
> 通过因数分解，找不到任何素数，使得他们的乘积为27，输出-1 -1。

# 思路

>
> 1：考察的是一些数学知识，如果数字n不是素数，则它一定可以写成两个数字相乘的形式（除了1*n），这两个数字称为n的因子，如：16=2*8=4*4，所以在判断n是否为素数时，只要找到一对因子中的一个就能证明n不是素数，而这一对因子中至少有一个因子小于等于根号n。

# 考点

> 1：数学知识

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def factor(num):
        if num == 1:
            return []
        else:
            for i in range(2, num+1):
                a, b = divmod(num, i)
                if b == 0:
                    return [i] + factor(a)
    
    num = int(input())
    if num > 2147483646:
        print('-1 -1')
    list_out = factor(num)
    if len(list_out) == 2:
        print('{} {}'.format(list_out[0], list_out[1]))
    else:
        print('-1 -1')

