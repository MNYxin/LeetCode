## 题目

>   * 某地有N个广播站，站点之间有些有连接，有些没有。有连接的站点在接受到广播后会互相发送。
>   *
> 给定一个N*N的二维数组matrix,数组的元素都是字符’0’或者’1’。matrix[i][j]=‘1’,则代表i和j站点之间有连接，matrix[i][j]
> = ‘0’代表没连接，
>   * 现在要发一条广播，问初始最少给几个广播站发送，才能保证所有的广播站都收到消息。
>

>
> **输入描述：**
>
>   * 从stdin输入，共一行数据，表示二维数组的各行，用逗号分隔行。保证每行字符串所含的字符数一样的。
>   * 比如：110,110,001。
>

>
> **输出描述：**
>
>   * 返回初始最少需要发送广播站个数。
>

>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `110,110,001`
>
> **输出**
>
> `2`
>
> **说明**
>
> 站点1和站点2直接有连接，站点3和其他的都没连接，所以开始至少需要给两个站点发送广播。
>
> * * *
>
> **示例1**
>
> **输入**
>
> `1 0 0`  
> `0 1 0`  
> `0 0 1`
>
> **输出**
>
> `3`
>
> **说明**
>
> 3台服务器互不连接，所以需要分别广播这3台服务器。
>
> **示例2**
>
> **输入**
>
> `1 1`  
> `1 1`
>
> **输出**
>
> `1`
>
> **说明**
>
> 2台服务器相互连接，所以只需要广播其中一台服务器

# 思路

> 1：读题之后，我们可知需要判断连在一起的广播的个数，其实和 leetcode 里面有一题 岛屿个数非常像，可以用DFS 也可以用并查集。
>
> 2：并查集的话先给一些理解，
>
> 定义：
>
> 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。
>
> 并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。
>
> 场景：
>
> 并查集用在一些有 **N**
> 个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这个过程看似并不复杂，但数据量极大，若用其他的数据结构来描述的话，往往在空间上过大，计算机无法承受，也无法在短时间内计算出结果，所以只能用并查集来处理。
>
> 3：我也是直接参考的[大佬的并查集实现](https://leetcode.cn/problems/number-of-
> provinces/solution/li-kou-547-bing-cha-ji-si-lu-jiang-jie-b-u9qh/
> "大佬的并查集实现")，知道什么题目能用上就行了，也不太指望真正笔试、面试的时候能写完整这个。

# 考点

> 1：并查集

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    input_str = input()
    arr = input_str.split(",")
    matrix = []
    for i in range(len(arr)):
        matrix.append([int(x) for x in arr[i]])
    n = len(matrix)
     
    child = n
    parent = [x for x in range(n)]
    
    def find(i):
        global parent
        if (parent[i] == i):
            return i
        parent[i] = find(parent[i])
        return parent[i]
    
    def union(i, j):
        global parent
        global child
        pos_i = find(i)
        pos_j = find(j)
    
        if (pos_i == pos_j):
            return
        child-=1
        parent[pos_i] = pos_j
    
    
    for i in range(n):
        for j in range(n):
            if i!=j and matrix[i][j] == 1:
                union(i, j)
    print(child)

