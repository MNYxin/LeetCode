**目录**

题目

思路

考点

Code

* * *

# 题目

> 开头和结尾都是元音字母（aeiouAEIOU）的字符串为元音字符串，其中混杂的非元音字母数量为其瑕疵度。比如:
>
>   1. “a” 、 “aa”是元音字符串，其瑕疵度都为0
>   2. “aiur”不是元音字符串（结尾不是元音字符）
>   3. “abira”是元音字符串，其瑕疵度为2
>

>
> 给定一个字符串，请找出指定瑕疵度的最长元音字符子串，并输出其长度，如果找不到满足条件的元音字符子串，输出0。
>
> 子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。
>
> **输入描述：**
>
> 首行输入是一个整数，表示预期的瑕疵度flaw，取值范围[0, 65535]。
>
> 接下来一行是一个仅由字符a-z和A-Z组成的字符串，字符串长度(0, 65535]。
>
> **输出描述：**
>
> 输出为一个整数，代表满足条件的元音字符子串的长度。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `0`
>
> `asdbuiodevauufgh`
>
> **输出**
>
> `3`
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `2`
>
> `aeueo`
>
> **输出**
>
> `0`
>
> **示例3**
>
> 输入
>
> 1
>
> aabeebuu
>
> 输出
>
> 5
>
> 说明
>
> 满足条件的最长元音字符子串有两个，分别为aabee和eebuu，长度为5

# 思路

> 1：双循环，直接暴力求解
>
> 2：应用一个简单的滑动窗口，统计窗口内的瑕疵度即可。

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    
    def cal(flaw, src):
        res = 0
        for i in range(len(src)):
            count = 0
            if src[i] not in "aeiouAEIOU":
                continue
            for j in range(i + 1, len(src)):
                if src[j] not in "aeiouAEIOU":
                    count += 1
                else:
                    if count > flaw:
                        break
                    if count == flaw and res < j - i + 1:
                        res = j - i + 1
        return res
    
    flaw = int(input())
    src = input()
    count = 0
    for i in src:
        if i in "aeiouAEIOU":
            count += 1
    if flaw == 0 and count == 1:
        print(1)
    else:
        res = cal(flaw, src)
        print(res)
    
    

O(N)复杂度解法：

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
     
    flaw = int(input())
    input_str = input()
    
    # 保存元音位置
    idxs = []
    for i in range(len(input_str)):
        if input_str[i] in set(list("aeiouAEIOU")):
            idxs.append(i)
    
    result = 0
    #窗口左右位置
    l = 0
    r = 0
    
    while r < len(idxs):
        # 计算瑕疵度
        if r - l == idxs[r] - idxs[l]:
            diff = 0
        else:
            diff = idxs[r] - idxs[l] - (r - l)
    
        if diff > flaw:
            l += 1
        elif diff < flaw:
            r += 1
        else:
            result = max(result, idxs[r] - idxs[l] + 1)
            r += 1
    
    print(result)

