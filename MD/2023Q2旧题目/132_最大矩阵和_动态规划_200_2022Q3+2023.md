**目录**

题目

思路

考点

Code

* * *

# 题目

>
> 给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大，我们把这个子矩阵称为和最大子矩阵，子矩阵的选取原则是原矩阵中一块相互连续的矩形区域。
>
> **输入描述:**
>
>   * 输入的第一行包含2个整数n, m(1 <= n, m <=
> 10)，表示一个n行m列的矩阵，下面有n行，每行有m个整数，同一行中，每2个数字之间有1个空格，最后一个数字后面没有空格，所有的数字的在[-1000,
> 1000]之间。
>

>
> **输出描述:**
>
>   * 输出一行一个数字，表示选出的和最大子矩阵内所有的数字和。
>

>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3 4`
>
> `-3 5 -1 5`
>
> `2 4 -2 4`
>
> `-1 3 -1 3`
>
> **输出**
>
> `20`
>
> **说明**
>
> 一个3*4的矩阵中，后面3列的子矩阵求和加起来等于20，和最大。

# 思路

> 1：从题目中来看，因为已经限制了矩阵最大就是10X10的，所以暴力破解也就成了可能，我们就直接遍历所有的子矩阵，看看谁最大就可以了。

# 考点

> 1：暴力法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
     
    n, m = map(int, input().split())
    
    matrix = []
    
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
    
    ans = -1000
    
    for i in range(n):
        b = [0]* m
        for j in range(i,n):
            sum = 0
            for k in range(m):
                b[k] += matrix[j][k]
                if sum > 0:
                    sum += b[k]
                else:
                    sum = b[k]
                if sum>ans:
                    ans = sum
    print(ans)

