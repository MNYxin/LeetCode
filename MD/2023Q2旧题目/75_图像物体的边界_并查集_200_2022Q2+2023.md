## 题目

>
> 给定一个二维数组M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。
>
> 像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）。
>
> **其他约束**
>
> **地图规格约束为：**
>
> 0<M<100  
>  0<N<100
>
>
> 1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、（5,4）为边界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界，所以下图边界个数为2。
>
> * * *
>
> ![](https://img-blog.csdnimg.cn/ec41d5f04db14d738f1cea1d774fdd03.png)
>
> * * *
>
>
> 2）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（3,3）、（3,4）、（3,5）、（4,3）、（4,5）、（5,3）、（5,4）、（5,5）为边界，另这些边界相邻，所以下图边界个数为1。
>
> * * *
>
> ![](https://img-blog.csdnimg.cn/9422f6254dad40e8a23bf09817224400.jpeg)
>
> * * *
>
> **注：** （2,2）、（3,3）相邻。
>
> **输入描述**
>
> 第一行，行数M，列数N
>
> 第二行开始，是M行N列的像素的二维数组，仅包含像素1和5
>
> **输出描述**
>
> 像素1代表的物体的边界个数。
>
> 如果没有边界输出0（比如只存在像素1，或者只存在像素5）。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `6 6`  
> `1 1 1 1 1 1`  
> `1 5 1 1 1 1`  
> `1 1 1 1 1 1`  
> `1 1 1 1 1 1`  
> `1 1 1 1 1 1`  
> `1 1 1 1 1 5`
>
> **输出**
>
> 2
>
> **说明**
>
> 参考题目描述部分
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `6 6`  
> `1 1 1 1 1 1`  
> `1 5 1 1 1 1`  
> `1 1 1 1 1 1`  
> `1 1 1 1 1 1`  
> `1 1 1 1 5 1`  
> `1 1 1 1 1 1`
>
> **输出**
>
> `1`

# 思路

> 1：并查集

# ![](https://img-blog.csdnimg.cn/4ed0f581da954d10a712fa51ece25877.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    input_param = [int(x) for x in input().split(" ")]
    m = input_param[0]
    n = input_param[1]
    matrix = []
    for i in range(m):
        matrix.append([int(x) for x in input().split(" ")])
    
    edges = []
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 5:
                edges.append((i, j))
    
    length = len(edges)
    child = length
    parent = [x for x in range(length)]
    
    def find(i):
        global parent
        if (parent[i] == i):
            return i
        parent[i] = find(parent[i])
        return parent[i]
    
    def union(i, j):
        global parent
        global child
        pos_i = find(i)
        pos_j = find(j)
    
        if (pos_i == pos_j):
            return
        child-=1
        parent[pos_i] = pos_j
    
    if length == 0 or length == n * m:
        print(0)
    else:
        for i in range(length):
            for j in range(i + 1, length):
                if abs(edges[j][0] - edges[i][0]) <= 3 and abs(edges[j][1] - edges[i][1]) <= 3:
                    union(i, j)
    
        print(child)
     
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

