**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 如果3个正整数(a,b,c)满足a2 + b2 = c2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五），
>
>
> 为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。
>
> 请求出给定范围[N,M]内，所有的勾股数元组。
>
> **输入描述**
>
> 起始范围N，1 <= N <= 10000
>
> 结束范围M，N < M <= 10000
>
> **输出描述**
>
> 1\. a,b,c请保证a < b < c,输出格式：a b c；
>
> 2\. 多组勾股数元组请按照a升序，b升序，最后c升序的方式排序输出；
>
> 3\. 给定范围中如果找不到勾股数元组时，输出”NA“。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `1`
>
> `20`
>
> **输出**
>
> `3 4 5`
>
> `5 12 13`
>
> `8 15 17`

# 思路

> 1：暴力循环，复杂度O(n^3)，很显然复杂度太高了。
>
> 2：不想要这么高的复杂度，那么需要了解一下勾股定理的一个衍生版：
>
> abc三个勾股数，存在m,n，使得 a=m^2-n^2 , b=2mn, c=m^2+n^2 , gcd(m,n) = 1
>
> 由此，可将三层循环转成两层循环。

# 考点

> 1：勾股定理
>
> 2：两个细节要注意，第一是题目要求了输出顺序，因此输出的时候要判断一下。
>
> 第二是不存在的时候输出NA

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter
    import copy
    from itertools import permutations
    import re
    import math
    
    start = int(input())
    end = int(input())
    LEN = math.ceil(math.sqrt(end))
    
    ans = []
    
    for i in range(1, LEN):
        for j in range(i + 1, LEN):
            if math.gcd(i, j) != 1:
                continue
            
            a = j ** 2 - i ** 2
            b = 2 * i * j
            if a < start or b < start:
                continue
            c = i ** 2 + j ** 2
            if c <= end:
                if math.gcd(a, b) ==  1 and math.gcd(a, c) == 1 and \
                    math.gcd(b, c) == 1:
                    t = [a, b, c]
                    t.sort()
                    ans.append(t)
    
    if len(ans) > 0:
        ans.sort()
        for t in ans:
            print(f"{t[0]} {t[1]} {t[2]}")
    else:
        print("NA")
    

