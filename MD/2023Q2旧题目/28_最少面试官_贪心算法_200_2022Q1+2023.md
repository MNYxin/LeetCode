**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定，用(S1,E1)、 (S2,E2)、
> (Sj,Ej)…(Si < Ei，均为非负整数)表示每场面试的开始和结束时间。
>
> 面试采用一对一的方式，即一名面试官同时只能面试一名应试者，一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过 m。
>
> 为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。
>
> **输入描述**
>
> 输入的第一行为面试官的最多面试人次 m，第二行为当天总的面试场次 n，
>
> 接下来的 n 行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。
>
> 其中， 1 <= n, m <= 500
>
> **输出描述**
>
> 输出一个整数，表示至少需要的面试官数量。
>
> **示例 1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `2`
>
> `5`
>
> `1 2`
>
> `2 3`
>
> `3 4`
>
> `4 5`
>
> `5 6`
>
> **输出**
>
> `3`
>
> **说明**
>
> 总共有 5 场面试，且面试时间都不重叠，但每个面试官最多只能面试 2 人次，所以需要 3 名面试官。
>
> **示例2**  
>  输入  
>  3  
>  3  
>  1 2  
>  2 3  
>  3 4  
>  输出  
>  1  
>  说明  
>  总共有3场面试，面试时间都不重叠，每个面试官最多能面试3人次，所以只需要1名面试官。
>
>  
> **示例3**  
>  输入  
>  3  
>  3  
>  8 35  
>  5 10  
>  1 3  
>  输出  
>  2  
>  说明  
>  总共有3场面试，[5,10]和[8,35]有重叠，所以至少需要2名面试官。

# 思路

> 1：先按照每个面试者的结束时间来排序，维护当前每次面试的结束时间，然后当一个新的时间安排出现的时候，只需要判断一下是否需要新的一个面试官。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
     
    def is_vaild(hr, plan):
        def compare(ls1, ls2):
            a, b = ls1[0], ls1[1]
            c, d = ls2[0], ls2[1]
            return a < c < b or a < d < b or (a >= c and b <= d)
    
        for single_hr in hr:
            if compare(single_hr, plan) or compare(plan, single_hr):
                return False
        return True
    
    
    def get_ans(plan):
        for hr in hrs:
            if len(hr) >= m:
                continue
            if is_vaild(hr, plan):
                hr.append(plan)
                return True
    
    
    m, n = int(input()), int(input())
    plans = sorted([[int(i) for i in input().split()] for _ in range(n)], key=lambda x: x[0])
    hrs = []
    for plan in plans:
        if not get_ans(plan):
            hrs.append([plan])
    print(len(hrs))
    

