**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 给定一个正整数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。
>
> 请计算执行完所有任务所需的最短时间。
>
> **任务执行规则如下:**
>
>   1. 任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。
>   2. 两个同类型的任务之间必须有长度为N个单位的冷却时间，比如N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务。
>   3. 系统在任何一个单位时间内都可以执行一个任务，或者等待状态。
>

>
> 说明：数组最大长度为1000，数字最大值1000。
>
> **输入描述**
>
>   * 第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000，
>   * 第二行记录任务冷却时间，N为正整数，N<=100。
>

>
> **输出描述**
>
>   * 输出为执行完所有任务所需的最短时间。
>

>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `2,2,2,3`
>
> `2`
>
> **输出**
>
> `7`
>
> **说明**
>
> 时间1：执行类型2任务。  
>  时间2：执行类型3的任务（因为冷却时间为2，所以时间2不能执行类型2的任务）。  
>  时间3：系统等待（仍然在类型2的冷却时间）。  
>  时间4：执行类型2任务。  
>  时间5：系统等待。  
>  时间6：系统等待。  
>  时间7：执行类型2任务。  
>  因此总共耗时7。

# 思路

> 1：题目需要花点时间理解。首先说结论： **完成所有任务的最短时间取决于出现次数最多的任务总数** 。
>
> 2：原因是什么呢？ **因为同类型的任务之间必须间隔N，这样的话，出现次数最多的任务之间必须间隔N，总等待耗时** **(M - 1) * (N +
> 1) （M为出现次数最多的任务的总数）是不变的** ，这样我们只需要将剩余的任务往等待时间里填充即可。
>
> 3：假设出现次数最多的元素为A，那么最后一个A之后是否还有任务跟随取决于 **是否存在与任务A出现次数相同的任务**
> 。因为间隔为正整数，必然大于0，两个A中间有间隔必然可以插下其他出现次数小于A的数字。
>
> 4：所以思路如下：
>
>   * 求地每个任务出现的次数
>   * 找出出现次数最多的任务，假设出现次数为 M
>   * 那么最短时间为 (M- 1) * (N + 1)
>   * 计算出现次数为 M 的任务总数 count，计算最终结果为 (M- 1) * (N + 1)+ count
>

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    v = [int(x) for x in input().split(",")]
    N = int(input())
    
    # 找出出现次数最多的数字
    # 因为最大数字不超过1000，所以可以用一个长度为1001的数组来表示所有元素的出现次数
    
    num_count =[0 for i in range(1001)]
    for x in v:
        # 出现次数+1
        num_count[x] += 1
    
    
    #降序排序
    num_count.sort(reverse=True)
    total = (N + 1) * (num_count[0] - 1) + 1
    for i in range(1,1001):
        if(num_count[i] == num_count[0]):
            total+=1
        
    
    print(total)
    
     
     
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

