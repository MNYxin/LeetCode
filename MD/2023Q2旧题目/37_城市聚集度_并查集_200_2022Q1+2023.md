## 题目

> 一张地图上有n个城市，城市和城市之间有且只有一条道路相连：要么直接相连，要么通过其它城市中转相连（可中转一次或多次）。城市与城市之间的道路
> **都不会成环** 。
>
> 当切断通往某个城市 i 的所有道路后，地图上将分为多个连通的城市群，设该城市i的聚集度为DPi（Degree of
> Polymerization），DPi = max（城市群1的城市个数，城市群2的城市个数，…城市群m 的城市个数）。
>
> 请找出地图上DP值最小的城市（即找到城市j，使得DPj = min(DP1,DP2 … DPn))
>
> 提示：如果有 **多个城市** 都满足条件，这些城市都要找出来（ **可能存在多个解** ）
>
> 提示：DPi的计算，可以理解为已知一棵树，删除某个节点后；生成的多个子树，求解多个子数节点数的问题。
>
> **输入描述：**
>
> 每个样例：第一行有一个整数N，表示有N个节点。1 <= N <= 1000。
>
> 接下来的N-1行每行有两个整数x，y，表示城市x与城市y连接。1 <= x, y <= N
>
> **输出描述：**
>
> 输出城市的编号。如果有多个，按照编号升序输出。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5`  
> `1 2`  
> `2 3`  
> `3 4`  
> `4 5`
>
> **输出**
>
> `3`
>
> **说明**
>
> 输入表示的是如下地图：
>
> ![](https://img-blog.csdnimg.cn/7ecb15144dd647b3895f836d393211be.png)
>
> 对于城市3，切断通往3的所有道路后，形成2个城市群[（1，2），（4，5）]，其聚集度分别都是2。DP3 = 2。
>
> 对于城市4，切断通往城市4的所有道路后，形成2个城市群[（1，2，3），（5）]，DP4 = max（3，1）= 3。
>
> 依次类推，切断其它城市的所有道路后，得到的DP都会大于2，因为城市3就是满足条件的城市，输出是3。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `6`  
> `1 2`  
> `2 3`  
> `2 4`  
> `3 5`  
> `3 6`
>
> **输出**
>
> `2 3`
>
> **说明**
>
> 将通往2或者3的所有路径切断，最大城市群数量是3，其他任意城市切断后，最大城市群数量都比3大，所以输出2 3。

# 思路

> 1：当切断通往一个城市i的所有路径之后，其他的城市形成了独立的城市群，这比较容易想到并查集， **两个城市相连，就把两个城市合并**
> 。循环n次遍历所有城市的结果，每个城市遍历所有的链接信息，如果出现当前循环需要排除的城市，则不执行本次合并操作。
>
> 2：并查集实现细节
>
>   1. 并查集模板中初始化时，需要从1开始，因为城市的编号是从1开始。
>   2. 统计每个城市所在的最大的城市数量，即聚集度
>

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.N = n
            self.id = [0 for x in range(n+1)]
            self.sz = [0 for x in range(n+1)]
            for i in range(1, n+1):
                self.id[i] = i
                self.sz[i] = 1
     
        def getMax(self):
            max_val = 0
            for i in range(1, self.count+1):
                max_val = max(max_val, self.sz[i])
            return max_val
    
        def union (self, p, q):
            pRoot = self.find(p)
            qRoot = self.find(q)
            if (pRoot != qRoot):
                if (self.sz[pRoot] < self.sz[qRoot]) :
                    self.id[pRoot] = qRoot
                    self.sz[qRoot] += self.sz[pRoot]
                else:
                    self.id[qRoot] = pRoot
                    self.sz[pRoot] += self.sz[qRoot]
                self.count-=1
            
        def find (self, p) :
            if (p == self.id[p]) :
                return p
            self.id[p] = self.find(self.id[p])
            return self.id[p]
        
    
    
    n = int(input())
    arr = []
    for i in range(n-1):
        arr.append([int(x) for x in input().split(" ")])
    res = float('inf')
    maxArray = [0 for i in range(n + 1)]; #统计每个城市的聚集度
    for i in range(1, n+1):  # 对于每一个城市
        uf = UF(n);
        for j in range(n-1):  # 判断每一条路径
            if (arr[j][0] == i or arr[j][1] == i):
                continue
            else:
                uf.union(arr[j][0], arr[j][1])
        maxArray[i] = uf.getMax();  # 每个城市对应的聚集度
        res = min(res, maxArray[i]);  # 切掉路径后的最小聚集度
    res_str = ""
    for i in range(1, len(maxArray)):
        if (maxArray[i] == res):
            res_str += str(i) + " "
    print(res_str[:-1])
     
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

