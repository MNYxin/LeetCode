**目录**

题目

思路

考点

Code

* * *

# 题目

> 同一个数轴X上有两个点的集合A={A1, A2, …, Am}和B={B1, B2, …, Bn}，Ai和Bj均为正整数，A、B已经按照从小到大排好序，
>
> A、B均不为空，给定一个距离R(正整数)，列出同时满足如下条件的所有（Ai, Bj）数对…
>
> 1) Ai<= Bj  
>  2) Ai, Bj之间的距离小于等于R  
>  3) 在满足1) 2)的情况下,每个Ai只需输出距离最近的Bj  
>  4) 输出结果按Ai从小到大的顺序排序
>
> **输入描述**
>
> 第一行三个正整数m,n,R
>
> 第二行m个正整数,表示集合A
>
> 第三行n个正整数,表示集合B
>
> **输入限制**
>
> 1<=R<=100000, 1<=n,m<=100000, 1<=Ai,Bj<=1000000000
>
> **输出描述**
>
> 每组数对输出一行Ai和Bj,以空格隔开
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4 5 5`  
> `1 5 5 10`  
> `1 3 8 8 20`
>
> **输出**
>
> `1 1`  
> `5 8`  
> `5 8`

# 思路

> 1：虽然有4个条件需要满足，但是每个条件其实都非常好满足， **在逻辑实现的情况下，直接循环遍历两个数组，在循环中判定各项条件即可** 。
>
> 2：第四个条件几乎是迷惑项，因为本身两个数组排好序了，循环后直接是从小到大的。

# 考点

> 1：条件判定
>
> 2：注重理解题意

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
     
    m, n, dis = map(int, input().split())
    set_a = [int(x) for x in input().split()]
    set_b = [int(x) for x in input().split()]
    
    i, j = 0, 0
    temp = list()
    while True:
        if i >= m or j >= n:
            break
        if set_b[j] - set_a[i] < 0:
            j += 1
        else:
            if set_b[j] - set_a[i] <= dis:
                temp.append((set_a[i], set_b[j]))
            i += 1
            
    for i, j in temp:
        print(i, j)
    

