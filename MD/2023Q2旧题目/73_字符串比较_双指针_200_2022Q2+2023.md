**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> _给定字符串A、B和正整数V，A的长度与B的长度相等， 请计算A中满足如下条件的最大连续子串的长度：_
>
> _1、该连续子串在A和B中的位置和长度均相同。_
>
> _2、该连续子串|A[i] – B[i]|之和小于等于V。其中|A[i] – B[i]|表示两个字母_ ** _ASCII码之差的绝对值_** _。_
>
> **_输入描述：_**
>
>   * _输入为三行：_
>   *  _第一行为字符串A，仅包含小写字符，1 <= A.length <=1000。_
>   *  _第二行为字符串B，仅包含小写字符，1 <= B.length <=1000。_
>   *  _第三行为正整数V，0 <= V <= 10000。_
>

>
> **_输出描述：_**
>
>   * _字符串最大连续子串的长度，要求该子串|A[i] – B[i]|之和小于等于V。_
>

>
> * * *
>
> **_示例 1_** _输入输出示例仅供调试，后台判题数据一般不包含示例_
>
> **_输入_**
>
> `xxcdefg`
>
> `cdefghi`
>
> `5`
>
> **_输出_**
>
> _`2`_

# 思路

> 1：第一步先求出 _|A[i] – B[i]|_
>
> _2：设立滑动窗口，满足窗口，右边界往右移动，不满足窗口，左边界往右移动。_
>
> _3：在移动的过程中得出最大子串长度_
>
> _![](https://img-blog.csdnimg.cn/a955c19adeed45c787df87f81bbd3612.jpeg)_

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    arr_a = input()
    arr_b = input()
    v = int(input())
    
    left = 0
    result = 0
    ascii_distance = 0
    for i in range(len(arr_a)-1):
        right = 0
        if (ord(arr_a[i + 1]) == ord(arr_a[i]) + 1) :
            right = i + 1
        else:
            left = i + 1
            continue
        
    
        for j in range(left, right):
            if (ord(arr_b[j + 1]) != ord(arr_b[j]) + 1) :
                ascii_distance = 0
                break
            
            if (j == left) :
                ascii_distance += abs(ord(arr_a[j]) - ord(arr_b[j]))
            
            ascii_distance += abs(ord(arr_a[j + 1]) - ord(arr_b[j + 1]))
        
    
        temp_length = right - left + 1
        if (ascii_distance <= v and temp_length > result) :
            result = temp_length
            ascii_distance = 0
        
    
    
    print(result)
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

