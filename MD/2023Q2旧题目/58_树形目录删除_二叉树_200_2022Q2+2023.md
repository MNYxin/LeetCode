**目录**

题目

思路

考点

Code

* * *

# 题目

> 某文件系统中有N个目录，每个目录都一个独一无二的ID。每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构呈树状结构。
>
> 假设，根目录的ID为0，且根目录没有父目录，其他所有目录的ID用唯一的正整数表示，并统一编号。  
>
> 现给定目录ID和其父目录ID的对应父子关系表[子目录ID，父目录ID]，以及一个待删除的目录ID，请计算并返回一个ID序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。  
>  注意：  
>  1、被删除的目录或文件编号一定在输入的ID序列中；  
>  2、当一个目录删除时，它所有的子目录都会被删除。
>
> **输入描述:** 输入的第一行为父子关系表的长度m；接下来的m行为m个父子关系对；最后一行为待删除的ID。序列中的元素以空格分割，参见样例。
>
> **输出描述:** 输出一个序列，表示因为删除指定目录后，剩余的目录ID。
>
> **示例1**  
>  **输入**  
>  5  
>  8 6  
>  10 8  
>  6 0  
>  20 8  
>  2 6  
>  8
>
> **输出**  
>  2 6

# 思路

> 1：第一步先按照输入，构造出父子结构，第二步按照删除的规则，将对应的节点的所有子节点都删除。
>
> 2：最后按照要求増序输出即可。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    rm_list_all = []
    def find_rm(rm_pv, tree_):
        rm_list_all.append(rm_pv)
        if tree_.get(rm_pv):
            for i in tree_.get(rm_pv):
                find_rm(i, tree_)
    
    
    lines = int(input().strip())
    tree = {}
    for i in range(lines):
        s, p = [int(i) for i in input().strip().split()]
        if tree.get(p) is None:
            tree[p] = [s]
        else:
            tree[p].append(s)
    rm_p = int(input().strip())
    find_rm(rm_p,tree)
    res = []
    
    for k,v in tree.items():
        if k not in rm_list_all and k != 0:
            res.append(k)
        for i in v:
            if i not in rm_list_all and i != 0:
                res.append(i)
    res = list(set(res))
    res.sort()
    print(' '.join([str(i) for i in res]))

