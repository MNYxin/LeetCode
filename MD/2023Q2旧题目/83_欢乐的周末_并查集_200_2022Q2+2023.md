## 题目

> 小华和小为是很要好的朋友，他们约定周末一起吃饭。
>
> 通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达），求小华和小为都能到达的聚餐地点有多少个？
>
> * * *
>
> **输入描述**
>
> 第一行输入m和n，m代表地图的长度，n代表地图的宽度。
>
> 第二行开始具体输入地图信息，地图信息包含：
>
> 0 为通畅的道路
>
> 1 为障碍物（且仅1为障碍物）
>
> 2 为小华或者小为，地图中必定有且仅有2个 （非障碍物）
>
> 3 为被选中的聚餐地点（非障碍物）
>
> **输出描述**
>
> 可以被两方都到达的聚餐地点数量，行末无空格。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4 4`
>
> `2 1 0 3`
>
> `0 1 2 1`
>
> `0 3 0 0`
>
> `0 0 0 0`
>
> **输出**
>
> `2`
>
> **说明**
>
> 第一行输入地图的长宽为3和4。
>
> 第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。
>
> 此时两者能都能到达的聚餐位置有2处。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4 4`
>
> `2 1 2 3`
>
> `0 1 0 0`
>
> `0 1 0 0`
>
> `0 1 0 0`
>
> **输出**
>
> `0`
>
> **说明**
>
> 第一行输入地图的长宽为4和4。
>
> 第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。
>
> 由于图中小华和小为之间有个阻隔，此时，没有两人都能到达的聚餐地址，故而返回0。
>
> **备注:**
>
> 地图的长宽为m和n，其中：
>
> 4 <= m <= 100
>
> 4 <= n <= 100
>
> 聚餐的地点数量为 k，则
>
> 1< k <= 100

# 思路

> 1：并查集，模板要记住

# ![](https://img-blog.csdnimg.cn/8f5fda8d171344b892ffada3f4c037ac.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
            return self.item[x]
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
    
    #获取输入
    input_param = [int(x) for x in input().split(" ")]
    m = input_param[0]
    n = input_param[1]
    matrix = []
    for i in range(m):
        matrix.append([int(x) for x in input().split(" ")])
    
    uf = UF(input_param[0]*input_param[1])
    positions = []
    dinner = []
    i=0
    while(True):
        if(i>=n):
            break
        else:
            j=0
            while(True):
                if(j>=m):
                    break
                else:
                    if matrix[i][j] == 1:
                        j+=1
                        continue
                    else:
                        if matrix[i][j] == 2:
                            positions.append(i * m + j)
                        elif matrix[i][j] == 3:
                            dinner.append(i * m + j)
    
                        if (i+1 < m):
                            if(matrix[i+1][j]!=1):
                                uf.union_connect(i * m + j, (i+1) * m + j)
                        if (i-1 >= 0):
                            if(matrix[i-1][j]!=1):
                                uf.union_connect(i * m + j, (i-1) * m + j)
                        if (j+1 < n):
                            if(matrix[i][j+1]!=1):
                                uf.union_connect(i * m + j, (i) * m + j+1)
                        if (j-1 >= 0):
                            if(matrix[i][j-1]!=1):
                                uf.union_connect(i * m + j, (i) * m + j-1)
                j+=1
        i+=1
            
    target1 = uf.find(positions[0])
    target2 = uf.find(positions[1])
    result = 0
    if target1 == target2:
        k=0
        while(True):
            if(k>=len(dinner)):
                break
            else:
                if uf.find(dinner[k]) == uf.find(positions[0]):
                    result += 1
            k+=1
    print(result)

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)
>
> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

