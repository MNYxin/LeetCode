**所有题目均有三种语言实现。**[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")、[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")、[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")

# 题目

> A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9（1100 + 0101 =
> 9），B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。
>
> 输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。
>
> 如果无法满足A的要求，输出-1。
>
> 数据范围
>
> 1 <= 总苹果数量 <= 20000
>
> 1 <= 每个苹果重量 <= 10000
>
> **输入描述：**
>
> 输入第一行是苹果数量：3
>
> 输入第二行是每个苹果重量：3 5 6
>
> **输出描述：**
>
> 输出第一行是B获取的苹果总重量：11
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 输入
>
> 3  
>  3 5 6
>
> 输出
>
> 11
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 输入
>
> 8  
>  7258 6579 2602 6716 3050 3564 5396 1773
>
> 输出
>
> 35165
>
> ![](https://img-blog.csdnimg.cn/80080b71730848bdb701e743c973fef2.webp)

# 思路

> 1：先审题，A的目标是 等分，也就是目标是一人一半。
>
> 2： **不进位的二进制加法，等同于二进制的异或操作。**
>
> 3：B要先满足 A 的 需求，那么肯定要先判定所有苹果在不进位的二进制加法前提下能否等分， **等分那就意味着分出来的两堆苹果异或的结果为 0** 。
>
> 4： **如果可以等分，那么取出最小的苹果分给 A 即可** 。因为所有苹果异或的结果是0，所以任意拿出1个，分成另一堆，
> 那么这两堆的重量，按照A的算法去算，必然是相等的 （不信可以试一试）。
>
> 5：如果不能等分，则直接返回 -1。

# 考点

> 1：题目理解能力
>
> 2： **异或** 的应用

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import random
     
    #树节点
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
    # 处理输入
    n = int(input())
    nums = [int(x) for x in input().split(" ")]
    aWeight = 0
    for i in range(0, len(nums)):
        #不进位的二进制加法，等同于二进制的异或操作。
        aWeight = aWeight ^ nums[i]
    if aWeight == 0:
        nums.sort(reverse=True)
        nums.pop()   
        print(sum(nums))
    else:
        print(-1)
    
        
    
        
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

