**目录**

题目

思路

考点

Code

* * *

# 题目

> 题目描述  
>  给你一个由 大于0的数（陆地）和 0（水）组成的的二维网格，请你计算网格中最大岛屿的体积。陆地的数表示所在岛屿的体积。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
> **输入描述**  
>  第一行是二维网格的宽和高。  
>  后面几行是二维网格。
>
> **输出描述**  
>  输出岛屿的最大体积。
>
> **样例**  
>  输入  
>  5 5  
>  0 1 1 0 0  
>  0 1 1 0 0  
>  0 0 0 0 0  
>  0 0 1 2 3  
>  0 0 1 3 9  
>  输出  
>  19

# 思路

> 1：[leetcode 200](https://leetcode.cn/problems/number-of-islands/ "leetcode
> 200") 和[leetcode 695](https://leetcode.cn/problems/max-area-of-island/
> "leetcode 695") 很像
>
> 2：唯一做了一些改动就是将求解岛屿的个数，改为了求岛屿中最大的那个的面积

# 考点

> 1：DFS
>
> ![](https://img-blog.csdnimg.cn/d4e9d742e43e4124a89dab6282e2b24c.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
    
    params = [int(x) for x in input().split(" ")]
    row = params[0]
    col = params[1]
    matrix = []
    max_val = -float("inf")
    #初始化岛屿
    for i in range(row):
        matrix.append([int(x) for x in input().split(" ")])
    
    area = 0
    def dfs(matrix, i, j):
        global row
        global col
        global area
        if (i < 0 or i >= row or j < 0 or j >= col or matrix[i][j] == 0):
            return
        
        area += matrix[i][j]
        matrix[i][j] = 0
        #上下左右判断是否为1
        dfs(matrix, i-1, j)
        dfs(matrix, i+1, j)
        dfs(matrix, i, j-1)
        dfs(matrix, i, j+1)
    
    
    for i in range(row):
        for j in range(col):
            if (matrix[i][j] > 0):
                #求当前点所属岛屿的大小
                dfs (matrix, i, j)
                max_val = max(area, max_val)
                area = 0
            
    print(max_val)
    
    

