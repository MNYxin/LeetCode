**目录**

题目

思路

Code

* * *

## 题目

> 商店里有N件唯一性商品，每件商品有一个价格，第i件商品的价格是 a[i]。一个购买方案可以是 **从N件商品种选择任意件进行购买(至少一件)
> ，花费即价格之和** 。  
>  现在你需要求出所有购买方案中花费前K小的方案，输出这些方案的花费。当两个方案选择的商品集合至少有一件不同，视为不同方案，因此可能存在两个方案花费相同.  
>  **输入描述**  
>  输入数据含两行:  
>  第一行包含两个整数N，K，整数之间通过空格隔开。分别表示商品的个数，以及需要求得的花费个数。1<=N<=10000，1<=K<=min(2^N -
> 1, 100000)
>
> 第二行包含N个整数a1，a2，..an,整数之间通过空格隔开。表示N件商品的价格。1<=a1<= a2 ...<= an <= 10000  
>  **输出描述**  
>  按花费从小到大的顺序依次输出K行，一行一个整数。表示花费前K小的购买方案的花费
>
> **示例1：**
>
> **输入**  
>  5 6  
>  1 1 2 3 3  
>  输出
>
> 1
>
> 1
>
> 2
>
> 2
>
> 3
>
> 3
>
> **示例2：**
>
> **输入**
>
> 3 5
>
> 1 100 101  
>  输出  
>  1  
>  100
>
> 101
>
> 101
>
> 102
>
> ![](https://img-blog.csdnimg.cn/635beb60efa841719030de02df37b29f.jpeg)

# 思路

> 1：[HDU的OJ题](http://acm.hdu.edu.cn/showproblem.php?pid=4546
> "HDU的OJ题")，逻辑几乎一致。
>
> 2：全组合中的前K小，暴力遍历肯定不行，必然超时，我看网上很多题解，大部分用的都是优先级队列，[HDU4546比赛难度(优先堆+思维
> 好题)_小胡同的诗的博客-
> CSDN博客](https://blog.csdn.net/calculate23/article/details/86777491
> "HDU4546比赛难度\(优先堆+思维 好题\)_小胡同的诗的博客-CSDN博客")，这个写的思路还算清晰吧。
>
> 3：该模块定义的优先级队列，其内部使用了 `heapq`
> 模块，所以它的时间复杂度和heapq是相同的。当一个对象的所有元素都是可比较的时，默认情况下是根据队列中的对象的第一个元素进行排序，越小的优先级越高，排在越前面。当第一个元素相同时，依次比较后续的元素的大小来进行排序。由于
> `PriorityQueue` 是继承自 `Queue` 类，所以很多函数的用法可以直接参照于 `Queue` 类中的函数。

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import queue
    import sys
    from queue import Queue
    
    params = [int(x) for x in input().split(" ")]
    n=params[0]
    m = params[1]
    nums = [int(x) for x in input().split(" ")]
    nums = sorted(nums, key=lambda x: x, reverse=False)
    self_queue = queue.PriorityQueue()
    c = [nums[0], [0, 0]]
    for i in range(m):
        print(c[1][0] + nums[c[1][1]])
        if c[1][1] + 1 < n:
            self_queue.put([c[1][0] + nums[c[1][1]] + nums[c[1][1]+1], [c[1][0] + nums[c[1][1]], c[1][1]+ 1]])
            c[1][1]+= 1
            self_queue.put([c[1][0] + nums[c[1][1]], c[1]])
        c = self_queue.get()
        

##

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

