**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 对报文进行重传和重排序是常用的可靠性机制，重传缓冲区内有一定数量的子报文，每个子报文在原始报文中的顺序已知，现在需要恢复出原始报文。  
>  **输入描述**  
>  输入第一行为N，表示子报文的个数，0 < N <= 1000。  
>
> 输入第二行为N个子报文，以空格分开，子报文格式为字符串报文内容+后缀顺序索引，字符串报文内容由|a-z,A-Z)组成后缀为整形值，表示顺序。顺序值唯一，不重复。  
>  **输出描述:**  
>  EN输出恢复出的原始报文。按照每个子报文的顺序的升席排序恢复出原始报文，顺序后缀需要从恢复出的报文中删除掉  
>  **用例1  
>  输入:**
>
> 4  
>  rolling3 stone4 like1 a2  
>  输出:  
>  like a rolling stone  
>  说明:  
>  4个子报文的内容分别为roling,stone,like,a，顺序值分别为3，4，1，2，按照顺序值升序并删除掉顺序后缀得到恢复的原始报文: like
> a rolling stone  
>  **用例2  
>  输入:**  
>  8  
>  gifts6 and7 Exchanging1 all2 precious5 things8 kinds3 of43
>
> // 注: 这里需要注意:and7与Exchanging1有两个空格  
>  输出:  
>  Exchanging all kinds of precious gifts and things

# 思路

> 1：简单题，重点考察的其实是字符串的处理。
>
> 2：第一步我们将每个字符串的后缀数字解析出来之后，存储到map中。第二步直接遍历1~N，取出对应的字符串，输出即可。

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    N = int(input())
    input_strs = input().split(" ")
    
    order_map = {}
    for i in range(N):
        word = input_strs[i]
        index = 0
        for j in range(len(word)):
            if word[j].isdigit():
                index = j
                break
        order_map[int(word[index:])] = word[:index]
    
    output_str = ""
    for i in range(1, N+1):
        output_str += order_map[i]
        if i != N:
            output_str += " "
    
    print(output_str)
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

