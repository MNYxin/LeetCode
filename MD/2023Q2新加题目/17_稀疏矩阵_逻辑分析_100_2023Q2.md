**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 如果矩阵中的许多系数都为零，那么该矩阵就是稀疏的。对稀疏现象有兴趣是因为它的开发可以带来巨大的计算节省，并且在许多大的实践中都会出现矩阵稀疏的问题。  
>  给定一个矩阵，现在需要逐行和逐列地扫描矩阵， **如果某一行或者某一列内，存在连续出现的O的个数超过了行宽或者列宽的一半 W / 2整除)**
> ，则认为该行或者该列是稀疏的。  
>  扫描给定的矩阵，输出稀疏的行数和列数  
>  **输入描述**  
>  第行输入为M和N，表示矩阵的大小M*N，0< M <=100，0 < N <=100
>
> 接下来M行输入为矩阵的成员，每行N个成员，知阵成员都是有符号整数，范围-32768到32767  
>  **输出描述**  
>  输出两行，第一行表示稀疏行的个数，第二行表示稀疏列的个数
>
> **示例1：**
>
> **输入**
>
> 3 3  
>  1 0 0  
>  0 1 0  
>  0 0 1  
>  输出
>
> 3  
>  3
>
> 说明  
>  给定的3*3矩阵里，每一行和每一列内都存在2个0，行宽3，列宽3，[3/2] = 1，因此稀疏行有3个，稀疏列有3个。
>
> **示例2：**
>
> **输入**
>
> 5 3  
>  -1 0 1  
>  0 0 0  
>  -1 0 0  
>  0 -1 0
>
> 0 0 0
>
> 输出
>
> 5
>
> 3  
>  说明  
>  给定的5*3矩阵，每行里面0的个数大于等于1表示稀疏行，每列里面0的个数大于等于2表示稀疏行，所以有5个稀疏行,3个稀疏列

# 思路

> 1：虽然题目难读，但确实是简单题。要求很明确：“ **如果某一行或者某一列内，存在连续出现的0的个数超过了行宽或者列宽的一半 W / 2整除)** ”
>
> 2：代码只要模拟统计每一行，每列的0的个数，最后再做出比较即可。
>
> 3：送分题啊，同志们赶紧冲！

# ![](https://img-blog.csdnimg.cn/0c010709b3d04a99b9577c9b2de6d40a.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
     
    data = [int(x) for x in input().split(" ")]
    m = data[0]
    n = data[1]
    
    rowZeroCount = [0 for x in range(m)]
    colZeroCount = [0 for x in range(n)]
    
    for i in range(m):
        input_arr = [int(x) for x in input().split(" ")]
        for j in range(n):
            if (input_arr[j] == 0):
                rowZeroCount[i]+=1
                colZeroCount[j]+=1
    
    res1 = 0
    for i in range(m):
        if rowZeroCount[i] >= int(n/2):
            res1+=1
    print(res1)
    
    res2= 0
    for i in range(n):
        if colZeroCount[i] >= int(m/2):
            res2+=1
    print(res2)
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

