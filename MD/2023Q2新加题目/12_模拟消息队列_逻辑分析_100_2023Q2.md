# 题目

> 让我们来模拟一个消息队列的运作，有一个发布者和若干消费者，发布者会在给定的时刻向消息队列发送消息若此时消息队列有消费者订阅，
> **这个消息会被发送到订阅的消费者中优先级最高(输入中消费者按优先级升序排列)的一个** 。
>
>
> 若此时没有订阅的消费者，该消息被消息队列丢弃。消费者则会在给定的时刻订阅消息队列或取消订阅。当消息发送和订阅发生在同一时刻时，先处理订阅操作，即同一时刻订阅的消费者成为消息发送的候选。.当消息发送和取消订阅发生在同一时刻时，先处理取消订阅操作，即消息不会被发送到同一时刻取消订阅的消费者  
>  **输入描述**  
>  输入为两行  
>
> 第一行为2N个正整数，代表发布者发送的N个消息的时刻和内容为方便解折，消息内容也用正整数表示)。第一个数字是第一人消息的发送时刻，第二个数字是第一个消息的内容，以此类推。用例保证发送时刻不会重复，但注意消息并没有按照发送时刻排列。  
>
> 第二行为2M个正整数，代表M个消费者订阅和取消订阅的时刻。第一个数字是第一个消费者订阅的时刻，第二个数字是第一人消费者取消订阅的时刻，以此类推。用例保证每个消费者的取消订阅时刻大于订阅时刻，消费者按优先级
> 升序排列  
>  两行的数字都由空格分隔。N不超过100，M不超过10，每行的长度不超过1000字符.
>
> **输出描述**  
>  输出为M行，依次为M个消费者收到的消息内容，消息内容按收到的顺序排列，且由空格分隔:若某个消费者没有收到任何消息，则对应的行输出-1.  
>  **示例1：  
>  输入**
>
> 2 22 1 11 4 44 5 55 3 33  
>  1 7 2 3  
>  输出  
>  11 33 44 55
>
> 22  
>  说明
>
> 消息11在1时刻到达，此时只有第一个消费者订阅，消息发送给它，  
>  消息22在2时刻到达，此时两人消费者都订阅了，消息发送给优先级最高的第二个消费者:  
>  消息33在时刻3到达，此时只有第一个消费者订阅，消息发送给它;  
>  余下的消息按规则也是发送给第一个消费者
>
> **示例2：  
>  输入**  
>  5 64 11 64 9 97  
>  9 11 4 9
>
> 输出  
>  97  
>  64
>
> 说明  
>  消息64在5时刻到达，此时只有第二个消费者订阅，消息发送给它  
>
> 消息97在9时刻到达，此时只有第一消费者订阅(因为第二个消费者刚好在9时刻取消订阅)，消息发送给它.11时刻也到达了一个内容为64的消息，不过因为没有消费者订阅，消息被丢弃

# 思路

> 1：逻辑分析题目，首先将消费者和发布者的信息存储下来。
>
> 2：核心的判定就是消息的发出时间是否和消费时间相吻合，如果符合，则被第一个消费者拿走。

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import queue
    import sys
    import bisect
    from queue import Queue
    
    class Message:
        def __init__(self, a, b):
            self.a = a
            self.b = b
    
    nums = [int(x) for x in input().split(" ")]
    nums1 =  [int(x) for x in input().split(" ")]
    n = len(nums)
    m = len(nums1)
    
    # 发布信息
    producer_map = []
    i=0
    while(i<n):
        ss = Message(nums[i], nums[i + 1])
        producer_map.append(ss)
        i+=2
    producer_map = sorted(producer_map, key=lambda x:x.a, reverse=False)
    
    
    # 消费信息
    consumer_map = []
    j=0
    while(j<m):
        ss1 = Message(nums1[j], nums1[j + 1])
        consumer_map.append(ss1)
        j+=2
    
    # 构造消费关系
    relation_map = [[] for x in range(int(m/2))]
    
    
    for i in range(int(n/2)):
        j = int(m / 2) - 1
        while(j>=0):
            if (producer_map[i].a >= consumer_map[j].a):
                if(producer_map[i].a < consumer_map[j].b):
                    relation_map[j].append(producer_map[i].b)
                    break
            j-=1
    
    i=0
    while(True):
        if (i>=int(m / 2)):
            break
        else :
            if (len(relation_map[i]) == 0) :
                print("-1")
            else :
                result = ""
                for x in relation_map[i] :
                    result += str(x) + " "
                print(result)
            
        
        i+=1
    
    
    
    
    
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

