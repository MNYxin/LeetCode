**目录**

题目

思路

Code

* * *

## 题目

> 误码率是最常用的数据通信传输质量指标。它可以理解为“在多少位数据中出现一位差错”。移动通信
> 网络中的误码率主要是指比特误码率，其计算公式如下:比特误码率=错误比特数/传输总比特数。为了简单，我们使用字符串来标识通信的信息，一个字符错误了，就认为出现了一个误码输入一个标准的字符串，和一个传输后的字符串，计算误码率字符串会被压缩。  
>  例:“2A3B4D5X1Z”表示"AABBBDDDDXXXXXZ"
>
> 用例会保证两个输入字符串解压后长度一致，解压前的长度不一定一致每个生成后的字符串长度<100000000.  
>  **输入描述**  
>  两行，分别为两种字符串的压缩形式。  
>  每行字符串(压缩后的) 长度<100000  
>  **输出描述**  
>  一行，错误的字数量/展开后的总长度  
>  **备注**  
>  注意: 展开后的字符串不含数字
>
> **示例1：  
>  输入**
>
> 3A3B
>
> 2A4B  
>  输出
>
> 1/6  
>  **示例2：  
>  输入**  
>  5Y5Z
>
> 5Y5Z
>
> 输出  
>  0/10  
>  **示例3：  
>  输入**  
>  4Y5Z
>
> 9Y
>
> 输出  
>  5/9
>
> ![](https://img-blog.csdnimg.cn/7fb5cf69942948a7bfe8ceed70dbd4cb.webp)

#  输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# 思路

>
> 1：题目理解起来还是挺快的，就是看两个字符串解压以后，对比起来有多少位不一致。用暴力解法直接双循环就可以，但是注意题目给定的数据范围很大，双循环大概率超时。
>
> 2：关键就在于， **怎样不解压，也能对比到字符串的不一致？**
>
> 以示例1为例，
>
> 3A和2A -> 后缀都是A，但是前缀数字不一样，那我们取最短的相同字符，
>
> 第一个字符串就变成了1A3B
>
> 第二个字符串就变成了4B
>
> 此时再继续上述步骤，1A和4B，后缀不一样，那不同的字符直接取最短的哪个。
>
> 第一个字符串变成了3B
>
> 第二个字符串就变成了3B
>
> 此时再继续上述步骤，3B和3B，前后缀都一致，所以就结束了，在第二步时找到了不同的个数。
>
> 3：简单练一练字符串压缩的题目吧，说不定能考到。
>
> [面试题 01.06. 字符串压缩 - 力扣（LeetCode）](https://leetcode.cn/problems/compress-
> string-lcci/ "面试题 01.06. 字符串压缩 - 力扣（LeetCode）")

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
     
    
    s1 = input()
    s2 = input()
    a_list = []
    b_list = []
    index_tmp1 = 0
    total = 0
    
    length = len(s1)
    while(index_tmp1 < length) :
        num = 0
        while(index_tmp1 < length and s1[index_tmp1].isdigit()) :
            num *= 10
            num += int(s1[index_tmp1]) - int('0')
            index_tmp1 +=1
        
        c = s1[index_tmp1]
        a_list.append([c, num])
        total += num
        index_tmp1 +=1
    
    
    index_tmp2 = 0
    len2_temp = len(s2)
    while(index_tmp2 < len2_temp) :
        num = 0
        while(index_tmp2 < len2_temp and  s2[index_tmp2].isdigit()) :
            num *= 10
            num += int(s2[index_tmp2]) - int('0')
            index_tmp2 +=1
        
        c = s2[index_tmp2]
        b_list.append([c, num])
        index_tmp2 +=1
    
    
    index = 0
    tmp1 = 0
    tmp2 = 0
    i = 0
    j = 0
    count = 0
    
    while ( i < len(a_list) and j < len(b_list)) :
        chars1 = a_list[i]
        chars2 = b_list[j]
        tmp1 += chars1[1]
        tmp2 += chars2[1]
        chars1[1] = 0
        chars2[1] = 0
        now1 = chars1[0]
        now2 = chars2[0]
    
        while(index < tmp1 and index < tmp2) :
            if(now1 != now2) :
                count+=1
            
            index +=1
        
        if(index >= tmp1) :
            i +=1
        
        if(index >= tmp2) :
            j +=1
        
    
    
    print(str(count) + "/" + str(total))

##

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

