**目录**

题目

思路

Code

* * *

## 题目

>
> 存在一个m*n的二维数组，其成员取值范围为0，1，2。其中值为1的元素具备同化特性，每经过1S，将上下左右值为0的元素同化为1。而值为2的元素，免疫同化。将数组所有成员随机初始化为0或2，
> **再将矩阵的[0,0]元素修改成1** ，在经过足够长的时间后求矩阵中有多少个元素是0或2(即0和2数量之和）  
>  **输入描述**  
>  输入的前两个数字是矩阵大小。后面是数字矩阵内容  
>  **输出描述**  
>  返回矩阵中非1的元素个数
>
> **示例1：**
>
> **输入**
>
> 4 4  
>  0 0 0 0  
>  0 2 2 2  
>  0 2 0 0  
>  0 2 0 0
>
> 输出
>
> 9  
>  说明
>
> 输入数字前两个数字是矩阵大小。后面的数字是矩阵内容。  
>  起始位置(0,0)被修改为1后，最终只能同化矩阵为:  
>  1 1 1 1  
>  1 2 2 2  
>  1 2 0 0  
>  1 2 0 0  
>  所以矩阵中非1的元素个数为9
>
> ![](https://img-blog.csdnimg.cn/28579c6ffa53468db139244709a18224.webp)

# 思路

> 1：【每经过1S，将上下左右值为0的元素同化为1】，看到这句话基本上都能想起来BFS了吧，还可以结合之前的BFS类问题一起练习：
>
> [【100%通过率】华为OD机试真题 Java 实现【计算网络信号】【2022.11 Q4 新题】_MISAYAONE的博客-
> CSDN博客](https://blog.csdn.net/misayaaaaa/article/details/128351616
> "【100%通过率】华为OD机试真题 Java 实现【计算网络信号】【2022.11 Q4 新题】_MISAYAONE的博客-CSDN博客")
>
> 2：不是华为题库里面的有不少经典题，多练吧，其实这些题目都是套模板，没啥难度的：
>
> [算法/BFS/DFS_上下移动记录算法_Rainbow-c的博客-
> CSDN博客](https://blog.csdn.net/qq_43746837/article/details/123206856
> "算法/BFS/DFS_上下移动记录算法_Rainbow-c的博客-CSDN博客")

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    
    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    matrix = [[int(x) for x in input().split(" ")] for y in range(m)]
    matrix[0][0] = 1
    queue = []
    queue.append([0, 0])
    result = 1
    
    while (len(queue)>0):
        node = queue[0]
        queue.pop(0)
        x = node[0]
        y = node[1]
        if (x+1<m and  matrix[x+1][y] == 0):
            matrix[x+1][y] = matrix[x][y] + 1
            queue.append([x+1, y])
            result += 1
        
        if (y+1<n and  matrix[x][y+1] == 0):
            matrix[x][y+1] = matrix[x][y] + 1
            queue.append([x, y+1])
            result += 1
        
        if (x-1>=0 and  matrix[x-1][y] == 0):
            matrix[x][y+1] = matrix[x][y] + 1
            queue.append([x-1, y])
            result += 1
        
        if (y-1>=0 and  matrix[x][y-1] == 0):
            matrix[x][y-1] = matrix[x][y] + 1
            queue.append([x, y-1])
            result += 1
             
    print(m * n - result)

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

