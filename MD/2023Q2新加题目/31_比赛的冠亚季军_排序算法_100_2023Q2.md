**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 有N
> (3<=N<10000)个运动员，他们的id为0到N-1,他们的实力由一组整数表示。他们之间进行比赛，需要决出冠亚军。比赛的规则是0号和1号比赛，2号和3号比赛，以此类推，每一轮，相邻的运动员进行比赛，获胜的进入下轮;实力值大的获胜，实力值相等的情况，id小的情况下获胜:轮空的直接进入下一轮.  
>  **输入描述:**  
>  输入一行N个数字代表N的运动员的实力值(0<=实力值<=10000000000).  
>  **输出描述:**  
>  输出冠亚季军的id，用空格隔开.
>
> **示例1  
>  输入:**  
>  2 3 4 5  
>  输出:  
>  3 1 2  
>  **说明:**  
>
> 第一轮比赛，id为0实力值为2的运动员和id为1实力值为3的运动员比赛，1号胜出进入下一轮争夺冠亚军，id为2的运动员和id为3的云动员比赛，3号胜出进入下一轮争夺冠亚军:冠亚军比赛，3号胜1号:故冠至为3号，亚军为1号。2号50号，比赛进行季军的全夺，2号实力值为4，0号实力值2，故2号胜出，得季军。冠亚季军为3
> 1 2。

# 思路

> 1：第一步按照条件对胜者组和败者组进行分类
>
> 2：对各组内的运动员进行自定义排序。
>
> 3：本质还是考察自定义排序的方法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
    
    class Athlete:
        def __init__(self, id, score):
            self.id = id 
            self.score = score
    
    def comp(a,b):
        if(a.score == b.score):
            return a.id - b.id;
        return b.score - a.score
    
    
    nums = [int(x) for x in input().split(" ")]
    
    all_athletes = []
    for i in range(len(nums)):
        all_athletes.append(Athlete(i, nums[i]))
    
    win = []
    lose = []
    
    def compete(all_athletes):
        result = []
        for i in range(0, len(all_athletes), 2):
            one = all_athletes[i]
            if(i == len(all_athletes) - 1):
                result.append(one)
                if(len(all_athletes) == 3):
                    win.append(one)
                break
            
            two = all_athletes[i+1]
            if(one.score >= two.score):
                result.append(one)
                if(len(all_athletes) <= 4):
                    win.append(one)
                    lose.append(two)
            else:
                result.append(two)
                if(len(all_athletes) <= 4):
                    win.append(two)
                    lose.append(one)
        if(len(result) > 4):
            compete(result)
    
    compete(all_athletes)
    win = sorted(win, key=functools.cmp_to_key(comp))
    lose = sorted(lose, key=functools.cmp_to_key(comp))
    
    print(str(win[0].id) +" "+ str(win[1].id) +" "+ str(lose[0].id))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

