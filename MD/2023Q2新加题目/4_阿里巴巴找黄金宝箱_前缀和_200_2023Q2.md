**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 一贫如洗的樵夫阿里巴巴在去砍柴的路上，无意中发现了强盗集团的藏宝地，藏宝地有编号从0~N的箱子，每个箱子上面贴有一个数字，箱子中可能有一个黄金宝箱。  
>  黄金宝箱满足排在它之前的所有箱子数字和等于排在它之后的所有箱子数字和;第一个箱子左边部分的数字和定义为0;最后一个宝箱右边部分的数字和定义为0。  
>  请帮阿里巴巴找到黄金宝箱，输出第一个满足条件的黄金宝箱编号，如果不存在黄金宝箱，请返回-1.  
>  **输入描述**  
>  箱子上贴的数字列表，使用逗号分隔，例如1，-1，0。  
>  宝箱的数量不小于1个，不超过10000  
>  宝箱上贴的数值范围不低于-1000，不超过1000  
>  **输出描述:**  
>  第一个黄金宝箱的编号
>
> **示例1  
>  输入:**  
>  2,5,-1,8,6  
>  **输出:**  
>  3  
>  说明:  
>  下标3之前的数字和为: 2 + 5 + -1 = 6下标3之后的数字和为: 6 = 6
>
> **示例2**
>
> **输入:**
>
> 8,9  
>  **输出:**
>
> -1  
>  说明:  
>  不存在符合要求的位置  
>  **示例3  
>  输入:**
>
> 11  
>  **输出:**
>
> 0  
>  说明:  
>  下标0之前的数字和为: 0  
>  下标0之后的数字和为: 0

# 思路

> 1：[leetcode 724原题](https://leetcode.cn/problems/find-pivot-
> index/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china
> "leetcode 724原题")，一模一样。
>
> 2：
>
> 题目仅说明是整数数组，无其他已知条件，因此考虑直接遍历数组。
>
> 设索引 i 对应变量「左侧元素相加和 sum_left 」和「右侧元素相加和 sum_right 」。  
>  遍历数组 nums ，每轮更新 sum_left 和 sum_right 。  
>  遍历中，遇到满足 sum_left == sum_right 时，说明当前索引为中心下标，返回即可。  
>  若遍历完成，仍未找到「中心下标」，则返回 -1 。  
>  初始化时，相当于索引 i=−1 ，此时 sum_left = 0 , sum_right = 所有元素的和 。
>
> ![](https://img-blog.csdnimg.cn/002d5b85d1914af19d4ac3338a9a74b0.png)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    def pivotIndex(nums):
        sum_left, sum_right = 0, sum(nums)
        for i in range(len(nums)):
            sum_right -= nums[i]
            # 若左侧元素和等于右侧元素和，返回中心下标 i
            if sum_left == sum_right:
                return i
            sum_left += nums[i]
        return -1
    
    
    #获取输入
    print(pivotIndex([int(x) for x in input().split(",")]))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

