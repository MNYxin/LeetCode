**目录**

题目

思路

Code

要求

* * *

## 题目

> 现有两个整数数组，需要你找出两个数组中同时出现的整数，并按照如下要求输出:
>
> 1.有同时出现的整教时，先按照同时出现次数(整数在两人数组中都出现并目出现次数较少的那人)进行归类，然后按照出现次数从小到大依次按行输出。  
>  2.没有同时出现的整数时，输出NULL  
>  **输入描述**  
>
> 第一行为第一个整数数组，第二行为第二个整数数组，每行数中整数与整数之间以英文号分，整数的取值范用为200,2001，数组长度的范用为[1，10000]之间的整数。  
>  **输出描述**  
>  按照出现次数从小到大依次按行输出，每行输出的格式为:  
>  出现次数:该出现次数下的整数升序排序的结果  
>  格式中的"."为英文冒号，整数间以英文逗号分隔.
>
> 示例1：  
>  输入
>
> 5,3,6,-8,0,11  
>  2,8,8,8,-1,15  
>  输出
>
> NULL  
>  说明  
>  两个整数数组没有同时出现的整数，输出NULL。
>
> 示例2：
>
> 输入：
>
> 5,8,11,3,6,8,8,-1,11,2,11,11  
>  11,2,11,8,6,8,8,-1,8,15,3,-9,11  
>  输出
>
> 1:-1,2,3,6
>
> 3:8,11
>
> 说明  
>
> 两整数数组中同时出现的整数为-12、3、6、8、11,其中同时出现次数为1的整数为-1,2,3.6(升序排序),同时出现次数为3的整数为8,11(升序排序),先升序输出出现次数为1的整数，再升序输出出现次数为3的整数。

# 思路

> 1：考察的就是数据结构的熟悉程度。各种map的操作。

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
    
    
    nums1 = [int(x) for x in input().split(",")]
    nums2 = [int(x) for x in input().split(",")]
    num1_map  = {}
    i=0
    while(True):
        if(i>=len(nums1)):
            break
        else:
            if nums1[i] in num1_map:
                num1_map[nums1[i]] += 1
            else:
                num1_map[nums1[i]] = 1
        i+=1
    
    num2_map  = {}
    j=0
    while(True):
        if(j>=len(nums2)):
            break
        else:
            if nums2[j] in num2_map:
                num2_map[nums2[j]] += 1
            else:
                num2_map[nums2[j]] = 1
        j+=1
    
    flag = True
    output_str = "NULL"
    same_num_map = {}
    for num in num1_map:
        if num in num2_map:
            flag = False
            if min(num1_map[num], num2_map[num]) not in same_num_map:
                same_num_map[min(num1_map[num], num2_map[num])] = []
            same_num_map[min(num1_map[num], num2_map[num])].append(num)
    if not flag:
        arr = []
        output_str = ""
        for key in same_num_map:
            arr.append(key)
        arr = sorted(arr, key=lambda x: x, reverse=False)
        for index in arr:
            new_res = sorted(same_num_map[index],key=lambda x: x, reverse=False)
            tmp_str = ""
            for ss in new_res:
                tmp_str += str(ss) + ","
            output_str =  str(index) + ":" + tmp_str[:-1]
            print(output_str)
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

