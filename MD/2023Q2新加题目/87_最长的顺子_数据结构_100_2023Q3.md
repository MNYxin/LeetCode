**所有题目均有三种语言实现。**[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")、[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")、[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")

# 题目

> 题目描述  
>  斗地主起源于湖北十堰房县，据说是一位叫吴修全的年轻人根据当地流行的扑克玩法“跑得快”改编的，如今已风靡整个中国，并流行于互联网上。  
>  牌型：  
>  单顺，又称顺子，最少5张牌，最多12张牌(3…A)不能有2，也不能有大小王，不计花色。  
>  例如：  
>  3-4-5-6-7-8，7-8-9-10-J-Q，3-4-5-6-7-8-9-10-J-Q-K-A  
>  可用的牌 3<4<5<6<7<8<9<10<J<Q<K<A<2<B(小王)<C(大王)，每种牌除大小王外有四种花色  
>  (共有13×4+2张牌)
>
> **输入描述**  
>  输入的第一行为当前手中的牌  
>  输入的第二行为已经出过的牌(包括对手出的和自己出的牌)
>
> **输出描述**  
>  最长的顺子  
>  对手可能构成的最长的顺子(如果有相同长度的顺子，输出牌面最大的那一个)，  
>  如果无法构成顺子，则输出 NO-CHAIN。
>
> 示例  
>  示例1  
>  输入  
>  3-3-3-4-4-5-5-6-7-8-9-10-J-Q-K-A-A-A-A  
>  4-5-6-7-8-8-8  
>  输出  
>  9-10-J-Q-K
>
> 示例2  
>  输入  
>  3-3-3-3-8-8-8-8  
>  K-K-K-K  
>  输出  
>  NO-CHAIN  
>  说明  
>  剩余的牌无法构成顺子

# 思路

> 1：主要考察的还是hash数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
    
    # 处理输入
    # 字典存储扑克
    porker_num = {'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14,'2':15,'B':16,'C':17}
    porker_str = {3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K',14:'A',15:'2',16:'B',17:'C'}
    
    # 所有的扑克
    porker = []
    lst = list(porker_num.values())
    for i in range(4):
        porker.extend(lst[:-2])
    porker.extend(lst[-2:])
    porker.sort()
    
    # 将自己的和已出的转换成数字
    input_have = list(porker_num.get(k) for k in input().upper().split('-')) # 注意大小写转换
    input_lost = list(porker_num.get(k) for k in input().upper().split('-'))
    temp = input_have + input_lost
    
    # 找到剩余的牌
    for j in range(len(temp)):
        if temp[j] in porker:
            porker.remove(temp[j])
    remain_porker = list(set(porker))
    
    # 去掉2和大小王
    if 15 in remain_porker:
        remain_porker.remove(15)
    if 16 in remain_porker:
        remain_porker.remove(16)
    if 17 in remain_porker:
        remain_porker.remove(17)
    # print(remain_porker)
    
    # 找最长子串
    def max_length(remain_porker,porker_str):
        result = []
        temp_res = []
        i = 1
        temp_res.append(remain_porker[0])
        while i < len(remain_porker):
            if remain_porker[i]-1 == remain_porker[i-1]:
                temp_res.append(remain_porker[i])
                i += 1
            else:
                if len(temp_res) >= len(result): 
                # 等号不可省略,因为长度相等时,输出最大的子串;
                # 因为porker已经排序了,最大子串总在后面
                    result = temp_res[:]
                temp_res.clear()
                temp_res.append(remain_porker[i])
                i += 1
        if len(temp_res) >= len(result): 
        # 等号不可省略,因为长度相等时,输出最大的子串;
        # 因为porker已经排序了,最大子串总在后面
            result = temp_res[:]
        if 5 <= len(result) <= 12:
            s = '-'.join([porker_str[j] for j in result])
            return s
        else:
            return 'NO-CHAIN'
    print(max_length(remain_porker,porker_str))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

