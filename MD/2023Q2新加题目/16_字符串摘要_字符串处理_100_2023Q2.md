**所有题目均有五种语言实现。 ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")****** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定一个字符串的摘要算法，请输出给定字符串的摘要值  
>  1、 **去除字符串中非字母的符号**  
>  2、 **如果出现连续字符 (不区分大小写)** ，则输出: 该字符 (小) + 连续出现的次数  
>  3、 **如果是非连续的字符(不区分大小写)** ，则输出: 该字符(小写)
> 该字母之后字符串中出现的该字符的次数、对按照以上方式表示后的字符串进行排序:
> 字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的则按字母进行排序，字母小的在前。  
>  **输入描述:**  
>  行字符串，长度为[1,200]
>
> **输出描述:**  
>  摘要字符串  
>  **示例1  
>  输入:**  
>  aabbcc  
>  输出:  
>  a2b2c2  
>  **示例2  
>  输入:**  
>  bAaAcBb  
>  输出:  
>  a3b2b2c0  
>  说明:  
>  第一个b非连续字母，该字母之后字符串中还出现了2次 (最后的两个Bb) ，所以输出b2，a连续出现3次，输出a3，  
>  c非连续，该字母之后字符串再没有出现过c，输出c0Bb连续2次，输出b2  
>  对b2a3c0b2进行排序，最终输出a3b2b2c0

# 思路

> 1：纯字符串处理的题目，熟悉下各种字符串函数和数据结构就行了。

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    from queue import Queue
     
    input_str = input()
     
    #条件1
    new_input_str = ""
    for i in input_str:
        if(i.isalpha()):
            new_input_str += i
    
    count = 1
    temp_char = new_input_str[-1].lower()
    
    #字符的集合
    char_list = []
    char_count_map ={}
    i = len(new_input_str)-2
    while(i >= 0):
        c = new_input_str[i].lower()
        #连续相同，条件2
        if(temp_char == c):
            count+=1
        else :
            #条件3
            if(count == 1):
                if temp_char in char_count_map:
                    count += char_count_map[temp_char]-1
                else:
                    count += -1
                
                char_count_map[temp_char]= count + 1
            else:
                char_count_map[temp_char]= count
            
            char_list.append([temp_char, count])
            temp_char = c
            count = 1
    
        if(i == 0):
            if(count == 1):
                if temp_char in char_count_map:
                    count += char_count_map[temp_char]-1
                else:
                    count += -1
            
            char_list.append([temp_char, count])
        i-=1
    
    #排序输出
    char_list = sorted(char_list,key=lambda ele:(-ele[1], ele[0]))
    
    print("".join(["".join([str(x) for x in y]) for y in char_list]))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

