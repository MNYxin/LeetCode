**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

>
> 2XXX年，人类通过对火星的大气进行宜居改造分析，使得火星已在理论上具备人类宜居的条件，由于技术原因，无法一次性将火星大气全部改造，只能通过局部处理形式，假设将火星待改造的区域为row
> *
> column的网格每个网格有3个值，宜居区、可改造区、死亡区，使用YES、NO、NA代替，YES表示该网格已经完成大气改造，NO表示该网格未进行改造，后期可进行改造，NA表示死亡区，不作为判断是否改造完成的宜居，无法穿过  
>
> 初始化下，该区域可能存在多个宜居区，并且每个宜居区能同时在每个太阳日单位向上下左右四个方向的相邻格子进行扩散，自动将4个方向相邻的真空区改造成宜居区;请计算这个待改造区域的网格中，可改造区是否能全部变成宜居区，如果可以，则返回改造的太阳日天数，不可以则返回-1。
>
> **输入描述:**  
>  输入row*column个网格数据，每个网格值枚举值如下: YES，NO，NA，样例:  
>  YES YES NO  
>  NO NO NO  
>  NA NO YES  
>  **输出描述:**  
>  可改造区是否能全部变成宜居区，如果可以，则返回改造的太阳日天数，不可以则返回-1.  
>  补充说明:  
>  grid[i]只有3种情况，YES、NO、NA  
>  row == grid.length, column == grid[i].length, 1 <= row, column <= 8
>
> **示例1  
>  输入:**  
>  YES YES NO  
>  NO NO NO  
>  YES NO NO  
>  **输出:**
>
> **2  
>  说明:**  
>  经过2个太阳日，完成宜居改造.
>
> **示例2  
>  输入:**  
>  YES NO NO NO
>
> NO NO NO NO  
>  NO NO NO NO  
>  NO NO NO NO  
>  **输出:**
>
> **6  
>  说明:**  
>  经过6个太阳日，可完成改造
>
>  
> **示例3  
>  输入:**
>
> NO NA  
>  **输出:**
>
> -1
>
> **说明:**  
>  无改造初始条件，无法进行改造
>
>  
> **示例4  
>  输入:**  
>  YES NO NO YES
>
> NO NO YES NO
>
> NO YES NA NA
>
> YES NO NA NO  
>  输出:
>
> -1  
>  说明:
>
> 右下角的区域，被周边三个死亡区挡住，无法实现改造

# 思路

> 1：好恶心这个题目，不给定输入的行列数，还要自己判断。
>
> 2：典型的一个多源BFS问题，可以参考 [leetcode](https://leetcode.cn/problems/as-far-from-
> land-as-possible/ "leetcode")上一个很类似的题目，题解区《宫水三叶》的讲解非常牛逼，可以参考下。

# ![](https://img-blog.csdnimg.cn/e792b3c442334e8bb6edfcc8c16e6bad.jpeg)

# Code【官方解法】

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import collections
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    import bisect
     
    def orangesRotting(grid):
        R, C = len(grid), len(grid[0])
    
        # queue - all starting cells with rotting oranges
        queue = collections.deque()
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == "YES":
                    queue.append((r, c, 0))
    
        def neighbors(r, c):
            for nr, nc in ((r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)):
                if 0 <= nr < R and 0 <= nc < C:
                    yield nr, nc
    
        d = 0
        while queue:
            r, c, d = queue.popleft()
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == "NO":
                    grid[nr][nc] = "YES"
                    queue.append((nr, nc, d + 1))
    
        if any("NO" in row for row in grid):
            return -1
        return d
    
    grid = []
    while True:
        try:
            grid.append(input().split(" "))
        except:
            break
    print(orangesRotting(grid))

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

