# 题目

> 有一个大小是N*M的战场地图，被墙壁 '#' 分隔成大小不同的区域，上下左右四个方向相邻的空地
> '.'，属于同一个区域，只有空地上可能存在敌人'E'，请求出地图上总共有多少区域里的敌人数小于K。  
>  **输入描述**  
>  第一行输入为N.M.K;  
>  N表示地图的行数，M表示地图的列数，K表示目标敌人数量  
>  N，M<=100  
>  之后为一个NxM大小的字符数组  
>  **输出描述**  
>  敌人数小于K的区域数量
>
> **示例1：**
>
> **输入**  
>  3 5 2  
>  ..#EE  
>  E.#E.
>
> ###..  
>  **输出**  
>  1  
>  **说明**  
>  地图被墙壁分为两个区域，左边区域有1个敌人，右边区域有3个敌人，符合条件的区域数量是1

#  输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# 思路

> 1：刷题库刷多了应该有肌肉记忆了吧，明显一个DFS搜索类的问题。
>
>
> 2：若某个位置未被搜索过且不是'#'，那么可以开始进行DFS遍历，单个源头的搜索区域，该区域的'E'的（敌军）数量+1。遍历完成后，对总敌军数量<k，则result
> + 1。
>
> 3：最好先别看我的题解，直接手撸一把看看，对于刷题多一点的同学来说，应该不是难题，模板都应该记住了。

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    m = params[1]
    k = params[2] 
    matrix = []
    for i in range(n):
        matrix.append(input())
    visited = [[0 for x in range(m)] for y in range(n)] 
    directions = ((-1, 0), (1, 0), (0, -1), (0, 1)) 
    
    def dfs(i, j, matrix, n,  m,count):
        visited[i][j] = 1
    
        # 敌军数量+1
        if (matrix[i][j] == 'E'):
            count += 1
        
        #已经不适用栈结构来实现了
        if (i+1<n and visited[i+1][j] == 0 and matrix[i+1][j] != '#'):
            dfs(i+1, j,matrix,n,m,count)
        if (i-1>=0 and visited[i-1][j] == 0 and matrix[i-1][j] != '#'):
            dfs(i-1, j,matrix,n,m,count)
        if (j+1<m and visited[i][j+1] == 0 and matrix[i][j+1] != '#'):
            dfs(i, j+1,matrix,n,m,count)
        if (j-1>=0 and visited[1][j-1] == 0 and matrix[i][j-1] != '#'):
            dfs(i, j-1,matrix,n,m,count)
    
    
    result = 0
     
    for i in range(n):
        for j in range(m):
            if visited[i][j] == 1 or matrix[i][j] == '#':
                continue
            count = 0
            dfs(i, j, matrix,n,m,count)
            if (count < k):
                result += 1
            
    print(result)

##

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

