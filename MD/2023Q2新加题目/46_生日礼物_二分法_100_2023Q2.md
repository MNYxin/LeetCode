## 题目

> 小牛的孩子生日快要到了，他打算给孩子买蛋糕和小礼物， **蛋糕和小礼物各买一个**
> ，他的预算不超过x元。蛋糕cake和小礼物gift都有多种价位的可供选择。  
>  请返回小牛共有多少种购买方案  
>  **输入描述**  
>  第一行表示cake的单价，以逗号分隔  
>  第二行表示gift的单价，以逗号分隔  
>  第三行表示x预算  
>  **输出描述**  
>  输出数字表示购买方案的总数  
>  **备注**  
>  1 < cake.length ≤ 10^5
>
> 1 < gift.length <10^5。
>
> 1 < cake[i]，gift[i] < 10^5。
>
> 1<X<2*10^5  
>  **示例1：  
>  输入**
>
> 10,20,5  
>  5,5,2  
>  15  
>  输出  
>  6  
>  解释: 小牛有6种购买方案，所选蛋糕与所选礼物在数组中对应的下标分别是:  
>  说明  
>  第1种方案: cake [0] + gift [0] = 10 + 5 = 15
>
> 第2种方案: cake [0] + gift [1]= 10 + 5 = 15;
>
> 第3种方案: cake [0] + gift [2] = 10 + 2 = 12
>
> 第4种方案: cake [2] + gift [0] = 5 + 5 = 10;
>
> 第5种方案: cake [2] + gift [1]= 5 + 5 = 10;  
>  第6种方案: cake [2] + gift [2] = 5 + 2 = 7.

# 思路

> 1：这个题挺有意思的，不算是传统的求组合问题，只要关注到题目的核心条件即可：【 **蛋糕和小礼物各买一个** 】
>
> 2：那么我们只要将cake数组排好序( **两个数组可互换** )，然后找到gift数组最大的一个满足条件的值x，再到cake数组中找到小于total-
> x的情况即可。
>
> 3：从样例中我们可以看出， **价格相同的礼物或者蛋糕，也可以组成不同的组合** ，这算是一个隐含条件，需要注意。

#

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    cakes = []
    input_str1 = input()
    for x in input_str1.split(","):
        cakes.append(int(x))
    
    gifts = []
    input_str2= input()
    for x in input_str2.split(","):
        gifts.append(int(x))
    total = int(input())
    cakes = sorted(cakes, key=lambda x: x, reverse=False)
    
    result = 0
    i=0
    while(True):
        if(i>=len(gifts)):
            print(result)
            break;
        else:
            if (total > gifts[i]) :
                left = 0
                right = len(cakes) - 1
                index = 0
                flag = True
                while (True) :
                    if(left > right):
                        break;
                    else:
                        mid = (left + right) >> 1
                        if (cakes[mid] > total - gifts[i]) :
                            right = mid - 1
                        elif (cakes[mid] < total - gifts[i]) :
                            left = mid + 1
                        else :
                            if mid == len(cakes) - 1 :
                                index = mid
                                flag = False
                                break;
                            elif cakes[mid] != cakes[mid + 1]:
                                index = mid
                                flag = False
                                break;
                            else :
                                left = mid + 1
                if flag:
                    index = -left - 1
                else:
                    index = index
    
                if (index >= 0) :
                    result += index + 1
                else :
                    result += -index - 1
            else:
                i+=1
                continue
        i+=1

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

