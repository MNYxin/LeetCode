**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 给你一个由0’(空地)、1’(银矿) 、"2(金矿)组成的的地图，矿堆只能由上下左右相邻的金矿或银矿连接形成。超出地图范围可以认为是空地。  
>  假设银矿价值1 ，金矿价值2 ，请你找出地图中最大价值的矿堆并输出该矿堆的价值  
>  **输入描述**  
>  地图元素信息如:  
>  22220  
>  00000  
>  00000  
>  11111  
>  地图范围最大 300*300  
>  0<= 地图元素 <=2  
>  **输出描述:**  
>  矿堆的最大价值
>
> **示例1  
>  输入:**  
>  22220
>
> 00000
>
> 00000
>
> 01111  
>  输出:  
>  8
>
>  
> **示例2  
>  输入:**  
>  22220
>
> 00020
>
> 00010  
>  01111
>
> 输出:
>
> 15
>
>  
> **示例3  
>  输入:**  
>  20000  
>  00920  
>  00000  
>  00111  
>  输出:
>
> 3

# 思路

> 1：经典的图一类的问题，比较麻烦的就是输入不确定行数和列数，要自己判定和解析。
>
> 2：和以前的岛屿最大面积很像，只不过面积换算成了最大价值，简单的改动。

# ![](https://img-blog.csdnimg.cn/477de3c0b783423d9cddfb084d622e70.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    matrix = []
    # 处理输入
    # 不确定多少行输入
    while True:
        line = sys.stdin.readline().strip()
        if not line:
            break
        matrix.append([ord(x)-48 for x in line])
    
    
    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    
    def dfs(max_value, x ,y,matrix):
        if(matrix[x][y] == 0):
            return max_value
        
    
        max_value += matrix[x][y]
        matrix[x][y] = 0 
        #四个方向
        for i in range(4):
            new_x = x + directions[i][0]
            new_y = y + directions[i][1]
    
            if( new_x>=0 and  new_x<len(matrix) and  new_y>=0 and  new_y<len(matrix[0])):
                if(matrix[new_x][new_y] > 0):
                    max_value = dfs(max_value,new_x, new_y, matrix)
        return max_value
    
    max_value  = 0 
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            max_value = max(max_value, dfs(0,i,j,matrix))
        
    print(max_value)

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

