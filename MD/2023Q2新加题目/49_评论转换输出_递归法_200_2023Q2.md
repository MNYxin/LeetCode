> 在一个博客网站上，每篇博客都有评论。每一条评论都是一个非空英文字母字符串。  
>  **评论具有树状结构** ，除了根评论外，每个评论都有一个父评论。  
>  当评论保存时，使用以下格式：
>
> 首先是评论的内容；
>
> 然后是回复当前评论的数量。
>
> 最后是当前评论的所有子评论。（子评论使用相同的格式嵌套存储）
>
> 例如：
>
> 第一条评论是"hello,2,ok,0,bye,0"，
>
> 第二条评论是"test,0"，
>
> 第三条评论是"one,1,two,1,a,0"
>
> 所有评论被保存成"hello,2,ok,0,bye,0,test,0,one,1,two,1,a,0"。  
>  对于上述格式的评论，请以另外一种格式打印:  
>  首先打印评论嵌套的最大深度。  
>  然后是打印n行，第i(1<=i<=n)行对应于嵌套级别为的评论
> (根评论的嵌套级别为1)对于第i行，嵌套级别为的评论按照它们出现的顺序打印，用空格分隔开。  
>
>
> **输入描述:**  
>  行评论。由英文字母、数字和英文逗号组成保证每个评论都是由英文字符组成的非空字符串每个评论的数量都是整数
> (至少由一个数字组成)整个字符串的长度不超过106.给定的评论结构保证是合法的。  
>  **输出描述**  
>  按照给定的格式打印评论。对于每一级嵌套，评论应该按照输入中的顺序打印
>
> **示例1**  
>  输入:  
>  hello,2,ok,0,bye,0,test,0,one,1,two,1,a,0  
>  输出:  
>  3  
>  hello test one  
>  ok bye two
>
> a  
>  说明:  
>  如题目描述中图所示，最大嵌套级别为3。嵌套级别为1的评论是"hello test one”，嵌套级别为2的评论是"ok
> bvetwo"，嵌套级别为3的评论为"a"。
>
> ![](https://img-
> blog.csdnimg.cn/img_convert/fb76c82b9e4e809d766aa6abbcd8e775.png)
>
> **示例2**  
>  输入:  
>  A,5,A,0,a,0,A,0,a,0,A,0  
>  输出:  
>  2  
>  A  
>  A a A a A  
>  说明:  
>  如下图所示，最大嵌套级别为2，嵌套级别为1的评论是"A"，嵌套级别为2的评论是"A a A a A"  
>
>
> ![](https://img-
> blog.csdnimg.cn/img_convert/b7e9df56061a2f170c55194e566b9a29.png)示例3  
>  输入:  
>  A,3,B,2,C,0,D,1,E,0,F,1,G,0,H,1,I,1,J,0,K,1,L,0,M,2,N,0,0,1,P,0  
>  输出:  
>  4  
>  A K M  
>  B F H L N O  
>  C D G I P  
>  E J  
>  说明:  
>  如下图所示。  
>
>
> ![](https://img-
> blog.csdnimg.cn/img_convert/65adaafba9fe5a5537c266ebf0e9d97b.png)

# 思路

> 1：题目中有一个核心的描述：【评论具有树状结构】。那么我们就将所有的评论转换成一棵树。
>
> 2：评论的最大深度也就变成了求树的高度，级别为i的评论就变成了树的第i层所有元素，也就是层序遍历树了。
>
> 3：核心的考点就是将输入的信息转换成一棵树，用的是递归的方法。

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    
    pos = 0
    level = 0
    input_comments = input().split(",")
    size = len(input_comments)
    # 评论的树结构
    comment_tree = []
    comment_tree.append("")
    
    def dfs(input_comments, comment_tree, k):
        global pos
        if (k >= len(comment_tree)):
            comment_tree.append("")
    
        comment_tree[k] =  comment_tree[k] + ' ' + input_comments[pos]
        pos +=1
        next_level_count = int(input_comments[pos])
        pos+=1
        level_temp = k
    
        for i in range(next_level_count):
            result = dfs(input_comments, comment_tree, k + 1)
            level_temp = max(result[0], level_temp)
            pos = result[1]
        
        return [level_temp, pos]
    
    
    while (True):
        if(pos >= size):
            print(level + 1)
            for single_comment in comment_tree:
                print(single_comment[1:])
            break
        else:
            comment_tree[0] = comment_tree[0] + ' ' + input_comments[pos]
            pos += 1
            next_level_count = int(input_comments[pos]) 
            pos += 1
    
            for i in range(next_level_count):
                result = dfs(input_comments, comment_tree, 1)
                level = max(result[0], level) 
                pos = result[1]
                    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

