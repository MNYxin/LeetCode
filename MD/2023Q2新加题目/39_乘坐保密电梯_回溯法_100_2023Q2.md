> 有一座保密大楼，你从0楼到达指定楼层m，必须这样的规则乘坐电梯:
> **给定一个数字序列，每次根据序列中的数字n上升n层或者下降n层，前后两次操作的方向必须相反，规定首次的方向向上，自行组织序列的顺序按规定操作到达指定楼层**
> 。求解到达楼层的序列组合， **如果不能到达楼层，给出小于该楼层的最近序列组合** 。
>
> **说明:**  
>  操作电梯时不限定楼层范围  
>  必须对序列中的每个项进行操作，不能只使用一部分。  
>  **输入描述:**  
>  第一行: 期望的楼层，取值范围[1,50]; 序列总个数，取值范围[1,23]
>
> 第二行: 序列，每个值取值范围[1,50]  
>  **输出描述**  
>  能够达到楼层或者小于该楼层最近的序列  
>  **补充说明:**  
>  操作电梯时不限定楼层范围  
>  必须对序列中的每个项进行操作，不能只使用一部分  
>  示例1  
>  输入:  
>  5 3  
>  1 2 6  
>  输出:  
>  6 2 1  
>  说明:  
>  1 2 6
>
> 6 2 1均为可行解，按先处理大值的原则结果为6 2 1

# 思路

> 1：题目中给出的规则特别绕，但是核心就是：电梯要按照固定规则上下移动，想从0层到target层是否有可行解。
>
> 2：因为前后两次方向必须相反，那么就将给定的序列分成了两个数组，一组up向上，一组down向下，那么up_sum - down_sum <=
> 期望的楼层。up_sum + down_sum = total_sum。
>
> 所以最后变成了 total_sum- 2* down_sum <= 期望的楼层(或者：2*up_sum - total_sum
> <=期望的楼层)，这个公式里的变量就只有down_sum(up_sum) 了。
>
> 3：求解 down_sum 或者up_sum，就是从序列中取出一半的数字，来满足这个条件，很明显的一个递归问题。最后注意要取出最大解即可。

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    
    params = [int(x) for x in input().split(" ")]
    target = params[0]
    count = params[1]
    nums =  [int(x) for x in input().split(" ")]
    #求和
    sum_val = 0
    min_distance = float("inf")
    floor_list = []
    for i in range(count):
        floor_list.append(nums[i])
        sum_val += nums[i]
    
    
    def solve(target, sum_val, floor_list,min_distance, n, new_list, index,downs, flag):
        if(flag):
            return
        if(n != 0):
            for i in range(index, len(floor_list)):
                new_list.append(floor_list[i])
                solve(target,sum_val, floor_list,min_distance, n-1, new_list, i+1,downs,flag)
                new_list.pop(len(new_list) - 1)  
        else :
            cnt1 = 0
            for i in range(len(new_list)):
                cnt1 += new_list[i]
            
            distance = abs(sum_val - 2 * cnt1 - target)
            if(distance == 0):
                downs = new_list
                flag = true
            elif(min_distance > distance):
                min_distance = distance
                downs = new_list
    
    #找出下降层数
    downs = []
    flag = False
    solve(target, sum_val, floor_list,min_distance, count/2, [], 0,downs,flag)
    
    for  down in downs :
        if(floor_list.index(down) != -1):
            floor_list.pop(floor_list.index(down))
        
    
    floor_list.sort(reverse=True)
    downs.sort(reverse=True)
    
    result_str = ""
    #上升和下降交替存在
    for  i in range(len(floor_list)):
        result_str += str(floor_list[i]) + " "
        if(i < len(downs) ):
            result_str += str(downs[i]) + " "
        
    
    print(result_str)

##

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

