**所有题目均有五种语言实现。 ** ** ** ** ** **
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")************** 、 ** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

>
> 现有两门选修课，每门选修课都有一部分学生选修，每个学生都有选修课的成绩，需要你找出同时选修了两门选修课的学生，先按照班级进行划分，班级编号小的先输出，每个班级按照两门选修课成绩和的降序排序，成绩相同时按照学生的学号升序排序。  
>  **输入描述**  
>  第一行为第一门选修课学生的成绩
>
>
> 第二行为第二门选修课学生的成绩，每行数据中学生之间以英文分号分隔，每个学生的学号和成绩以英文逗号分隔，学生学号的格式为8位数字(2位院系编号+入学年份后2位+院系内部1位专业编号+所在班级3位学号)，学生成绩的取值范围
> **为[0,100]之间的整数，两门选修课选修学生数的取值范围为[1-2000]之间的整数。  
>  输出描述**  
>
> 同时选修了两门选修课的学生的学号，如果没有同时选修两门选修课的学生输出NULL，否则，先按照班级划分，班级编号小的先输出，每个班级先输出班级编号(学号前五位)，然后另起一行输出这个班级同时选修两门选修课的学生学号，学号按照要求排序(按照两门选修课成绩和的降序，成绩和相同时按照学号升序)，学生之间以英文分号分隔。
>
> **示例1  
>  输入:**  
>  01202021,75;01201033,95;01202008,80;01203006,90;01203088,100
>
> 01202008,70;01203088,85;01202111,80;01202021,75;01201100,88  
>  输出:  
>  01202  
>  01202008;01202021  
>  01203  
>  01203088  
>  说明:  
>  同时选修了两门选修课的学生01202021、01202008、01203088，这三个学生两门选修课的成绩和分别为150、150、185,
> 01202021、01202008属于01202班的学生，按照成绩和降序，成绩相同时按学号升序输出的结果为01202008:01202021,01203088属于01203班的学生，按照成绩和降序，成绩相同时按学号升序输出的结果为01203088，01202的班级编号小于01203的班级编号，需要先输出。
>
> **示例2  
>  输入:**  
>  01201022,75;01202033,95;01202018,80;01203006,90;01202066,100
>
> 01202008,70;01203102,85;01202111,80;01201021,75;01201100,88  
>  输出:  
>  NULL  
>  说明:  
>  没有同时选修了两门选修课的学生，输出NULL。

# 思路

> 1：比较简单的一个字符串处理的题目，只要维护好两个map保存课程和学生之间的关系即可。

# ![](https://img-blog.csdnimg.cn/1b28bd1645934fd5bd84eaefbfa0298e.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    class Student:
        def __init__(self, id, score):
            self.id = id
            self.score = score
        
        def __lt__(self, other):
            return self.score != other.score and self.score > other.score or self.id < other.id
    
    grade_one_str = input()
    grade_two_str = input()
    
    student_id_map = {}
    for token in grade_two_str.split(';'):
        ids = token.split(',')
        student_id_map[ids[0]] = int(ids[1])
    
    student_map = defaultdict(set)
    for token in grade_one_str.split(';'):
        ids = token.split(',')
        student_id = ids[0]
        if student_id in student_id_map:
            totalScore = int(ids[1]) + student_id_map[student_id]
            temp = student_id[:5]
            student_map[temp].add(Student(student_id, totalScore))
    
    if not student_map:
        print("NULL")
    else:
        for key, value in sorted(student_map.items()):
            print(key)
            res = ""
            for student in sorted(value):
                res += student.id + ";"
            print(res[:-1])

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

