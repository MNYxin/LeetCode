**目录**

题目

思路

Code

* * *

## 题目

> 某通信网络中有N个网络结点，用1到N进行标识。网络通过一个有向无环图表示，其中图的边的值表示结点之间的消息传递时延。
>
> 现给定相连节点之间的时延列表times[i]={u，v，w}，其中u表示源结点，v表示目的结点，w表示u和v之间的消息传递时延。
>
> 请计算给定源结点到目的结点的最小传输时延，如果目的结点不可达，返回-1。
>
> 注：N的取值范围为[1，100];
>
> 时延列表times的长度不超过6000，且 1 <= u,v <= N，0 <= w <= 100;
>
> **输入描述：**
>
> 输入的第一行为两个正整数，分别表示网络结点的个数N，以及时延列表的长度M，用空格分隔；
>
> 接下来的M行为两个结点间的时延列表[u v w];
>
> 输入的最后一行为两个正整数，分别表示源结点和目的结点。
>
> ![](https://img-blog.csdnimg.cn/91ba78b152764a49a91f4f2ce2676fa6.png)
>
> **输出描述：**
>
> 起点到终点得最小时延，不可达则返回-1
>
> **示例1：**
>
> **输入：**
>
> 3 3
>
> 1 2 11
>
> 2 3 13
>
> 1 3 50
>
> 1 3
>
> 输出：
>
> 24

# 思路

> 1：leetcode 原题：[力扣](https://leetcode.cn/problems/network-delay-time/ "力扣")
>
>
> 2：典型的有向图的单源最短路径，可以使用Dijkstra算法计算起点到终点的最短时延。使用优先队列实现算法中每次取最短路径。提供两种连接关系的表示方法，包括邻接表和邻接矩阵。

# ![](https://img-blog.csdnimg.cn/42eca8c5691144f2a9511821b795bf3e.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    n, m = map(int, input().split())
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
    start, end = map(int, input().split())
    
    def comp(a,b):
        if a[1] == b[1]:
            return 0
        elif a[1] > b[1]:
            return 1
        else:
            return -1
    
    queue = []#new PriorityQueue<>((a, b) -> a[1] - b[1])
    dist = [float('inf') for i in range(n + 1)]
    dist[start] = 0
    queue.append([start, 0])
    while (len(queue)>0) :
        poll = queue[0]
        queue.pop(0)
        node = poll[0]
        for i in range(len(matrix)):
            if (matrix[i][0] == node) :
                next = matrix[i][1]
                if (dist[next] > dist[node] + matrix[i][2]) :
                    dist[next] = dist[node] + matrix[i][2]
                    queue.append([next, dist[next]])
        queue.sort(key=functools.cmp_to_key(comp), reverse=False)
                
           
    
    if (dist[end] == float('inf') ) :
        print(-1)
    else:
        print(dist[end])

##

> **【华为od机试真题Python+JS+Java合集】【超值优惠】：
> **[Py/JS/Java合集](https://blog.csdn.net/misayaaaaa/category_12258991.html
> "Py/JS/Java合集")****
>
> **【华为od机试真题Python】：
> **[Python真题题库](https://blog.csdn.net/misayaaaaa/category_12111005.html
> "Python真题题库")****
>
> **【华为od机试真题JavaScript】：
> **[JavaScript真题题库](https://blog.csdn.net/misayaaaaa/category_12199270.html
> "JavaScript真题题库")****
>
> **【华为od机试真题Java】：
> **[Java真题题库](https://blog.csdn.net/misayaaaaa/category_12111006.html
> "Java真题题库")****
>
> **【华为od机试真题C++】：
> **[C++真题题库](https://blog.csdn.net/misayaaaaa/category_12036814.html
> "C++真题题库")****
>
> **【华为od机试真题C语言】：
> **[C语言真题题库](https://blog.csdn.net/misayaaaaa/category_12217917.html
> "C语言真题题库")****
>
> **【华为od面试手撕代码题库】：
> **[面试手撕代码题库](https://renjie.blog.csdn.net/article/details/130419388
> "面试手撕代码题库")****
>
> **【华为od机试面试交流群：830285880】**

