**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

>
> 某公司员工食堂以盒饭方式供餐。为将员工取餐排队时间降低为0，食堂的供餐速度必须要足够快。现在需要根据以往员工取餐的统计信息，计算出一个刚好能达成排队时间为0的最低供餐速度。即，食堂在每个单位时间内必须至少做出多少份盒饭才能满足要求。  
>  **输入描述:**  
>  第1行为一个正整数N，表示食堂开餐时长。1 <= N <= 1000。
>
> 第2行为一个正整数M，表示开餐前食堂已经准备好的盒饭份数。pi <= M <= 1000.
>
> 第3行为N个正整数，用空格分隔，依次表示开餐时间内按时间顺序每个单位时间进入食堂取餐的人数Pi。1 <=i<= N，0<= Pi<=100.  
>  **输出描述:**  
>  个整数，能满足题目要求的最低供餐速度(每个单位时间需要做出多少份盒饭)
>
> **补充说明:**  
>  每人只取一份盒饭。  
>
> 需要满足排队时间为0，必须保证取餐员工到达食堂时，食堂库存盒饭数量不少于本次来取餐的人数。第一个单位时间来取餐的员工只能取开餐前食堂准备好的盒饭。每个单位时间里制作的盒饭只能供应给后续单位时间来的取餐的员工食堂在每个单位时间里制作的盒饭数量是相同的。  
>  **示例1  
>  输入:**  
>  3  
>  14  
>  10 4 5  
>  **输出:**  
>  3
>
> **说明:**  
>  本样例中，总共有3批员工就餐，每批人数分别为10、4、5.  
>  开餐前食堂库存14份。  
>
> 食堂每个单位时间至少要做出3份餐饭才能达成排队时间为0的目标。具体情况如下:第一个单位时间来的10位员工直接从库存取餐。取餐后库存剩余4份盒饭，加上第一个单位时间做出的3份，库存有7份。第一个单位时间来的4员工从库存的7份中取4份。取餐后库存剩余3份盒饭，加上第二个单位时间做出的3份，库存有6份第二个单位时间来的员工从库存的6份中取5份，库存足够。  
>
> 如果食堂在单位时间只能做出2份餐饭，则情况如下:第一个单位时间来的10位员工直接从库存取餐。取餐后库存剩余4份盒饭，加上第一个单位时间做出的2份，库存有6份.第二个单位时间来的4员工从库存的6份中取4份。取餐后库存剩余2份盒饭，加上第二个单位时间做出的2份，库存有4份第三个单位时间来的员工需要取5份，但库存只有4份，库存不够。

# 思路

> 1: 本来是个简单题，非要整这么长的说明背景文字，生怕别人不能理解题意。。。。
>
> 2: 给定的数据量不大，可以使用二分法来解决。
>
> 假定 最小出餐速度 left=0 最大出餐速度right = 总人数-已准备好的盒饭
>
> 逐渐二分，直到找到最小速度。

# ![](https://img-blog.csdnimg.cn/c1455aae338d4a66a40d5913d685c966.jpeg)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    N = int(input())
    M = int(input())
    P = [int(x) for x in input().split(" ")]
    
    amount = sum(P)
    
    def check(speed, total, N, P):
        for i in range(N):
            total -= P[i]
            if(total < 0):
                return False
            
            total += speed
        return True
    
    
    left = 0;
    right = amount - M;
    while (left < right):
        #二分法
        mid = (left + right) / 2
        if(check(mid,M,N,P)):
            right = mid
        else:
            left = mid + 1
    
    print(int(left))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

