**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 张兵和王武是五子棋迷，工作之余经常切磋棋艺。这不，这会儿又下起来了。走了一会儿，轮张兵了，对着一条线思考起来了，这条线上的棋子分布如下  
>  用数组表示: -1 0 1 1 1 0 1 01 1  
>  棋子分布说明:  
>  1.-1代表白子，0代表空位，1 代表黑子  
>  2.数组长度L,满足 1 < L < 40,且L为奇数  
>  你得帮他写一个程序，算出最有利的出子位置。最有利定义  
>  1.找到一个空位(0)，用棋子(1/-1)填充该位置，可以使得当前子的最大连续长度变大  
>  2.如果存在多个位置，返回最靠近中间的较小的那个坐标;  
>  3.如果不存在可行位置，直接返回-1:  
>  4.连续长度不能超过5个(五字棋约束)  
>  **输入描述:**  
>  第一行: 当前出子颜色  
>  第二行: 当前的棋局状态  
>  **输出描述**  
>  1个整数，表示出子位置的数组下标
>
> **示例1  
>  输入:**
>
> 1  
>  -1 0 1 1 1 0 1 0 1 -1 1  
>  输出:
>
> 5  
>  说明:  
>  当前为黑子 (1)，放置在下标为5的位置，黑子的最大连续长度，可以由3到5  
>  **示例2  
>  输入:**
>
> -1  
>  -1 0 1 1 1 0 1 0 1 -1 1  
>  输出:
>
> 1
>
> 说明:  
>  当前为白子，唯一可以放置的位置下标为1，白子的最大长度，由1变为2  
>  **示例3  
>  输入:**  
>  0 0 0 0 1 0 0 0 0 1 0  
>  输出:  
>  说明:  
>  可行的位置很多，5最接近中间的位置坐标

# 思路

> 1：[leetcode 424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-
> character-replacement/ "leetcode 424. 替换后的最长重复字符")
> 改过来的，leetcode要求的是替换后最长的长度，而本题要求的是最长情况下替换的最佳位置。不过同样是使用双指针的滑动窗口法。
>
> [通过此题了解一下什么是滑动窗口 Java 题解 - 替换后的最长重复字符 -
> 力扣（LeetCode）](https://leetcode.cn/problems/longest-repeating-character-
> replacement/solution/tong-guo-ci-ti-liao-jie-yi-xia-shi-yao-shi-hua-don/
> "通过此题了解一下什么是滑动窗口 Java 题解 - 替换后的最长重复字符 - 力扣（LeetCode）")

# ![](https://img-blog.csdnimg.cn/5fc1783103a64155ac3be8326e840522.jpeg)

# Code

    
    
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy 
    from collections import defaultdict
    
    target = int(input())
    nums = [int(x) for x in input().split(" ")]
    maxVal = -float('inf')
    midDist = 0
    result = -1
    
    def countLeftMatch(nums, target, index, maxVal):
        left = index - 1
        leftCount = 0
        while left >= 0 and nums[left] == target and leftCount < maxVal - 1:
            leftCount += 1
            left -= 1
        return leftCount
    
    def countRightMatch(nums, target, index, maxVal):
        right = index + 1
        rightCount = 0
        while right < len(nums) and nums[right] == target and rightCount < maxVal - 1:
            rightCount += 1
            right += 1
        return rightCount
    
    for i in range(len(nums)):
        if nums[i] != 0:
            continue
        leftCount = countLeftMatch(nums, target, i, maxVal)
        if leftCount > 4:
            continue
        rightCount = countRightMatch(nums, target, i, maxVal)
        totalCount = leftCount + rightCount
        distToMid = abs(i - len(nums) // 2)
        if totalCount > maxVal or (totalCount == maxVal and distToMid < midDist):
            maxVal = totalCount
            result = i
            midDist = distToMid
    print(result)
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

