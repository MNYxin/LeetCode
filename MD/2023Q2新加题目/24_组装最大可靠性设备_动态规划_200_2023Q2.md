# 题目

>
> 一个设备由N种类型元器件组成(每种类型元器件只需要一个，类型type编号从0~N-1),每个元器件均有可靠性属性reliability，可靠性越高的器件其价格price越贵。而设备的可靠性由组成设备的所有器件中可靠性最低的器件决定。给定预算S，购买N种元器件(
> **每种类型元器件都需要购买一个** )，在不超过预算的情况下，请给出能够组成的设备的最大可靠性.  
>  **输入描述**  
>  S N // S总的预算，N元器件的种类  
>  total // 元器件的总数，每种型号的元器件可以有多种:  
>  此后有total行具体器件的数据  
>  type reliability price / type 整数类型，代表元器件的类型编号从0 ~ N-1; reliabily
> 整数类型，代表元器件的可靠性: price 整数类型，代表元器件的价格  
>  **输出描述**  
>  符合预算的设备的最大可靠性，如果预算无法买产N种器件，则返回 -1
>
> **备注**  
>  0 <= S,price <= 10000000  
>  0 <= N <= 100  
>  0 <= type <= N-1  
>  0 <= total <= 100000  
>  0 < reliability <= 100000
>
>  
> **示例1：**
>
> **输入**  
>  500 3  
>  6  
>  0 80 100  
>  0 90 200  
>  1 50 50  
>  1 70 210  
>  2 50 100  
>  2 60 150  
>  输出  
>  60  
>  说明
>
> 预算500，设备需要3种元件组成，方案类型0的第一个(可靠性80),  
>  类型1的第二个(可靠性70).  
>  类型2的第二个(可靠性60).
>
> 可以使设备的可靠性最大 60
>
> **示例2：**
>
> **输入**
>
> 100 1
>
> 1  
>  0 90 200  
>  输出  
>  -1  
>  说明  
>  组成设备需要1个元件，但是元件价格大于预算，因此无法组成设备，返回-1

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import queue
    import sys
    import bisect
    from queue import Queue
    
    result = -1
    params = [int(x) for x in input().split(" ")]
    s = params[0]
    n = params[1]
    total = int(input())  
    items = []
    for i in range(total):
        items.append([int(x) for x in input().split(" ")]) 
    
    for i in range(total):
        items[i][0] += 1
    
    def cal(x, devices):
        temp = [float("inf") for x in range(n+1)]
    
        j=0
        while(True):
            if(j>=len(devices)):
                all = 0
                for i in range(1, n+1):
                    all += temp[i]
                return all <= s
            else:
                if (devices[j][1] >= x) :
                    temp[devices[j][0]] = min(temp[devices[j][0]], devices[j][2])
                
            
            j+=1
     
    left = 0
    right = total*1000
    while (True) :
        if(left > right):
            print(result)
            break
        else:
            if (cal(left + int((right - left) / 2), items)) :
                result = left +  int((right - left) / 2)
                left +=  int((right - left) / 2) + 1
            else:
                right = left +  int((right - left) / 2) - 1
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

