**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> Jungle 生活在美丽的蓝鲸城，大马路都是方方正正，但是每天马路的封闭情况都不一样。地图由以下元素组成:  
>  1)”.” - 空地，可以达到;
>
> 2)”*” - 路障，不可达到;
>
> 3)"S” - Jungle的家;
>
> 4)”T” - 公司.  
>  其中我们会限制Jungle拐弯的次数，同时Jungle可以清除给定个数的路障，现在你的任务是计算Jungle是否可以从家里出发到达公司。
>
> **输入描述**
>
> 输入的第一行为两个整数tc(o<tc<100)t代表可以拐弯的次数，c代表可以清除的路陪个数
>
> 输入的第二行为两个整数n,m(1≤n,m≤100),代表地图的大小。
>
> 接下来是n行包含m个字符的地图。n和m可能不一样大。  
>  我们保证地图里有S和T。
>
> **输出描述**  
>  输出是否可以从家里出发到达公司，是则输出YES，不能则输出NO。
>
> **示例1：**
>
> 输入  
>  2 0
>
> 5 5
>
> ..S..  
>  ****.
>
> T....  
>  ****.
>
> .....  
>  输出
>
> YES
>
> 示例2：
>
> 输入
>
> 1 2
>
> 5 5
>
> .*S*.  
>  *****  
>  ..*..
>
> *****
>
> T....  
>  输出
>
> NO
>
> 说明 该用例中，至少需要拐弯1次，清除3个路障，所以无法到达

# 思路

> 1：和 [机器人](https://renjie.blog.csdn.net/article/details/128319475
> "机器人")这题很像，都是上下左右遍历走矩阵的，思路也差不多。
>
> 2：唯一加的条件就是转向次数和破壁次数，在DFS遍历中加上这两个条件即可。

# 考点

> 1：DFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
        
     
    #处理输入
    directions = [[0, 1,1], [0, -1,2], [1, 0,3], [-1, 0,4]]
     
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    t = params[0]
    c = params[1]
    params1 = [int(x) for x in input().split(" ")]
    n = params1[0]
    m = params1[1]
    matrix = []
    for i in range(n):
        matrix.append([x for x in input()])
    
    def dfs(visited, x, y, ut, uc, last_direct):
        global t,c,n,m,directions
        # 找到目的地
        if ('T' == matrix[x][y]):
            return True
        
        #表示当前点已走过
        visited[x][y] = True
        #print(visited)
        # 有四个方向选择走下一步
        for direction in directions:
    
            direct = direction[2]
            new_x = x + direction[0]
            new_y = y + direction[1]
            # 转向+破壁标记
            turn_flag = False
            break_flag = False
        
            # 越界 + 是否当前点已访问判断
            if (new_x >= 0 and new_x < n and new_y >= 0 and new_y < m and not visited[new_x][new_y]):
    
                #转向+破壁判断
                if (last_direct != 0 and last_direct != direct):
                    # 转向次数已用尽
                    if (ut + 1 > t):
                        continue
                    turn_flag = True
                
        
                if ('*' == matrix[new_x][new_y]):
                    # 破壁次数已用尽
                    if (uc + 1 > c):
                        continue
                    break_flag = True
                
                # 可到达目的地T, 返回True
                if (dfs(visited, new_x, new_y, ut+1 if turn_flag else ut , uc+1 if break_flag else uc, direct)):
                    return True
    
        return False
    
     
    
    flag = True
    for i in range(n):
        for j in range(m):
            visited = [[False for y in range(m)] for x in range(n)]
            if ('S' == matrix[i][j]):
                if (dfs(visited, i, j, 0, 0, 0)):
                    print("YES")
                    flag = False
                    break
                else:
                    print("NO")
                    flag = False
                    break
        if (not flag):
            break
    
    if (flag):
        print("NO")
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

