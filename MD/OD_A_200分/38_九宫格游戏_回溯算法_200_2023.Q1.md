**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> **题目描述:**
>
> 九宫格又是一款广为流传的游戏，起源于河图洛书。  
>  游戏规则是:1到9九个数字放在3x3的格子中，要求每行、每列以及两个对角线上的三数之和都等于15.  
>  在金麻名著《射雕英雄传》中黃蓉曾给九宫格的一种解法，口诀:戴九恩一，左三右七，二四有肩，八六为足，五居中央。解法如图所示。
>
> 4| 9| 2  
> ---|---|---  
> 3| 5| 7  
> 8| 1| 6  
>  
> 现在有一种新的玩法，给九个不同的数字，将这九个数字放在3x3的格子中，要求每行、每列以及两个对角线上的三数之积相等(三阶积幻方)。其中一个三阶幻方如图:
>
> 2| 9| 12  
> ---|---|---  
> 36| 6| 1  
> 3| 4| 18  
>  
>  
>  解释:每行、每列以及两个对角线上的三数之积相等，都为216。请设计一种算法，将给定的九个数宇重新排列后，使其满足三阶积幻方的要求。  
>  排列后的九个数宇中:第1-3个数字为方格的第一行，第4-6个数宇为方格的第二行，第7-9个数字为方格的第三行。
>
> **输入描述:**  
>  九个不同的数宇，每个数字之间用空格分开。  
>  0<数字<10^7。
>
> 0<排列后满足要求的每行、每列以及两个对角线上的三数之积<2^31-1。
>
> **输出描述:**  
>  九个数字所有满足要求的排列，每个数字之间用空格分开。每行输出一个满足要求的排列。  
>
> 要求输出的排列升序排序，即:对干排列A(A1.A2.A3A9)和排列B(B1.B2.B3…B9)，从排列的第1个数字开始，遇到Ai<Bi，则排列A<排列B
> (1<=i<=9)。  
>  说明:用例保证至少有一种排列组合满足条件。
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**  
>  **输入**
>
> 75 36 10 4 30 225 90 25 12
>
> **输出**
>
> 10 36 75 225 30 4 12 25 90
>
> 10 225 12 36 30 25 75 4 90
>
> 12 25 90 225 30 4 10 36 75
>
> 12 225 10 25 30 36 90 4 75
>
> 75 4 90 36 30 25 10 225 12
>
> 75 36 10 4 30 225 90 25 12
>
> 90 4 75 25 30 36 12 225 10
>
> 90 25 12 4 30 225 75 36 10
>
> **注意30永远在中间。**
>
> **示例2：**
>
> **输入：**
>
> 1 2 3 5 10 20 25 50 100  
>  **输出：**
>
> 2 25 20 100 10 1 5 4 50  
>  2 100 5 25 10 4 20 1 50  
>  5 4 50 100 10 1 2 25 20  
>  5 100 2 4 10 25 50 1 20  
>  20 1 50 25 10 4 2 100 5  
>  20 25 2 1 10 100 50 4 5  
>  50 1 20 4 10 25 5 100 2  
>  50 4 5 1 10 100 20 25 2  
>  **注意10永远在中间。**
>
> ![](https://img-blog.csdnimg.cn/479f4d5a4d4f47649af2d89a5af96c82.webp)

# 思路

>
> 1：网上也有人分享过这个题目，题目是完全一致的，[link](https://blog.csdn.net/g498912529/article/details/126030602
> "link")。
>
>
> 2：了解三阶积幻方的性质，其实可以根据它的性质来解这个题，不过过于复杂了些。可以参考的[百度百科](https://baike.baidu.com/item/%E4%B8%89%E9%98%B6%E7%A7%AF%E5%B9%BB%E6%96%B9/8879896?fr=aladdin
> "百度百科")：
>
> **【3个数一组的3组数（共9个数），组与组倍数相等，每组数乘积与倍数相等】**
>
> 【 **三阶积幻方的幻积值=中间数的3次方】**
>
> **题目描述的示例中，9个数字的中间数为6，积为216。**
>
> 3：不依赖它的性质其实也能做出来，本质上就是一个简单全排列问题，逐个检查全排列的结果是否满足条件即可。

# 考点

> 1：逻辑思维能力
>
> 2：全排列

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
     
    #处理输入
    nums = [int(x) for x in input().split(" ")]
    result = []
    
    def check(a):
        fixed_result = a[0] * a[1] * a[2]
        # 每行
        if (fixed_result != a[3] * a[4] * a[5] or fixed_result != a[6] * a[7] * a[8]):
            return False
    
        #每列
        if (fixed_result != a[0] * a[3] * a[6] or 
            fixed_result != a[1] * a[4] * a[7] or
            fixed_result != a[2] * a[5] * a[8]):
            return False
         
        #对角线
        if (fixed_result != a[0] * a[4] * a[8] or fixed_result != a[2] * a[4] * a[6]):
            return False
        
        return True
    
    
    def swap(a, k, i):
        t=a[k]
        a[k]=a[i]
        a[i]=t
    
    def Perm(a, i, j):
        if(i==j):
            if (check(a)):
                result.append(a.copy()) 
        else:
            for k in range(i,j+1):
                swap(a,i,k)#交换第一个i=k,即交换1和他自己；对后面的数字进行递归
                Perm(a,i+1,j)#递归
                swap(a,i,k)#再交换回来，进行下一次交换
            
    
    #全排列核心思想就是每个数字逐个与后面的数字进行交换
    Perm(nums,0,8)
    
    #排序
    result.sort(key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8]))
    
    #输出
    for single_res in result:
        print(" ".join([str(i) for i in single_res]))
    
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

