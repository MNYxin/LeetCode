**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 给定一个数组nums，可以将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中，最大的平分组个数。
>
> **输入描述：**  
>  第一行输入 m  
>  接着输入m个数，表示此数组  
>  数据范围:1<=M<=50, 1<=nums[i]<=50
>
> **输出描述：**
>
> 最大的平分组数个数。
>
> **示例1：**
>
> 输入：
>
> 7  
>  4 3 2 3 5 2 1
>
> 输出：
>
> 4
>
> 说明：可以等分的情况有：
>
> 4 个子集（5），（1,4），（2,3），（2,3）
>
> 2 个子集（5, 1, 4），（2,3, 2,3）
>
> 最大的平分组数个数为4个。
>
> **示例2：**
>
> 输入：
>
> 9  
>  5 2 1 5 2 1 5 2 1
>
> 输出：
>
> 4
>
> 说明：可以等分的情况有：
>
> 4 个子集（5，1），（5，1），（5，1），（2，2，2）
>
> 2 个子集（5, 1, 5,1），（2,2, 2,5,1）
>
> 最大的平分组数个数为4个。

# 思路

>
> 1：这题有点类似22年Q4出过的一道题，[等和子数组最小和](https://renjie.blog.csdn.net/article/details/128062049
> "等和子数组最小和")，与那一题不同的是，本题求解的是平分数组的最小和，这题求解的是最多可以分成多少个平分数组。但是逻辑几乎是一样的，因为！！！最多的分组对应的就是分组最小和！！！！
>
>
> 2：之前那道题是A卷的，这个应该是B卷的，大概就是A卷和B卷之间的差别吧，考点、逻辑几乎不变，就是描述和输出的结果变一下。搞得像高考数学AB卷一样。。。。。
>
> 3：它们都衍生于[leetcode 698](https://leetcode.cn/problems/partition-to-k-equal-
> sum-subsets/solution/hua-fen-wei-kge-xiang-deng-de-zi-ji-by-l-v66o/
> "leetcode 698")。
>
> 4：我这就不献丑了，leetcode各路大佬还是很强的。  
>

# 考点

> 1：动态规划

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
     
    def canPartitionKSubsets(nums, k):
        all = sum(nums)
        if all % k:
            return False
        per = all // k
        nums.sort()
        if nums[-1] > per:
            return False
        n = len(nums)
        dp = [False] * (1 << n)
        dp[0] = True
        cursum = [0] * (1 << n)
        for i in range(0, 1 << n):
            if not dp[i]:
                continue
            for j in range(n):
                if cursum[i] + nums[j] > per:
                    break
                if (i >> j & 1) == 0:
                    next = i | (1 << j)
                    if not dp[next]:
                        cursum[next] = (cursum[i] + nums[j]) % per
                        dp[next] = True
        return dp[(1 << n) - 1]
     
     
    #处理输入
    n = int(input())
    nums = [int(x) for x in input().split(" ")]
     
     
    for i in reversed(range(n+1)):
        #从最大的可能行开始，满足条件即为为最小的情况
        if (canPartitionKSubsets(nums, i)):
            print (i)
            break;
     

