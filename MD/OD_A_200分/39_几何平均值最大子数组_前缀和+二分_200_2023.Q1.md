**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**  
>  从一个长度为N的正数数组numbers中找出长度至少为L且几何平均值最大子数组，并输出其位置和大小。(K个数的几何平均值为K个数的乘积的K次方根)  
>  若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组，  
>  若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。
>
> **输入描述:**  
>
> 第一行输入为N、L，N表示numbers的大小(1<=N<=100000)，L表示子数组的最小长度(1<=L<=N)之后N行表示numbers中的N个数，每个一行(10-9<=numbers<=109)。  
>  **输出描述:**  
>  输出子数组的位置(从0开始计数)和大小，中间用一个空格隔开。  
>  **补充说明:**
>
> 用例保证除几何平均值为最大值的子数组外，其他子数组的几何平均值至少比最大值小最大值的10-10倍
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**  
>  输入
>
> 3 2
>
> 2
>
> 2
>
> 3  
>  输出:
>
> 1 2  
>  说明:  
>  长度至少为2的子数组有3个， [2,2] [2,3] [2,2,3] , 几何平均值最大为[2,3]， 输出其位置1和长度2
>
> **示例2：输入输出示例仅供调试，后台判题数据一般不包含示例**  
>  输入
>
> 10 2  
>  0.2  
>  0.1  
>  0.2  
>  0.2  
>  0.2  
>  0.1  
>  0.2  
>  0.2  
>  0.2  
>  0.2  
>  输出:
>
> 2 2  
>  说明:  
>
> 有多个长度至少为2的子数组的几何平均值为0.2，其中长度最短的为2，也有多个，长度为2月几何平均值为0.2的子数组最前面的那个为从第二个数开始的两个0.2组成的子数组
>
> ![](https://img-blog.csdnimg.cn/f9f6fadaf0ac4cb2bf8191fd5db5fabe.webp)

# 思路

> 1：leetcode上有一个类似的原题：[leetcode 644](https://leetcode.cn/problems/maximum-
> average-subarray-ii/ "leetcode 644")，但是VIP 才能看到这个题，所以在网上找了另外2篇博客介绍的也很详细：
>
> [九章算法 | Facebook面试题：最大平均值子数组2 - 知乎](https://zhuanlan.zhihu.com/p/33845675
> "九章算法 | Facebook面试题：最大平均值子数组2 - 知乎")[[LeetCode] 644. Maximum Average
> Subarray II 子数组的最大平均值之二](https://www.cnblogs.com/grandyang/p/8021421.html
> "\[LeetCode\] 644. Maximum Average Subarray II 子数组的最大平均值之二")
>
> 2：暴力双循环的方法由于数据量很大，肯定会超时。
>
> 3：本题和leetcode上的题目不一致的地方就在于一个是算平均值，一个是算几何平均值。
>
> 虽然有所差别，但是解题的方法还是一样的，利用的还是 **二分+前缀值** 的解法。
>
> 4：假设其中一个子数组0~k，它的几何平均值为res，那么有：
>
> a[0]*a[1] *...*a[k-1] = res^k
>
> 转换公式为：
>
> (a[0]/res)*(a[1]/res) *...*(a[k-1]/res) = 1
>
> 那这样的话题目就变成了怎么找这个res，根据数学关系，右侧等于1，那么左侧的各个值要么必然在min(a[0~k-1])
> 和max(a[0~k-1])之间，不然不可能乘积为1。
>
> 5：找到这个res之后，就算找到了当前子数组的几何平均值，还要找最大，那就从长度为L的子数组开始遍历，一直到N即可。要求的有一定的数学功底。
>
> 6：考这种hard题有啥意思？。。。。

# 考点

> 1：二分+数学

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import random
     
    #树节点
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
     
    #处理输入
    sub_arr_pos = 0
    sub_arr_size = 0
    params = [int(x) for x in input().split(" ")]
    N = params[0]
    L = params[1]
    
    # 最大 / 最小值 / 乘积
    min_num = float('inf')
    max_num = -float('inf')
    result = 1.0
    
    nums = [0 for x in range(N)]
    for i in range(N):
        nums[i] = float(input())
        min_num = min(min_num, nums[i])
        max_num = max(max_num, nums[i])
        if (i<L):
            result *= nums[i]
    
    def cal(result, nums, mid_num):
        global sub_arr_pos
        global sub_arr_size
        # 利用中间值来进行几何平均值计算
        result = result / pow(mid_num, L)
        #如果大于1，说明[0~L-1]已经大于这个临时的最大几何平均值mid_num, 可以直接返回。
        if (result >= 1):
            sub_arr_pos = 0
            sub_arr_size = L
            return True
        
    
        #否则需要往后延长，继续增加长度，用前缀的方式来保存前面的子数组的乘积
        pre_result = 1.0
        min_pre_result = float('inf')
        min_pre_result_pos = 0
    
        for i in range(L, N):
            result *= nums[i] / mid_num
            pre_result *= nums[i - L] / mid_num
        
            if (pre_result < min_pre_result) :
                min_pre_result = pre_result
                min_pre_result_pos = i - L
            
        
            if (result / min_pre_result >= 1) :
                sub_arr_pos = min_pre_result_pos + 1
                sub_arr_size = i - min_pre_result_pos
                return True
        return False
    
     
    
    
    #二分法找几何平均数，注意double数相等的判断方法,leetcode是10^-10次方
    while (max_num - min_num >= pow(10, -10)) :
        mid_num = (min_num + max_num) / 2
        #print(mid_num)
    
    
        if (cal(result, nums, mid_num)) :
            min_num = mid_num
        else:
            max_num = mid_num
        
    
    print(str(sub_arr_pos) + " " + str(sub_arr_size))
    
    
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

