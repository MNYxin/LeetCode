**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

>
> 公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决一个任务混部问题：有taskNum项任务，每个任务有开始时间（startTime），结束时间（endTime）,并行度（parallelism）三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放（结束时刻不占用）。任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行，请你计算完成这批任务混部最少需要多少服务器，从而最大最大化控制资源成本。
>
> 输入描述：  
>  第一行输入为taskNum，表示有taskNum项任务  
>  接下来taskNum行，每行三个整数，表示每个任务的开始时间  
>  （startTime ），结束时间（endTime ），并行度（parallelism）
>
> 输出描述：  
>  一个整数，表示最少需要的服务器数量
>
> 示例1 输入输出示例仅供调试，后台判断数据一般不包含示例  
>  输入  
>  3  
>  2 3 1  
>  6 9 2  
>  0 5 1  
>  输出
>
> 2
>
> 说明  
>  一共有三个任务，第一个任务在时间区间【2，3】运行，占用1个服务  
>  器，第二个任务在时间区间【6，9】运行，占用2个服务器，第三个任  
>  务在时间区间【0，5】运行，占用1个服务器，需要最多服务器的时间  
>  区间为【2，3】和【6，9】，需要2个服务器。
>
> 示例2 输入输出示例仅供调试，后台判断数据一般不包含示例  
>  输入  
>  2  
>  3 9 2  
>  4 7 3  
>  输出  
>  5  
>  说明  
>  一共两个任务，第一个任务在时间区间【3，9】运行，占用2个服务  
>  器，第二个任务在时间区间【4，7】运行，占用3个服务器，需要最多  
>  服务器的时间区间为【4，7】，需要5个服务器。
>
> 备注：  
>  1<=taskNum<=100000  
>  0<=startTime<endTime<=50000  
>  1<=parallelism<=100

# 思路

>
> ~~1：题目与[第56题【区间交集】](https://blog.csdn.net/misayaaaaa/article/details/127410463
> "第56题【区间交集】")非常相似。大致思路应该是不断的递归对区间求交集，求得交集之后将占用机器数相加，直到没有交集为止。~~
>
> 1：之前的思路有误，感谢评论区提出的问题。
>
>
> 2：新思路就是取一个set合集，放入所有的时间点。然后遍历每一个时间点，判断其是否在每一个区间之内，如果在，那么该时间点所需要的服务器数量+该区间的服务器数量。
>
> 因为区间的交集，必然最后的结果会有两个区间起始节点其中之一。这样就可以避免评论区的两个问题。
>
> 3：举一个比较长的例子：
>
> 4
>
> 0 5 1  
>  2 4 1
>
> 3 7 3  
>  6 9 2
>
> 所有时间点为：
>
> [0,5,2,4,3,7,6,9]
>
> 逐个元素判断其是否在四个区间之内：
>
> 0 -> 1
>
> 5 -> 3+2 = 5
>
> 2 -> 1 + 1= 2
>
> 4 -> 1+1+3 = 5
>
> 3 -> 1+1+3 = 5
>
> 7 -> 3 + 2 = 5
>
> 6 -> 3 + 2 = 5
>
> 9 -> 2
>
> 因此最大为5。
>
> **2：经评论区大佬指点，此题与 **[leetcode253](https://leetcode.cn/problems/meeting-rooms-
> ii/ "leetcode253")** 非常类似，我参考了这位博主的文章：**
>
> ****[Leetcode--Java--253. 会议室 II_会议室2 leetcode_外滩卷王的博客-
> CSDN博客](https://blog.csdn.net/Sherlock_Obama/article/details/123151960
> "Leetcode--Java--253. 会议室 II_会议室2 leetcode_外滩卷王的博客-CSDN博客")****
>
> **使用优先级队列来处理，应该可以完全避免超时问题了。**

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    def comp(a, b):
        return a - b
    
    def comp1(a, b):
        return a[0] - b[0]
    
    result_machine = 0
    
    #处理输入
    task_num = input()
    
    i = int(task_num)
    ranges = []
    while(i>0):
        input_str = input()
        input_list = [int(x) for x in input_str.split(" ")]
        ranges.append(input_list)
        i=i-1
    #区间排序
    ranges = sorted(ranges, key=functools.cmp_to_key(comp1))
    
    points = set()
    for single_range in ranges:
        points.add(single_range[0])
        points.add(single_range[1])
    #点排序
    points = sorted(points, key=functools.cmp_to_key(comp))
    
    result = 0;
    ignore = set()
    
    for point in points:
        current_sum = 0
        for i in range(len(ranges)):
            if (i in ignore):
                continue
    
            start = ranges[i][0]
            end = ranges[i][1]
            count = ranges[i][2]
    
            if (point < start):
                break
            elif (point < end):
                current_sum += count
            else:
                ignore.add(i)
    
    
        result = max(result, current_sum)
    
    
    print(result)
    

新解法：

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import queue
    
    def comp(a, b):
        return a - b
    
    def comp1(a, b):
        return a[0] - b[0]
    
    result_machine = 0
    
    #处理输入
    task_num = input()
    
    i = int(task_num)
    ranges = []
    while(i>0):
        input_str = input()
        input_list = [int(x) for x in input_str.split(" ")]
        ranges.append(input_list)
        i=i-1
    
    #区间排序
    ranges = sorted(ranges, key=functools.cmp_to_key(comp1))
    
    pq = queue.PriorityQueue()
    res = 0
    temp_res = 0
    
    for i in range(len(ranges)):
        while pq.qsize() > 0:
            top = pq.queue[0]
    
            if top[0] < ranges[i][0]:
                poll = pq.get()
                temp_res -= poll[1]
            else:
                break
    
        pq.put((ranges[i][1], ranges[i][2]))
        temp_res += ranges[i][2]
    
        if temp_res > res:
            res = temp_res
    
    print(res)
    

