**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**  
>
> 公司老板做了一笔大生意，想要给每位员工分配一些奖金，想通过游戏的方式来决定每个人分多少钱。按照员工的工号顺序，每个人随机抽取一个数字。按照工号的顺序往后排列，
> **遇到第一个数字比自己数字大的，那么，前面的员工就可以获得“距离*数字差值”的奖金。**
> 如果遇不到比自己数字大的，就给自己分配随机数数量的奖金。例如，按照工号顺序的随机数字是:
> 2,10.3。那么第2个员工的数字10比第1个员工的数字2大，所以，第1个员工可以获得1*(10-2)
> =8。第2个员工后面没有比他数字更大的员工，所以，他获得他分配的随机数数量的奖金，就是10。第3个员工是最后一个员工，后面也没有比他更大数字的员工，所以他得到的奖金是3。  
>  请帮老板计算一下每位员工最终分到的奖金都是多少钱
>
> **输入描述:**  
>  第一行n表示员工数量 (包含最后一个老板)  
>  第二是每位员工分配的 **随机数字**  
>  例如  
>  3  
>  2 10 3  
>  **输出描述:**  
>  最终每位员工分到的奖金数量  
>  例如  
>  8 10 3  
>  补充说明:  
>  随机数字不重复，员工数量(包含老板)范围1~10000，随机数范围1~100000
>
> **示例1**  
>  输入:  
>  3  
>  2 10 3  
>  输出:  
>  8 10 3

# 思路

> 1：其实翻译一下就是找数组的每一个元素的右边第一个比它大的数字。
>
> 2：如果用最简单的双层循环暴力法，最坏情况下 O(n^2)时间复杂度。
>
> 3：明显是一个单调栈就可以解决的问题，时间复杂度O(n)
>
> 当栈中为空，直接压入，栈不为空，比较栈顶元素 top 和 a[i]。 若 top < a[i] ，弹出栈顶元素。循环执行，直到遇到第一个
> top>a[i] （top即为第一个比其大的元素）或者 栈为空（左边没有比 a[i] 大的元素，因此栈中元素从底到上按照从大到小的顺序

# 考点

> 1：单调栈

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    def monoStack( nums):
        n = len(nums)
        res = [-1] * n
        stack = list()
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                res[stack[-1]] = (nums[i] - nums[stack[-1]]) * (i - stack[-1])
                stack.pop()
            stack.append(i)
        return res
     
     
    #处理输入
    N = int(input())
    nums = [int(x) for x in input().split(" ")]
     
    res = monoStack(nums)
    for i in range(len(res)):
        if res[i] == -1:
            res[i] = nums[i]
    print(" ".join([str(x) for x in res]))

