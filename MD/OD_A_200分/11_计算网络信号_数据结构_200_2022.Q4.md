**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>  网络信号经过传递会逐层衰减，且遇到阻隔物无法直接穿透，在此情况下需要计算某个位置的网络信号值。注意:网络信号可以绕过阻隔物
>
> array[m][n] 的二维数组代表网格地图  
>  array[i][j]=0代表i行j列是空旷位置;  
>  array[i][j]=x(x为正整数)代表i行j列是信号源，信号强度是x;  
>  array[i][j]=-1代表i行j列是阻隔物.  
>  信号源只有1个，阻隔物可能有0个或多个  
>  网络信号衰减是上下左右相邻的网格衰减 1  
>  现要求输出对应位置的网络信号值。
>
> **输入描述**
>
> 输入为三行，第一行为 m、n，代表输入是一个mxn的数组。第二行是一串 m xn 如个用空格分隔的整数  
>  每连续n个数代表一行，再往后 n个代表下一行，以此类推。对应的值代表对应的网格是空矿位置，还是信号源，还是阻隔物。第三行是i、j，代表需要计算
> array[i][j]的网络信号值。
>
> 注意:此处i和j均从 0 开始，即第一行i 为 0
>
> **输出描述**  
>  输出对应位置的网络信号值，如果网络信号未覆盖到，也输出0。  
>  一个网格如果可以途径不同的传播衰减路径传达，取较大的值作为其信号值。
>
> 示例1：
>
> 输入：
>
> 6 5  
>  0 0 0 -1 0 0 0 0 0 0 0 0 -1 4 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0  
>  1 4
>
> 输出：
>
> 2
>
> 示例2：
>
> 输入：
>
> 6 5  
>  0 0 0 -1 0 0 0 0 0 0 0 0 -1 4 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0  
>  2 1
>
> 输出：
>
> 0
>
> 备注
>
> 1.m不一定等于n，m<100 n<100,网络信号之和小于1000。  
>  2.信号源只有1个，阻隔物可能有0个或多个。  
>  3.输入的 m，n 与第二行的数组是合法的，无需处理数量对不上的异常情况。  
>  4.要求输出信号值的位置，不会是阻隔物。

# 思路

> 1：搜索类问题，这次是单源的搜索，也就是从单个起点进行搜索遍历，上下左右前进，信号值衰减1。
>
> 2：利用队列来模拟整个搜索过程，队列中保存所有大于等于 1
> 的信号位置，从信号源位置开始上下左右遍历，能够到达的信号值减1，并入队列，一轮遍历结束之后，头部元素出队列，直到所有元素遍历完成 或者 信号值衰减为1。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    def comp(a, b):
        return b-a
     
    #处理输入
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    matrix = [int(x) for x in input().split(" ")]
    target_params = [int(x) for x in input().split(" ")]
    target_i = target_params[0]
    target_j = target_params[1]
    #print(matrix)
        
    # 队列中保存所有大于等于 1 的信号位置
    queue = []
    # 找到信号源
    for i in range(m):
        for j in range(n):
            if (matrix[i * n + j] > 0) :
                queue.append([i,j])
                break
    #print(queue)
            
    # 信号可以上下左右传播
    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    
    while (len(queue) > 0) :
        pos = queue[0]
        queue.pop(0)
        i = pos[0]
        j = pos[1]
    
        # 信号强度为1，则不需要再传播了，后面肯定都是0
        if (matrix[i * n + j] - 1 == 0) :
            break
    
        for direction in directions:
            new_x = i + direction[0];
            new_y = j + direction[1];
    
            if (new_x >= 0 and new_x < m and new_y >= 0 and new_y < n and matrix[new_x * n + new_y] == 0) :
                matrix[new_x * n + new_y] = matrix[i * n + j] - 1
                queue.append([new_x, new_y])
            
    
    print(matrix[target_i * n + target_j])
    

