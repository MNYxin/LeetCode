**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> **题目描述**  
>
> 某农场主管理了一大片果园，fields表示不同果林的面积，单位:m^2，现在要为所有的果林施肥且必须在n天之内完成，否则影响收成。小布是果林的工作人员，他每次选择一片果林进行施肥，且一片果林施肥完后当天不再进行施肥作业。  
>  假设施肥机的能效为k，单位:m^2/day，请问至少租赁能效 k 为多少的施肥机才能确保不影响收成? 如果无法完成施肥任务，则返回-1。  
>  **输入描述**  
>  第一行输入为m和n，m表示fields中的元素个数，n表示施肥任务必须在n天内 (含n天) 完成
>
> 第二行输入为fields，fields[i]表示果林i的面积，单位: m^2  
>  **输出描述**  
>  对于每组数据，输出最小施肥机的能效 k，无多余空格。
>
> **备注**  
>  1 ≤ fields.length ≤ 10^4  
>  1 ≤ 10^9  
>  1 ≤ fieldsli] ≤10^9
>
> **示例1：**  
>  输入  
>  5 7  
>  5 7 9 15 10
>
> 输出  
>  9
>
> 说明  
>
> 当能效k为9时，fields[0]需要1天，fields[1]需要1天，fields[2]需要1天，fields[3]需要2天，fields[4]需要2天，共需要7天，不会影响收成。
>
> **示例2：**  
>  输入  
>  3 1  
>  2 3 4  
>  输出
>
> -1  
>  说明  
>  由于一天最多完成一片果林的施肥，无论k为多少都至少需要3天才能完成施肥，因此返回-1。

# 思路

> 1：简单的二分法题目，取排完序的 fields 数组中的一个二分中间值
> target作为效能k，那么效能K左边的所有fields必然都是在1天内完成，只需要处理下右边剩余的数组，算出还需要多少天即可。

# 考点

> 1：二分法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def cal(k, fields):
        days = 0
        for i in range(len(fields)):
            days += math.ceil(fields[i] / float(k))
        return days
    
    #处理输入
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    fields = [int(x) for x in input().split(" ")]
    
    # 最少天数小于果林大小可直接返回-1
    if (n<len(fields)):
        print(-1)
    elif(n==len(fields)):
        print(max(fields))
    else:
        #排序找到最小值
        fields = sorted(fields)
        left = 0
        right = fields[len(fields) - 1]
    
        result = -1
        while (left +1 < right):
            #取中间位置的值作为效能k，
            k = int(math.ceil(float(left + right) / 2))
    
            res = cal(k, fields)
    
            if (res - n > 0):
                left = k
            else:
                result = k
                right = k
        print(result)
    
    

