**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>
> 某个充电站，可提供n个充电设备，每个充电设备均有对应的输出功率。任意个充电设备组合的输出功率总和，均构成功率集合P的1个元素。功率集合P的最优元素，表示最接近充电站最大输出功率P_max的元素  
>  **输入描述**  
>  输入为3行:  
>  第1行为充电设备个数n  
>  第2行为每个充电设备的输出功率P_i  
>  第3行为充电站最大输出功率P_max
>
> **输出描述**  
>  功率集合P的最优元素  
>  备注  
>  充电设备个数 n >0  
>  最优元素必须小于或等于充电站最大输出功率P_max  
>  **示例1：**
>
> 输入
>
> 4  
>  50 20 20 60
>
> 90  
>  输出
>
> 90  
>  说明  
>  当充电设备输出功率50、20、20组合时，其输出功率总和为90，最接近充电站最大充电输出功率，因此最优元素为90。
>
> **示例2：**
>
> **2**  
>  50 40
>
> 30  
>  输出  
>  0  
>  说明  
>  所有充电设备的输出功率组合，均大于充电站最大充电输出功率30，此时最优元素值为0。

# 思路

> 1：简单的01背包问题，个人觉得 [leetcode ](https://leetcode.cn/circle/article/lUki6J/
> "leetcode ")上这位大佬讲的比较细，大家可以详细读一下这篇文章。
>
> ![](https://img-
> blog.csdnimg.cn/img_convert/83e4dcbbe8793805cee5e2b6e1b7f3fa.jpeg)
>
> 2：背包问题的互转
>
> 充电设备个数 -> 物品个数
>
> 充电设备的功率 -> 物品的价值
>
> 充电设备的功率 -> 物品的体积
>
> 最大输出功率 -> 背包容量
>
> 比较tricky的地方就是功率即代表体积，也代表价值。
>
> 最优
>
> 3： **所有背包问题的理论基础重中之重是01背包，一定要理解透！**

# 考点

> 1：背包问题

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    #处理输入
    n = int(input())
    p = [int(x) for x in input().split(" ")]
    p_max = int(input())
    
    #dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
    dp = [[0 for x in range(p_max + 1)] for y in range(n+1)]
    
    # 初始化, i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。
    j = p_max
    while(j >= p[0]):
        dp[0][j] = dp[0][j - p[0]] + p[0]
        j -= 1
    
    for i in range(1, n):  # 遍历物品
        for j in range(0, p_max+1): # 遍历背包容量
            # 背包容量为j，如果物品i的体积，此时dp[i][j]就是dp[i - 1][j]
            if (j < p[i]):
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - p[i]] + p[i])
    
    print(dp[n-1][p_max])
    
    
    
    
    
    

