**所有题目均有五种语言实现。[C实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C实现目录")、[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html
"C++
实现目录")、[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")、[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")、[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")**

# 题目

> 请按下列描达构建一颗二叉树，并返回该树的根节点:  
>  1、先创建值为 -1 的根结点，根节点在第 0 层;  
>  2、然后根据 operations 依次添加节点:operations[i] = [height，index] 表示对第 height 层的第
> index 个节点node ，添加值为 i 的子节点:  
>  -> 若node 无[左子节点] ，则添加左子节点  
>  -> 若node 有[左子节点] ，但无[右子节点] ，则添加右子节点:  
>  否则不作任何外理。
>
> height、index 均从0开始计数; index 指所在层的创建顺序注意:  
>  ->输入用例保证每次操作对应的节点已存在:  
>  ->控制台输出的内容是根据返回的树根节点，按照层序遍历二叉树打印的结果。
>
> **示例1**
>
> 输入: operations=[[0, 0], [0, 0], [1, 1], [1, 0], [0, 0]]  
>  输出: [-1, 0,1, 3, null, 2]  
>  **示例2**  
>  输入: operations=[[0, 0], [1, 0], [1, 0],[2, 1], [2, 1], [2, 1], [2, 0], [3,
> 1], [2, 0]]
>
> 输出: [-1. 0, null, 1, 2, 6, 8, 3, 4, null, null, null, null, null, null, 7]
>
> **提示**  
>  1<= operations.length <= 100  
>  operations[i].length == 2  
>  0 <= operations[i][0] < 100  
>  0 <= operations[i][1] < 100  
>  示例输出说明: 示例中的输出按照二叉树层序方式输出各节点的值.  
>  1.首个值是根节点的值，也是返回值:  
>  2.null 表示是空节点，此特殊层序遍历会遍历有值节点的 null 子节点
>
> ![](https://img-blog.csdnimg.cn/a9f27e10e907477f84a7845aa563f223.webp)

# 思路

> 1：先理解题目要求，每次的操作描述【根据 operations 依次添加节点:operations[i] = [height，index] 表示对第
> height 层的第 index 个节点node ，添加值为 i 的子节点】，意思就是[0， 1]
> 表示的就是添加第0层的第1个节点，这个节点的值就是此次operation的序号 i 。
>
> 2：输出就是二叉树的层序遍历结果。
>
> 3：核心考点有两个，第一个是二叉树的创建，要理解TreeNode的定义，不然不好操作。其次就是二叉树层序遍历。

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #处理输入
    input_infos= input().replace("[","").replace("]", "").split(",")
    #print(input_infos)
    operations = []
            
    for i in range(len(input_infos)):
        if (i%2==0):
            temp = []
            temp.append(int(input_infos[i]))
            temp.append(int(input_infos[i+1]))
            operations.append(temp)
    
    #头节点
    head = TreeNode(-1);
    first_level = [head]
    
    tree = [first_level]
    
    
    for i in range(len(operations)):
        height = operations[i][0]
        index = operations[i][1]
    
        # 开启下一层
        if((len(tree)) <= height + 1):
            tree.append([])
        
    
        temp_node = TreeNode(i)
        tree[height + 1].append(temp_node)
    
        parent_node = tree[height][index];
        if (parent_node.left is None):
            parent_node.left = temp_node
        elif (parent_node.right is None):
            parent_node.right = temp_node
    
    
    result = []
    queue = []
    queue.append(tree[0][0]);
    
    while (len(queue) > 0):
        node = queue[0]
        queue.pop(0)
    
        if (node is not None):
            result.append(str(node.val));
            queue.append(node.left);
            queue.append(node.right);
        else:
            result.append("null");
    
    
    while (True):
        if (result[-1] == "null"):
            result.pop()
        else :
            break
    
    res_str = "[" + ",".join(result) + "]"
    print(res_str)
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

