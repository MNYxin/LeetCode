**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>
> 祖国西北部有一片大片荒地，其中零星的分布着一些湖泊，保护区，矿区.整体上常年光照良好，但是也有一些地区光照不太好。某电力公司希望在这里建设多个光伏电站，生产清洁能源对每平方公里的土地进行了发电评估，其中不能建设的区域发电量为0kw，可以发电的区域根据光照，地形等给出了每平方公里年发电量x千瓦。我们希望能够找到其中集中的矩形区域建设电站，能够获得良好的收益.  
>  **输入描述**  
>  第一行输入为调研的地区长，宽，以及准备建设的电站【长宽相等，为正方形】的边长最低要求的发电量
>
> 之后每行为调研区域每平方公里的发电量  
>  **输出描述**  
>  输出为这样的区域有多少个
>
> **示例1：**
>
> 输入  
>  2 5 2 6  
>  1 3 4 5 8  
>  2 3 6 7 1
>
> 输出
>
> 4  
>  输入说明  
>  调研的区域大小为长2宽5的矩形，我们要建设的电站的边长为2，建设电站最低发电量为6.  
>  输出说明
>
> 长宽为2的正方形满足发电量大于等于6的区域有4个
>
> **示例2：**
>
> 输入
>
> 2 5 1 6  
>  1 3 4 5 8  
>  2 3 6 7 1  
>  输出  
>  3

# 思路

> 1：看来题库是没啥新题了，这题就是换了下说法，与 之前的这个题一摸一样[华为机试真题 Python 实现【探索地块建立】【2022.11 Q4
> 新题】_MISAYAONE的博客-
> CSDN博客](https://renjie.blog.csdn.net/article/details/128134566 "华为机试真题
> Python 实现【探索地块建立】【2022.11 Q4 新题】_MISAYAONE的博客-CSDN博客")
>
> 连例子都是一模一样。
>
> 2：要求：
>
> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

# 考点

> 1：二维前缀和

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
     
    def maxSideLength(mat, threshold, c):
        m, n = len(mat), len(mat[0])
        P = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1]
        
        ans = 0;
        #print (P)
        #2、遍历前缀和矩阵，获得边长等于c的矩阵
        for i in range(c,m+1):
            for j in range(c, n+1):
                #重点理解：减去点[i-c][j]和点[i][j-c]的矩阵前缀和，剩下来的为一个边长为c正方形，注意点[i-c][j-c]减了两次，需要加一个回来
                if (P[i][j] - P[i - c][j] - P[i][j - c] + P[i - c][j - c] >= threshold):
                    ans += 1
     
        return ans
     
     
    #处理输入
    #print ( input())
     
    input_params = [int(x) for x in input().split(" ")]
    n=input_params[0]
    m=input_params[1]
    c=input_params[2]
    k=input_params[3]
     
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
     
    print (maxSideLength(matrix, k, c))
     
     

