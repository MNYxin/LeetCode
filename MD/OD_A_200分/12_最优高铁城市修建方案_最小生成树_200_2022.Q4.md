**所有题目均有三种语言实现。**[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")、[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")、[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")

# 题目

> **题目描述：**
>
> 高铁城市圈对人们的出行、经济的拉动效果明显。
>
> 每年都会规划新的高铁城市圈建设。在给定城市数量，可建设高铁的两城市间的修建成本列表、以及结合城市商业价值会固定建设的两城市建高铁。
>
> 请你设计算法，达到 **修建城市高铁的最低成本** 。注意，需要满足城市圈内城市间两两互联可达(通过其他城市中转可达也属于满足条件）。
>
> **输入描述：**
>
> 1、第一行，包含此城市圈中城市的数量、可建设高铁的两城市间修建成本列表数量、必建高铁的城市列表。三个数字用空格间隔。
>
> 2、可建设高铁的两城市间的修建成本列表，为多行输入数据，格式为3个数字，用空格分隔，长度不超过1000。
>
> 3、 固定要修建的高铁城市列表，是上面参数2的子集，可能为多行，每行输入为2个数字，以空格分隔。
>
> 城市id从1开始编号，建设成本的取值为正整数，取值范围均不会超过1000
>
> **输出描述：**
>
> 修建城市圈高铁的最低成本，正整数。如果城市圈内存在两城市之间无法互联，则返回-1。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3 3 0`  
> `1 2 10`  
> `1 3 100`  
> `2 3 50`
>
> **输出**
>
> `60`
>
> **解释：**
>
> 3 3 0城市圈数量为3，表示城市id分别为1,2,3  
>  1 2 10城市1，2间的高铁修建成本为10  
>  1 3 100城市1，3间的高铁修建成本为100  
>  2 3 50城市2，3间的高铁修建成本为50  
>  满足修建成本最低，只需要建设城市1，2间，城市2，3间的高铁即可，城市1，3之间可通过城市2中转来互联。这样最低修建成本就是60。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `3 3 1`  
> `1 2 10`  
> `1 3 100`  
> `2 3 50`
>
> `1 3`
>
> **输出**
>
> `110`

# 思路

> 1：考虑这个问题，其实是求 **
> **[最小生成树](https://blog.csdn.net/qq_40693171/article/details/120552056
> "最小生成树")****
> 的题目，不过就是增加了一些难度设置，就是可能会有必须要添加的边做初始集合，所以这里参考使用Kruskal算法，基于并查集的实现，先把必须修建高铁的边添加进去，之后就取最小花费的边进行判断，如果没有构成圈，就添加边，直到边集合有n-1条边结束，或者没有办法联通就输出-1。
>
> 2：并查集的模板可以记一下。

# 考点

> 1：并查集

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    def get_shorter_time(a, b):
        if (a * 10 < b):
            return a * 10
        return b
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n+1):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
            
    def comp(a, b): 
        return a[2] - b[2]
     
    #处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    pair_count_1= params[1]
    pair_count_2=params[2]
    
    # 可建设高铁的两城市
    city_pair_1 = []
    for i in range(pair_count_1):
        city_pair_1.append([int(x) for x in input().split(" ")])
    
    
    # 必建高铁的两城市
    city_pair_2 = []
    for i in range(pair_count_2):
        city_pair_2.append([int(x) for x in input().split(" ")])
    
    
    uf = UF(n)
    
    # key为修建高铁的两个城市，value为费用
    city_map = {}
    for city_pair in city_pair_1:
        city1 = city_pair[0]
        city2 = city_pair[1]
        if city1 < city2:
            key = str(city1) + "-" + str(city2)
        else:
            key = str(city2) + "-" + str(city1)
        city_map[key] =  city_pair[2]
    
    
    result = 0
    # 先计算必建高铁情况下的费用
    for city_pair in city_pair_2:
        city1 = city_pair[0]
        city2 = city_pair[1]
        if city1 < city2:
            key = str(city1) + "-" + str(city2)
        else:
            key = str(city2) + "-" + str(city1)
        result += city_map[key]
        # 纳入并查集
        uf.union_connect(city1, city2)
    
    
    #  已经满足所有城市通车，直接返回
    if (uf.count == 1):
        print(result)
    else:
        # 按修建费用排序
        city_pair_1 = sorted(city_pair_1, key=functools.cmp_to_key(comp))
    
        # 当前的最小权重边
        for city_pair in city_pair_1:
            city1 = city_pair[0]
            city2 = city_pair[1]
            # 判断两城市是否相连
            if (uf.item[city1] != uf.item[city2]):
                uf.union_connect(city1, city2)
                # 若可以合入，则将对应的建造成本计入result
                result += city_pair[2]
            
            if (uf.count == 1):
                break
            
    
    
        # count>1代表有的城市无法通车
        if (uf.count > 1):
            print(-1)
        else:
            print(result)

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

