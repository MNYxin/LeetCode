**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 当前IT部门支撑了子公司颗粒化业务，该部门需要实现为子公司快速开租建站的能力，建站是指在一个全新的环境部署一套IT服务。  
>  １：每个站点开站会由一系列部署任务项构成，每个任务项部署完成时间都是固定和相等的，设为1.  
>  ２：部署任务项之间可能存在依赖，假如任务2依赖任务1，那么等任务1部署完，任务2才能部署。  
>  ３：任务有多个依赖任务则需要等所有依赖任务都部署完该任务才能部署。  
>  ４：没有依赖的任务可以并行部署，优秀的员工们会做到完全并行无等待的部署。  
>  给定一个站点部署任务项和它们之间的依赖关系，请给出一个站点的最短开站时间。  
>  **输入描述**  
>  第一行是任务数taskNum,
>
> 第二行是任务的依赖关系数relationsNum接下来 relationsNum 行，每行包含两个id，描述一个依赖关系，格式为: IDi
> IDj，表示部署任务部署完成了，部署任务自容署，IDi 和 IDj值的范围为: [0,taskNum)  
>  注: 输入保证部署任务之间的依赖不会存在环。
>
> **输出描述**  
>  1个整数，表示一个站点的最短开站时间。  
>  备注  
>  1 < taskNum ≤ 100  
>  1 ≤ relationsNum ≤ 5000
>
> **示例1：**
>
> 输入  
>  5
>
> 5  
>  0 4  
>  1 2  
>  1 3
>
> 2 3
>
> 2 4  
>  输出  
>  3
>
> 说明：
>
> 先同时部署任务0和任务1，然后部署任务2，最后同时部署任务3和任务4.最短开站时间为3
>
> **示例2：**
>
> 输入  
>  5
>
> 3  
>  0 3  
>  0 4  
>  1 3  
>  输出  
>  2
>
> 说明：
>
> 先同时部署任务0，任务1，任务2。然后再同时部署任务3和4.最短开站时间为2.

# 思路

>
> 1：一个非常经典的拓扑排序的问题，网上也有原始的题型：[最短工期](https://blog.csdn.net/qq_45921756/article/details/123721672
> "最短工期")。
>
>
> 2：考察的就是拓扑排序，因为本题设定了所有任务消耗时间都为1，所以比原题还更简单一些。只要从入度为零的点往后不断更新即可，都不用算每层的最短时间。只需要算有多少层就行了。

# 考点

> 1：拓扑排序

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #处理输入
    taskNum = int(input())
    relationsNum = int(input())
    relation_ids = []
    for i in range(relationsNum):
        relation_ids.append([int(x) for x in input().split(" ")])
    
    
    # 每个任务的前置依赖任务个数，也就是拓扑排序中的入度
    upstream = [0 for x in range(taskNum)]
    # 每个任务的下游任务， 也就是拓扑排序中的出度
    downstream = [[] for x in range(taskNum)]
    print(relation_ids)
    
    #初始化入度、出度
    for relation_id in relation_ids:
        downstream[relation_id[0]].append(relation_id[1]) 
        upstream[relation_id[1]]+=1 
    
    
    #队列中保存当前入度为0 的任务id
    queue = []
    result = 1
    
    for i in range(taskNum):
        #将所有入度为零的任务入队, 默认耗时为1
        if (upstream[i] == 0):
            queue.append([i, result]) 
        
    
    
    while (len(queue)> 0):
        current_task = queue.pop(0)
        task = current_task[0]
        time = current_task[1]
    
        for downstream_task in downstream[task]:
            # 当前任务的入度减小到0时，放入queue中
            upstream[downstream_task] -= 1
            if (upstream[downstream_task] == 0):
                result = time + 1
                queue.append([downstream_task, result])
    
    print(result)
    
    
    
    
    

