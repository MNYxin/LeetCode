**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述：**
>
> 现需要实现一种算法，能将一组压缩字符串还原成原始字符串， **还原规则** 如下：
>
> 1、字符后面加数字N，表示重复字符N次。例如：压缩内容为A3，表示原始字符串为AAA。  
>  2、花括号中的字符串加数字N，表示花括号中的字符重复N次。例如压缩内容为{AB}3，表示原始字符串为ABABAB。  
>  3、字符加N和花括号后面加N，支持 **任意的嵌套** ，包括 **互相嵌套** ，例如：压缩内容可以{A3B1{C}3}3
>
> **输入描述：**
>
> 输入一行压缩后的字符串
>
> **输出描述：**
>
> 输出压缩前的字符串
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `{A3B1{C}3}3`
>
> **输出**
>
> `AAABCCCAAABCCCAAABCCC`
>
> **说明**
>
> {A3B1{C}3}3代表A字符重复3次，B字符重复1次，花括号中的C字符重复3次，最外层花括号中的AAABCCC重复3次。

# 思路

> 1：和以前的 [报文解压缩](https://renjie.blog.csdn.net/article/details/128085502
> "报文解压缩") 这个题非常类似。
>
> 2：遍历字符串的同时保持原先的状态，由于还有嵌套的结构，因此想到了使用栈这个数据结构。
>
> 3：四种情况需要考虑/数字/字母/{ 符号/}符号

# 考点

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    def repeat_operation(stack,pos,repeat_count):
        count = len(stack) - pos
    
        # temp_stack用于存储弹栈数据
        temp_stack = [0 for x in range(count)]
    
        while (count >= 1):
            count -= 1
            temp_stack[count] = stack.pop()
        
        
        temp_str = "".join(temp_stack)
        result = ""
        #重复repeat_count次
        for i in range(repeat_count):
            result += temp_str
        
    
        stack.append(result);
        
     
    #处理输入
    input_str = input() + " "
    stack = []
    # bracket_pos 保存的是所有花括号出现的位置
    bracket_pos = []
    number_str = ""
    
    for i in range(len(input_str)):
        c = input_str[i]
        if (c >= '0' and c <= '9'): 
            number_str += c
            continue
        
        
        #数字
        if (len(number_str)>0): 
            repeat_count = int(number_str) 
            number_str = ""
            # 若此时栈顶是 } 字符, 将对应的字母重复repeat_count次
            if (stack[-1] == "}"): 
                #获取上一个{的位置
                pos = bracket_pos.pop()
                #删除左右{
                stack.pop(pos) 
                stack.pop()
                # 重复{之间的字母
                repeat_operation(stack, pos, repeat_count) 
            else: 
                #不是 } 字符, 简单重复栈顶字符对应次即可
                repeat_operation(stack, len(stack) - 1, repeat_count)
               
            
    
        #{ 字符
        if (c == '{'):
            bracket_pos.append(len(stack))
    
        # 其他字符 (字母 + )
        stack.append(c + "")
    
    
    # 输出
    print("".join(stack)) 

