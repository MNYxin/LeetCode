**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 题目描述:  
>  快递业务范围有N个站点，A站点与B站点可以中转快递，则认为A-B站可达，如果A-B可达，B-C可达，则A-
> C达。现在给N个站点编号0、1、...n-1，用s[i][j] 表示i-j是否可达，s[i][j] =1表示i-j可达，s[i][j] =0表示i-
> j不可达。现用二维数组给定N个站点的可达关系，请计算至少选择从几个主站点出发，才能可达所有站点(覆盖所有站点业)  
>  说明: s[i][j] 与s [j][i] 取值相同  
>  输入描述:  
>  第一行输入为N，N表示站点个数之后N行表示站点之间的可达关系，第i行第i个数值表示编号为i和之间是否可达输出描述:  
>  输出站点个数，表示至少需要多少个主站点  
>  补充说明:  
>  1<N<10000
>
> 示例1  
>  输入:  
>  4  
>  1 1 1 1  
>  1 1 1 0  
>  1 1 1 0  
>  1 0 0 1  
>  输出:  
>  说明:  
>  选择0号站点作为主站点，0站点可达其他所有站点，所以至少选择1个站点作为主站才能覆盖所有站点业务。
>
> 示例2  
>  输入:
>
> 4  
>  1 1 0 0  
>  1 1 0 0  
>  0 0 1 0  
>  0 0 0 1  
>  输出:  
>  3  
>  说明:  
>  选择0号站点可以覆盖0、1站点，选择2号站点可以覆盖2号站点，选择3号站点可以覆盖3号站点，所以至少选择3个站点作为主站才能覆盖所有站点业务。

# 思路

> 1：又是一个类似岛屿个数的那种DFS
> 题目，回溯法，从每一个站点出发，将可以到达的站点置为已到达(可以用一个集合或者map来保存已到达的站点)，最后看需要从多少个站点出发的个数即可。

# 考点

> 1：回溯法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def check(site_set,n,matrix):
        for i  in range(len(matrix)):
            if(i in site_set):    
                continue        
            if(n != i and matrix[n][i] == 1):
                site_set.add(i)
                check(site_set, i,matrix)
    
    
    
    #处理输入
    N = int(input())
    matrix = []
    for i in range(N):
        matrix.append([int(x) for x in input().split(" ")])
     
    #已经有连通的站点
    site_set = set()  
    #需要遍历的次数  
    res = 0   
    for i in range(N):
        #当前站点已经可以达到
        if(i in site_set):
            continue
        temp = set()
        temp.add(i)
        check(temp, i, matrix)
        site_set = set.union(site_set, temp)
        res +=1
    
    print(res)

* * *

时间限制：C/C++ 1秒，其他语言 2秒

空间限制：C/C++262144K，其他语言524288K

64bit IO Format：%lld

* * *

**语言限定：**  
C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
Python2（2.7.3）,  
PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript Node(12.18.2),
JavaScript V8(6.0.0),  
Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
5.2), Pypy2(pypy2.7.13),  
Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10), Groovy(3.0.6),
TypeScript(4.1.2), Mysql(8.0)

