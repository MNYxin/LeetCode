**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 有一组区间[a0，b0]，[a1，b1]，…（a，b表示起点，终点），区间有可能重叠、相邻，重叠或相邻则可以合并为更大的区间；
>
>
> 给定一组连接器[x1，x2，x3，…]（x表示连接器的最大可连接长度，即x>=gap），可用于将分离的区间连接起来，但两个分离区间之间只能使用1个连接器；
>
> 请编程实现使用连接器后，最少的区间数结果。
>
> 区间数量<10000，a,b均 <=10000  
>  连接器梳理<10000；x <= 10000
>
> **输入描述**
>
> 区间组：[1,10],[15,20],[18,30],[33，40]  
>  连接器组：[5,4,3,2]
>
> **输出描述**
>
> 1
>
> 说明：
>
> 合并后：[1,10],[15,30],[33,40]，使用5, 3两个连接器连接后只剩下 [1, 40]。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> 输入
>
> [1,10],[15,20],[18,30],[33,40]  
>  [5,4,3,2]
>
> 输出
>
> 1
>
> 说明
>
> 合并后：[1,10], [15,30], [33,40]，使用5, 3两个连接器连接后只剩下[1,40]。

# 思路

> 1：区间重叠合并类的问题经常考啊。。。
>
> 2：第一步肯定是自然合并，在不用链接器的情况下直接合并得到第一轮结果
>
> 3：然后就是遍历第一轮结果，看有没有分离的区间，计算出分离区间的大小后，与链接器数组进行比较，看能否覆盖他们的距离。
>
> 4：其次是这个最少区间结果，意思就是大小不用管，只用管区间个数
>
> 5：最后用贪心来对比区间距离和连接器的大小，逐个选择即可。

# 考点

> 1：数据结构
>
> 2：贪心算法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    
    def comp(a, b):
        if a[0] == b[0]:
            return a[1] - b[1]
        else:
            return a[0] - b[0]
    
    #处理输入
    input_ranges = [int(x) for x in input().replace("[", "").replace("]", "").split(",")]
    input_connectors = [int(x) for x in input().replace("[", "").replace("]", "").split(",")]
    
    #print (input_ranges)
    ranges = []
    for i in range(len(input_ranges)):
        if i % 2 != 0:
            ranges.append([input_ranges[i-1], input_ranges[i]])
    
    ranges = sorted(ranges, key= functools.cmp_to_key(comp))
    
    #print (ranges)
    
    
    result = 0
    distances = []
    left = ranges[0][0]
    right = ranges[0][1]
    for i in range(len(ranges)):
        if (ranges[i][0] <= right):
            right = max(right, ranges[i][1])
        else:                  
            result+=1
            distances.append(ranges[i][0]-right)
            right = ranges[i][1]
    result+=1
    
    distances = sorted(distances)
    connectors = sorted(input_connectors)
    
    idx = 0;
    for i in range(len(connectors)):
        if idx > len(distances):
            break
        if (connectors[i] >= distances[idx]):
            idx+=1
            result-=1
    print (result)
    

