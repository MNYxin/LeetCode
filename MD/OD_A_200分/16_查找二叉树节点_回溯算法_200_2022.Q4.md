**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述：**
>
> 已知树形结构的所有节点信息，现要求根据输入坐标（x,y）找到该节点保存的内容值，其中x表示节点所在的层数，  
>  根节点位于第0层，根节点的子节点位于第1层，依此类推，  
>  y表示节点在该层内的相对偏移，从左至右，第一个节点偏移0，第二个节点偏移1，依此类推，
>
> * * *
>
> ![](https://img-blog.csdnimg.cn/ee481a092b404f82ab0c0d7560a3dac3.png)
>
> * * *
>
> **举例：** 上图中，假定圆圈内的数字表示节点保存的 **内容值** ，则根据坐标(1,1)查到的内容值是23。
>
> **输入描述：**
>
> 每个节点以一维数组（int[]）表示，所有节点信息构成二维数组（int[][]），二维数组的0位置存放根节点；  
>  表示单节点的一维数组中，0位置保存 **内容值** ，后续位置保存子节点在二维数组中的 **索引位置** 。  
>  对于上图中，根节点的可以表示为{10，1，2}，树的整体表示为  
>  {{10,1,2},{-21,3,4},{23,5},{14},{35},{66}}  
>  查询条件以长度为2的一维数组表示，上图查询坐标为(1,1)时表示为  
>  {1,1}
>
> 使用Java标准IO键盘输入进行录入时，先录入节点数量，然后逐行录入节点。最后录入查询的位置，对于上述示例为：
>
> `6`  
> `10 1 2`  
> `-21 3 4`  
> `23 5`  
> `14`  
> `35`  
> `66`  
> `1 1`
>
> **输出**
>
> `{23}`
>
> **举例：** 上图中，假定圆圈内的数字表示节点保存的内容值，则根据坐标(1,1)查到的内容值是23。
>
> **输出描述：**
>
> 查询到内容时，输出{内容值}，查询不到时输出{}  
>  上图中根据坐标(1,1)查询输出{23}，根据坐标(1,2)查询输出{}
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `6`  
> `10 1 2`  
> `-21 3 4`  
> `23 5`  
> `14`  
> `35`
>
> `66`
>
> `1 1`
>
> **输出**
>
> `{23}`

# 思路

> 1：这种阅读理解题是真的烦。
>
>
> 2：题目中最重要的一句话："每个节点以一维数组（int[]）表示，所有节点信息构成二维数组（int[][]），二维数组的0位置存放根节点；表示单节点的一维数组中，0位置保存
> **内容值** ，后续位置保存子节点在二维数组中的 **索引位置** 。"
>
> **意味着二维数组的第一个元素{10，1，2}，10表示节点值，1和2表示的是它的子节点在一维数组中的索引值** 。

# 考点

> 1：二叉树
>
> 2：BFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    result = []
    def calc(nodes, index, n):
        node = nodes[index]
        if (n == 0):
            result.append(node[0])
            return
        
        
        
        if (len(node) == 1):
            return
        
        
        for i in range(1, len(node)):
            calc(nodes, node[i], n - 1)
        
    
    
    def get_result(nodes, x, y):
        if (x < 0 or y < 0):
            return "{}" 
        calc(nodes, 0, x)
        
        if (y >= len(result)):
            return "{}"
        
        return "{" + str(result[y]) + "}"
    
    
    #处理输入
    n = int(input())
    
    nodes_info = []
    for i in range(n):
        nodes_info.append([int(x) for x in input().split(" ")])
    
    target_info = [int(x) for x in input().split(" ")]
    x = target_info[0]
    y = target_info[1]
    
    
    print(get_result(nodes_info,x,y))

