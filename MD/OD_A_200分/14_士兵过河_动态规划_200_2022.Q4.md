**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 一支N个士兵的军队正在趁夜色逃亡，途中遇到一条湍急的大河。  
>  敌军在T的时长后到达河面，没到过对岸的士兵都会被消灭。  
>  现在军队只找到了1只小船，这船最多能同时坐上2个士兵。
>
> 1）当1个士兵划船过河，用时为 a[i]；0 <= i < N  
>  2）当2个士兵坐船同时划船过河时，用时为max(a[j],a[i])两士兵中用时最长的。  
>  3）当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时。  
>  4）如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。  
>  请帮忙给出一种解决方案，保证存活的士兵最多，且过河用时最短。
>
> **输入描述：**
>
> 第一行：N 表示士兵数(0<N<1,000,000)  
>  第二行：T 表示敌军到达时长(0 < T < 100,000,000)  
>  第三行：a[0] a[1] … a[i]… a[N- 1]  
>  a[i]表示每个士兵的过河时长。  
>  (10 < a[i]< 100; 0<= i< N）
>
> **输出描述：**
>
> 第一行：”最多存活士兵数” “最短用时”
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5`  
> `43`  
> `12 13 15 20 50`
>
> **输出**
>
> `3 40`
>
> **说明**
>
> 可以达到或小于43的一种方案：  
>  第一步：a[0] a[1] 过河用时：13  
>  第二步：a[0] 返回用时：12  
>  第三步：a[0] a[2] 过河用时：15
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5`  
> `130`  
> `50 12 13 15 20`
>
> **输出**
>
> `5 128`
>
> **说明**
>
> 可以达到或小于130的一种方案：  
>  第一步：a[1] a[2] 过河用时：13  
>  第二步：a[1] 返回用时：12  
>  第三步：a[0] a[5] 过河用时：50  
>  第四步：a[2] 返回用时：13  
>  第五步：a[1] a[2] 过河用时：13  
>  第六步：a[1] 返回用时：12  
>  第七步：a[1] a[3] 过河用时：15  
>  所以输出为：  
> `5 128`
>
> **示例3** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `7`  
> `171`  
> `25 12 13 15 20 35 20`
>
> **输出**
>
> `7 171`
>
> **说明**
>
> 可以达到或小于60的一种方案：  
>  第一步：a[1] a[2] 过桥用时：13  
>  第二步：a[1] 带火把返回用时：12  
>  第三步：a[0] a[5] 过桥用时：35  
>  第四步：a[2] 带火把返回用时：13  
>  第五步：a[1] a[2] 过桥用时：13  
>  第六步：a[1] 带火把返回用时：12  
>  第七步：a[4] a[6] 过桥用时：20  
>  第八步：a[2] 带火把返回用时：13  
>  第九步：a[1] a[3] 过桥用时：15  
>  第十步：a[1] 带火把返回用时：12  
>  第十一步：a[1] a[2] 过桥用时：13
>
> 所以输出为：
>
> `7 171`
>
> **备注：**
>
> 1）两个士兵的同时划船时，如果划速不同则会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划的慢的士兵看齐。  
>  2）两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢；  
>  3）由于河水湍急大量的力用来抵消水流的阻力，所以2）中过河用时不是a[i] *2，  
>  而是a[i] * 10。

# 思路

> 1：出这种hard题，感觉想招ACM选手。。。
>
> 2：类似一个经典的[过桥问题](https://www.cnblogs.com/qionglouyuyu/p/5126573.html
> "过桥问题")，但是有变种，手电筒换成了小船，过桥也变化了过河。。。
>
> 3：最关键的目标就是在过河过程中，让最慢的两个人消耗的时间最短。
>
> 具体的方法就是让最慢的两个一起过河，然后让对岸快的人回来送船。（ **其实从题目给出的示例的说明中，也能发现符合这个逻辑** ）
>
> 1、让用时最短的两个士兵a[0], a[1]划船过河到对岸，用时a[1]  
>  2、然后让a[1]留在对岸，让最快的士兵a[0]划船回来本岸，用时a[0]  
>  3、然后让本岸用时最长的两个士兵划船过河到对岸  
>  4、然后再让对岸用时最短的士兵a[1]划船回来本岸
>
> 按照上述步骤进行循环，直到用时达到上限T，或者士兵全部运完。
>
> 5：有重复的子问题，那么动态规划也就顺势而出：
>
> **定义** ：dp[i] 为 第 0~i 士兵全部过河所需的最短时间。（首先肯定要对耗时数组 a 进行升序排序）  
>  **初始状态** ：
>
> 士兵总数为1，只能走到第1步：dp[0] = a[0]
>
> 士兵总数为2，只能走到第1步：dp[0] = a[1]
>
> **转移方程** ：
>
> dp[i] = min(dp[i - 1] + a[0] + get_shorter_time(a[0], a[i]),
>
> dp[i - 2] + a[0] + get_shorter_time(a[i - 1], a[i]) + a[1] +
> get_shorter_time(a[0], a[1]))
>
> **转义方程解释** ：
>
> 方案1：本岸剩余士兵个数为奇数，0~i-1 士兵都已经过河(dp[i - 1] )，此时让对岸最快的士兵回来，也就是a[0]，然后0号士兵和第 i
> 号士兵一起过河，用时a[i]。但是题目中有一个特殊条件： **当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时**
> 。如果a[0] = 1, a[i] = 20, 那么a[0] 自己划船更快a[0]*10 < a[i]，所以需要判断一下。
>
> 因此：dp[i - 1] + a[0] + get_shorter_time(a[0], a[i])
>
> 方案2：本岸剩余士兵个数为偶数，方案1就不成立了，需要回退一步，0~i-2 士兵都已经过河(dp[i - 2]
> )，此时让对岸最快的士兵回来，也就是a[0]，然后 i-1 号士兵 和i
> 号士兵划船过河（最慢的两个士兵），用时a[i]，然后对岸最快的a[1]划船回来，用时a[1]，然后0号士兵和1号士兵划到对岸，用时a[1]。同时考虑题目中的特殊条件，每次两个人过河的时候，都需要考两次一下是否一个人划船更快。
>
> 因此：dp[i - 2] + a[0] + get_shorter_time(a[i - 1], a[i]) + a[1] +
> get_shorter_time(a[0], a[1])
>
> 6：OK，说明到此结束，考试出这题，能做出来的凤毛麟角吧。我想了很久，网上也各种搜博客和相关的答案才理解的。

# 考点

> 1：动态规划

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    def get_shorter_time(a, b):
        if (a * 10 < b):
            return a * 10
        return b
    
    #处理输入
    N = int(input())
    T = int(input())
    a = [int(x) for x in input().split(" ")]
    a = sorted(a)
    
    dp = [0 for x in range(N)]
    
    skip_flag = False
    for i in range(N):
        if (i == 0):
            dp[0] = a[0]
            if (dp[0] > T):
                print("0 0")
                skip_flag = True
                break
            
        elif (i == 1):
            dp[1] = a[1]
        
        else:
            dp[i] = min(dp[i - 1] + a[i] + a[0], dp[i - 2] + a[0] + a[i] + a[1] + a[1])
        
        if (dp[i] > T):
            skip_flag = True
            print(str(i) + " " + str(dp[i - 1]))
            break
         
    
    
    if not skip_flag:
        print(str(N) + " " + str(dp[N - 1]))
    

