**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> n 行 m 列的矩阵，每个位置上有一个元素  
>  你可以上下左右行走，代价是前后两个位置元素值差的绝对值.  
>  另外，你最多可以使用一次传送阵 (只能从一个数跳到另外一个相同的数)  
>  求从走上角走到右下角最少需要多少时间。
>
> **输入描述：**
>
> 第一行两个整数n,m，分别代表矩阵的行和列。
>
> 后面n行，每行m个整数，分别代表矩阵中的元素。
>
> **输出描述：**
>
> 一个整数，表示最少需要多少时间。
>
> **示例1：**
>
> 输入：
>
> 3 3
>
> 1 2 3
>
> 4 5 6
>
> 7 8 9
>
> 输出：
>
> 8
>
> **示例2：**
>
> 输入：
>
> 3 3  
>  1 2 3  
>  4 5 6  
>  7 1 4
>
> 输出：
>
> 3

# 思路

> 1：第一眼看像是BFS，但是由于可以【传送】，所以并不好求，因为算当前点到另外一个点的最小距离的时候，会受到其他点的影响。
>
> 2：首先计算左上角到每个点需要经过的最短时间，再计算右下角到每个点经过的最短时间。
>
> ，保存方式为map，key为每个点的数字，value为最小距离。然后将两个结果对应数字相加取出最小值即可。

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    input_data = [int(x) for x in input().split(" ")]
    n = input_data[0]
    m = input_data[1]
    
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
    
    #从左上角到右下角
    left_map = {}
    left_arr = [[0 for x in range(m)] for y in range(n)]
    distance = 0
    for i in range(n):
        for k in range(m):
            if(i==0):
                if(k==0):
                    distance = 0
                    left_arr[i][k]=0
                else:
                    distance = abs(matrix[i][k]-matrix[i][k-1])+left_arr[i][k-1]
                    left_arr[i][k]=distance 
            
            if(i!=0):
                if(k==0):
                    distance =abs(matrix[i][k]-matrix[i-1][k])+left_arr[i-1][k]
                    left_arr[i][k]=distance
                else:
                    top = matrix[i-1][k]
                    left = matrix[i][k-1]
                    distance = min(abs(matrix[i][k]-top)+left_arr[i-1][k],abs(matrix[i][k]-left)+left_arr[i][k-1])
                    left_arr[i][k]=distance
                
            
    
            if(matrix[i][k] in left_map):
                left_map[matrix[i][k]] = min(left_map[matrix[i][k]],distance)
            else:
                left_map[matrix[i][k]] = distance
            
        
    
    
    #从右下角到左上角
    right_map = {}
    right_arr = [[0 for x in range(m)] for y in range(n)]
    i = n-1
    
    while(i>=0):
        k=m-1
        while(k>=0):
        
            if(i==n-1):
                if(k==m-1):
                    distance = 0
                    right_arr[i][k]=0
                else:
                    distance = abs(matrix[i][k]-matrix[i][k+1])+right_arr[i][k+1]
                    right_arr[i][k]=distance
                
            
            if(i!=n-1):
                if(k==m-1):
                    distance = abs(matrix[i][k]-matrix[i+1][k])+right_arr[i+1][k]
                    right_arr[i][k]=distance
                else:
                    bottom = matrix[i+1][k]
                    right = matrix[i][k+1]
                    distance = min(abs(matrix[i][k]-bottom)+right_arr[i+1][k],abs(matrix[i][k]-right)+right_arr[i][k+1])
                    right_arr[i][k]=distance
                
            
            if(matrix[i][k] in right_map):
                right_map[matrix[i][k]] = min(right_map[matrix[i][k]],distance)
            else:
                right_map[matrix[i][k]] = distance
            k-=1
            
        i-=1
        
        
    
    
    #相加取最小
    res = float("inf")
    for entry in left_map :
        res = min(res, left_map[entry]+right_map[entry])
    
    
    print(res)
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

