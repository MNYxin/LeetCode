**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>
> 给定一个数组，我们称其中连续的元素为连续子序列，称这些元素的和为连续子序列的和。数组中可能存在几组连续子序列，组内的连续子序列互不相交且有相同的和。求一组连续子序列，组内子序列的数目最多。输出这个数目。  
>  **输入描述:**  
>  第一行输入为数组长度 N，1 <= N <= 10^3.  
>  第二行为 N 个用空格分开的整数 Ci，-10^5 <= Ci <= 10^5.  
>  **输出描述:**  
>  第一行是一个整数 M，表示满足要求的最多的组内子序列的数目。
>
> **示例1**  
>  输入:  
>  10  
>  8 8 9 1 9 6 3 9 1 0  
>  输出:
>
> 4  
>  说明:  
>  四个子序列的第一个元素和最后一个元素的下标分别为:  
>  2 2  
>  4 4  
>  5 6  
>  7 7
>
> **示例2**  
>  输入:  
>  10  
>  -1 0 4 -3 6 5 -6 5 -7 -3  
>  输出:  
>  3  
>  说明:  
>  三个子序列的第一个元素和最后一个元素的下标分别为:  
>  3 3  
>  5 8  
>  9 9

# 思路

> 1：两个要求，第一、连续子序列和相同。第二、子序列内的数目最多。
>
> 2：我们用两个 map 数据结构来保存连续子序列的信息，key为连续子序列的和，value为该连续子序列的个数、以及最有一个元素的位置。
>
> 3：数组长度最多只有1000个，两个for循环来暴力求解所有的连续子数组也应该可行。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #处理输入
    N = int(input())
    nums = [int(x) for x in input().split(" ")]
    
    #保存每个位置到首元素的和(前缀和思想)
    pre_sum = [0 for x in range(N + 1)]
    res = 1
    #保存子序列和为key的子序列有value个
    sum_cnt = {}
    #保存子序列和为key的子序列最后一个位置
    last_pos = {}
    #两个for循环遍历所有的连续子数组
    for i in range(N):
        #连续子序列之和
        pre_sum[i + 1] = pre_sum[i] + nums[i]
        j = i
        while(j>=0):
            target = pre_sum[i + 1] - pre_sum[j]
            temp_pos = 0
            if target in last_pos:
                temp_pos = last_pos[target]
            if(temp_pos <= j):
                last_pos[target]= i+1
                if target in sum_cnt:
                    sum_cnt[target] += 1
                else:
                    sum_cnt[target] = 1
                res = max(res, sum_cnt[target])
            
            j-=1
    
    
    print(res)
        
    

