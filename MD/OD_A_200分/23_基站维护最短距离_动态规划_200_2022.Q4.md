**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 小王是一名基站维护工程师，负责某区域的基站维护。某地方有n个基站(1<n<10)，已知各基站之间的距离 s(0<s<500)
> 并且基站到基站y的距离，与基站y到基站的距离并不一定会相同。小王从基站1出发，途经每个基站1次，然后返回基站1，需要请你为他选择一条距离最短的路。  
>  **输入描述**  
>  站点数n和各站点之间的距离(均为整数)。  
>  如:  
>  3{站点数}  
>  0 2 1 {站点1到各站点的路程]  
>  1 0 2 {站点2到各站点的路程]  
>  2 1 0 (站点3到各站点的路程  
>  **输出描述**  
>  最短路Q程的数值
>
> 示例1：
>
> 输入：
>
> 3  
>  0 2 1  
>  1 0 2  
>  2 1 0  
>  输出：
>
> 3

# 思路

> 1：OJ 的原题，[P1171](https://www.luogu.com.cn/problem/P1171
> "P1171")，这个题目说实话还是很难的。
>
> 2：各种解法都有，回溯、记忆化搜索、DP等等，我介绍一个DP的吧。
>
> 3：状态定义：dp[ i ][ j ]表示当小王到达基站 i 时，所有基站访问情况为 j 的最小距离（j 为二进制状压。
>
> **状态压缩DP** ，也就是俗称的状压DP，是一种利用二进制来描述状态的DP。
>
> 这类DP一般状态数较大，如果直接存可能会爆空间，而使用状态压缩就不会有任何问题。只需要一个大小一般的十进制数就可以描述原本很复杂的状态。
>
> 举个例子，如果我们要描述一块n * n的农田的使用情况，设n =
> 9，那么我们就可以用一个九位的二进制数来描述一行的状态。可以令1表示已使用，0表示未使用这样我们只需要最多2 ^ (n + 1) - 1个十进制数就好
>
> 其实说白了，状压DP是一种很暴力的算法，因为它需要枚举所有状态，但是在一些题目中我们可以根据情景进行适当的优化，从而减少枚举的次数
>
> 对于本题来说，状态转移方程为：（m表示当前的状态）
>
> dp[i][(1 << (i - 1)) | m] = min(dp[i][(1 << (i - 1) | m)], dp[j][m] +
> a[j][i]);

# 考点

> 1：状态压缩DP

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    
    def solve(n, matrix):
    
        dp = [[float('inf') for x in range(1<<n)] for y in range(n)]
        for i in range(n):
            dp[i][1<<i]=matrix[0][i]
        
        #j为当前状态
        for j in range(1<<n):
            #i为当前基站
            for i in range(n):
                if((j&(1<<i))==0): 
                    continue  #注意运算符优先级
                #k为下一个基站
                for k in range(n):
                    dp[i][j]=min(dp[i][j], dp[k][j&(~(1<<i))]+matrix[k][i])
    
        return dp[0][(1<<n)-1];
    
    
    n = int(input())
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
    #print(matrix)
    print(solve(n, matrix))
    
    

