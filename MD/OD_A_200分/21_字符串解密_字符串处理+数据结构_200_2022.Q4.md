**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**  
>  给定两个字符串string1和string2。  
>
> string1是一个被加扰的字符串。string1由小写英文字母('a'~'z')和数字字符('0'~'9')组成，而加扰字符串由'0'~'9'、'a'~'f'组成。string1里面可能包含0个或多个加扰子串，剩下可能有0个或多个有效子串，这些有效子串被加扰子串隔开。  
>  string2是一个参考字符串，仅由小写英文字母('a'~'z')组成。  
>  你需要在string1字符串里找到一个有效子串，这个有效子串要同时满足下面两个条件:  
>  (1)这个有效子串里不同字母的数量不超过且最接近于string2里不同字母的数量，即小于或等于string2里不同字母的数量的同时且最大。  
>  (2)这个有效子串是满足条件(1)里的所有子串(如果有多个的话)里字典序，最大的一个。  
>  如果没有找到合适条件的子串的话，请输出"Not Found"
>
> **示例:**  
>  输入字符串string1为"thisisanewday111forme"，输入字符串string2为"good"。
>
>
> string1里有效子串和加扰子串分割后可表示为:"thisis"+"a"+"n"+"e"+"w"+"da"+"y"+"111f"+"orm"+"e"，去除加扰子串("a"、"e"、"da"、"111f"、"e")后的有效子串候选为("thisis"，"n"，"w""y"，"orm")。
>
>
> 输入字符串string2里不同字母的数量为3('g'、'o'、'd')，从有效子串候选里可以找出"orm"满足要求，其不同字母的数量为3，最接近于string2不同字母的数量。
>
> **输入描述:**  
>  input_string1 input_string2  
>  说明:输入为两个字符串，第1行是题目里的string1(被加扰的字符串)，第2行是题目里的strinq2(参考字符串)  
>  **输出描述:**  
>  output_string  
>  说明:输出为一个字符串(有效字符串)补充说明:  
>  输入字符串string1的长度在1~100000之间，string2的长度在1~500之间
>
> **示例1**
>
> 输入:  
>  123admyffc79pt
>
> ssyy
>
> 输出:
>
> pt  
>  说明:  
>
> 将输入字符串1里的加扰子串"123ad"、"ffc79"去除后得到有效子串序列:"my"、"pt"，其中"my"里不同字母的数量为2(有'm'和'y'两个不同字母)，"pt"里不同字母的数量为2(有'p'和't'两个不同字母);输入字符串2里不同字母的数量为2(有's'和'y'两个不同字母)。  
>  可得到最终输出结果为"pt"，其不同字母的数量最接近于"ssy"里不同字母的数量的同时字典序最大。
>
> **示例2**
>
> 输入:  
>  123admyffc79ptaagghi2222smeersst88mnrt
>
> ssyyfgh
>
> 输出:  
>  mnrt
>
> 说明:  
>
> 将输入字符串1里的加扰子串"123ad"，"ffc79"，"aa"，"2222"，"ee"，"88"去除后得到有效子串序列:"mv"、"pt"、"aahi"、"sm"."rsst""mnrt":输入字符串2里不同字母的数量
> 5(有's'、'v''f、'a'、'h'5个不同字母)。可得到最终输出结果为"mnrt"，其不同字母的数量(为4)最接近干"ssvvfah"里不同字母的数量，其他有效子串不同字母的数量都小于"mnrt"。
>
> **示例3** 输入:  
>  abcmnq
>
> rt  
>  输出:  
>  Not Found
>
> 说明:
>
>
> 将输入字符串1里的加扰子串"abc"去除后得到有效子串序列:"mna":输入字符串2里不同字母的数量为2(有”"两个不同的字母)。可得到最终的输出结果为"Not
> Found"，没有符合要求的有效子串，因有效子串的里不同字母的数量(为3)，大于输入字符串2里的不同字母的数量

# 思路

> 1：看懂题目之后就挺简单的，主要是两个规则的实现，字符串的去重计数以及字符判断。
>
> 2：一些简单的数据结构set的操作要熟悉

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    import re
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    #字符串去重后个数
    def distinct_length(s):
        str_set = set()
        for c in s:
            str_set.add(c)
        return len(str_set)
    
     
    #处理输入
    valids = re.split(r"[0-9a-f]+", input())
    count = len(set(input()))
    
    result = list(filter(lambda valid: valid != "" and len(set(valid)) <= count, valids))
    
    if len(result) > 0:
        result.sort(key=lambda x: (-len(set(x)), [-ord(char) for char in x]))
        print(result[0]) 
    else:
        print("Not Found")
    
    
    

