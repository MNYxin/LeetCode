**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>  给你一个整数M和数组N，N中的元素为连续整数，要求根据N中的元素组装成新的数组R，组装规则:  
>  1.R中元素总和加起来等于M  
>  2.R中的元素可以从N中重复选取  
>  3.R中的元素最多只能有1个不在N中，且比N中的数字都要小(不能为负数)  
>  **输入描述**  
>  第一行输入是连续数组N，采用空格分隔第二行输入数字M  
>  **输出描述**  
>  输出的是组装办法数量，int类型
>
> **备注**  
>  1≤M≤30  
>  1 ≤ N.length ≤ 1000
>
>  
> **示例1**  
>  输入  
>  2  
>  5
>
> 输出
>
> 1
>
> 说明  
>  只有1种组装办法，就是[2,2,1]
>
> **示例2**  
>  输入  
>  2 3  
>  5  
>  输出  
>  2
>
> 说明  
>  共两种组装办法，分别是[2,2,1]，[2,3]

# 思路

> 1：第三个规则就是迷惑项，说的有点绕，另外一个元素可以随便补的意思就是，从N中任意选取元素，使得元素之和sum满足下面的条件：
>
> M - min(N) < sum ≤ M
>
>
> 2：这样转换完了之后，其实就转变成了一个leetcode上的原题：[组合总数](https://leetcode.cn/problems/combination-
> sum/ "组合总数")。
>
> 3：简单的回溯算法，选择数字，直到满足条件停止回溯。

# 考点

> 1：回溯算法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #处理输入
    nums = [int(x) for x in input().split(" ")]
    m = int(input())
    #排序找到最小值
    nums = sorted(nums)
    min_num = nums[0]
            
    def dfs(nums, index, num_sum, count):
            if (num_sum > m):
                return count
            #满足边界条件+1
            if (num_sum <= m and m - min_num < num_sum):
                return count + 1
        
            for i in range(index, len(nums)):
                count = dfs(nums, i, num_sum + nums[i], count)
        
            return count
    
    print(dfs(nums, 0, 0, 0))
    
    
    
    
    
    

