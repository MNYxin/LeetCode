**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>
> 大众对垃圾短信深恶痛绝，希望能对垃圾短信发送者进行识别，为此，很多软件增加了垃圾短信的识别机制。经分析，发现正常用户的短信通常具备交互性，而垃圾短信往往都是大量单向的短信，按照如下规则进行垃圾短信识别:  
>  本题中，发送者A符合以下条件之一的，则认为A是垃圾短信发送者:  
>  1：A发送短信的接收者中，没有发过短信给A的人数L> 5;  
>  2：A发送的短信数 -A接收的短信数M > 10;  
>  3：如果存在X，A发送给X的短信数 - A接收到X的短信数N >5.  
>  **输入描述**  
>  第一行是条目数，接下来几行是具体的条目，每个条目，是一对D，第一人数字是发送者ID，后面的数字是接收者ID，中间空格隔开，所有的ID都为
> 无符号整型Q，ID最大值为100:  
>  同一个条目中，两个ID不会相同 (即不会自己给自己发消息)  
>  最后一行为指定的ID
>
> 输出描述  
>  输出该ID是否为垃圾短信发送者，并且按序列输出 L M 的值(由于 N 值不唯一，不需要输出)输出均为字符串。
>
> 示例1：
>
> 输入  
>  15
>
> 1 2
>
> 1 3
>
> 1 4
>
> 1 5
>
> 1 6
>
> 1 7
>
> 1 8
>
> 1 9  
>  1 10  
>  1 11  
>  1 12  
>  1 13  
>  1 14  
>  14 1  
>  1 15
>
> 1  
>  输出  
>  true 13 13
>
> 说明  
>  true 表示1是垃圾短信发送者，两个数字，代表发送者1对应的L和M值。true 13 13中间以一个空格分割。注意true是字符电输出
>
> 示例2：
>
> 输入
>
> 15
>
> 1 2
>
> 1 3
>
> 1 4
>
> 1 5
>
> 1 6
>
> 1 7
>
> 1 8
>
> 1 9  
>  1 10  
>  1 11  
>  1 12  
>  1 13  
>  1 14  
>  14 1  
>  1 15
>
> 2  
>  输出  
>  false 0 -1

# 思路

>
> 1：核心就是统计出题目中的三个指标L、M、N，因此主要是求得每个人发送和接收的信息，因为题目中已经指定好ID，所以只要求这个人的发送和接受短信的信息即可。
>
> 2：具体需要统计的逻辑其实比较简单，按照题目中的逻辑来即可。
>
> 3：考察的还是数据结构的使用。
>
> **4：最大就100，直接暴力法。**

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    def get_shorter_time(a, b):
        if (a * 10 < b):
            return a * 10
        return b
    
    #处理输入
    n = int(input())
     
    id_pairs = []
    data = [[0 for x in range(100)] for x in range(100)]
    for i in range(n):
        pair = [int(x) for x in input().split(" ")]
        data[pair[0]][pair[1]] += 1
    
    id = int(input())
    
    L=0
    M1=0
    M2=0
    flag = False
    for i in range(100):
        if(data[id][i]>0 and data[i][id]==0):
            L+=1
        
        M1+=data[id][i]
        M2+=data[i][id]
        if(data[id][i]-data[i][id] > 5):
            flag = True
    
    if(L>5 or M1-M2>10):
        flag = True
    
    
    print(str(flag) + " " + str(L) + " " + str(M1-M2))

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

