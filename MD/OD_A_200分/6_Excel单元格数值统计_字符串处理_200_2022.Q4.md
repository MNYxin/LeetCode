**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **_Excel_** 工作表中对选定区域的数值进行统计的功能非常实用。  
>  仿照Excel的这个功能，请对给定表格中选中区域中的单元格进行求和统计，并输出统计结果。  
>  为简化计算，假设当前输入中每个单元格内容仅为数字或公式两种。  
>  ● 如果为数字，则是一个非负整数，形如3、77  
>  ● 如果为公式，则固定以=开头，且仅包含下面 **三种情况** ：
>
> 1.等于某单元格的值，例如=B12  
>  2.两个单元格的双目运算（仅为+或-），形如=C1-C2、C3+B2  
>  3.单元格和数字的双目运算（仅为+或-），形如=B1+1、100-B2
>
> **注意：**
>
>   1. 公式内容都是合法的，例如不存在，=C+1、=C1-C2+B3,=5、=3+5
>   2. 不存在循环引用，例如A1=B1+C1、C1=A1+B2
>   3. 内容中不存在空格、括号
>

>
> **输入描述：**
>
> 第一行两个整数rows cols，表示给定表格区域的行数和列数，1<=rows<=20，1<=cols<=26。  
>  接下来rows行，每行cols个以空格分隔的字符串，表示给定表格values的单元格内容。  
>  最后一行输入的字符串，表示给定的选中区域，形如A1:C2。
>
> **输出描述：**
>
> 一个整数，表示给定选中区域各单元格中数字的累加总和，范围-2,147,483,648 ~ 2,147,483,647
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `1 3`  
> `1 =A1+C1 3`  
> `A1:C1`
>
> **输出**
>
> `8`
>
> **备注：**  
>  表格的行号1~20，列号A~Z，例如单元格B3对应values[2][1]。
>
> * * *
>
> ![](https://img-
> blog.csdnimg.cn/img_convert/4585483a26a9b70c86f9b1f6d4c23e00.png)

# 思路

> 1：由于题目中限制了只可能出现的三种情况，合法情况下，就处理一下字符串，把这三种情况的分支都实现一下就可以了。
>
> 2：其实把A~Z都转换为数字，把它当成一个二维矩阵看就行了。

# 考点

> 1：字符串处理

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
     
     
    #处理输入
    params = [int(x) for x in input().split(" ")]
    rows = params[0]
    cols = params[1]
    
    matrix = []
    for i in range(rows):
        matrix.append([x for x in input().split(" ")])
    
    #先将表达式都转为数字
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j][0] == '=':
                if '+' in matrix[i][j]:
                    op1 = matrix[i][j].split("+")[0]
                    op2 = matrix[i][j].split("+")[1]
                    #如果为纯数字，直接取即可
                    if op1[1:].isdigit():
                        num1 = int(op1[1:])
                    else:
                        #否则到excel中取到对应位置的数字
                        num1 = int(matrix[int(op1[2:]) - 1][ord(op1[1])-65])
    
                    if op2.isdigit():
                        num2 = int(op2)
                    else:
                        num2 = int(matrix[int(op2[1:])-1][ord(op2[0])-65])
    
                    matrix[i][j] = num1 + num2;
                elif '-' in matrix[i][j]:
                    op1 = matrix[i][j].split("-")[0]
                    op2 = matrix[i][j].split("-")[1]
    
                    if op1[1:].isdigit():
                        num1 = int(op1[1:])
                    else:
                        num1 = int(matrix[int(op1[2:]) - 1][ord(op1[1])-65])
    
                    if op2.isdigit():
                        num2 = int(op2)
                    else:
                        num2 = int(matrix[int(op2[1:])-1][ord(op2[0])-65])
    
                    matrix[i][j] = num1-num2
                else:
                    matrix[i][j] = int(matrix[int(matrix[i][j][2:]) - 1][ord(matrix[i][j][1])-65]);
    
    
    #输出表达式解析
    output = [x for x in input().split(":")]
    res = 0
    for i in range(int(output[0][1:])-1, int(output[1][1:])):
        for j in range(ord(output[0][0])-65, ord(output[1][0])-65+1):
            res += int(matrix[i][j])
    
     
    print(res)

