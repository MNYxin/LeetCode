**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 信号传播过程中会出现一些误码，不同的数字表示不同的误码ID，取值范围为1~65535，用一个数组记录误码出现的情况，  
>  每个误码出现的次数代表误码频度，请找出记录中包含频度最高误码的最小子数组长度。
>
> **输入描述**
>
> 误码总数目：取值范围为0~255，取值为0表示没有误码的情况。  
>  误码出现频率数组：误码ID范围为1~65535，数组长度为1~1000。
>
> **输出描述**
>
> 包含频率最高的误码最小子数组长度
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `5`
>
> `1 2 2 4 1`
>
> **输出**
>
> `2`
>
> **说明**
>
> 频度最高的有1和2，他们的频度均为2.
>
> 可能的记录数组为[2,2]和 [1,2,2,4,1]
>
> 最短的长度为2.
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `7  
>  1 2 2 4 2 1 1`
>
> **输出**
>
> `4`
>
> **说明**
>
> 最短的为[2,2,4,2]

# 思路

>
> 1：很明显，第一步要找出误码频度最高的数字，找到以后我们想要子数组的长度，那么就需要它出现第一次的位置和最后一次的位置，所以还需要一个数据结构来保存每一个数字出现的第一次的位置和最后一次的位置。
>
> 2：找出频度最高的数字之后，就是比较他们这两次出现次数之间的差值大小了。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    
    # 处理输入
    n = int(input())
    
    nums = [int(x) for x in input().split(" ")]
    
    #计算频度最高的数字
    max_count = 0;
    num_count = {}
    for i in range(n):
        if nums[i] in num_count:
            num_count[nums[i]] = num_count[nums[i]] + 1
        else:
            num_count[nums[i]] = 1
        
        max_count = max(max_count, num_count[nums[i]])
    
    
    max_num = set([])
    for item in  num_count:
        if num_count[item] == max_count:
            max_num.add(item)
    
    
    
    #找到第一次和最后一次出现位置
    result = n;
    for i in max_num:
        left = 0
        right = n - 1
        while (nums[left] != i):
            left+=1
        
        while (nums[right] != i):
            right-=1
        
        if (left <= right) :
            result =min(result, right - left + 1)
    
    print(result)

