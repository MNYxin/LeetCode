**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定一组数字，表示扑克牌的牌面数字，忽略扑克牌的花色，请按如下规则对这一组扑克牌进行整理:
>
> **步骤1、** 对扑克牌进行分组，形成组合牌，规则如下:当牌面数字相同张数大于等于4时，组合牌为“炸弹”:3张相同牌面数字 +
> 2张相同牌面数字，且3张牌与2张牌不相同时，组合牌为“葫芦”  
>  3张相同牌面数字，组合牌为“三张”  
>  2张相同牌面数字，组合牌为“对子”  
>  剩余没有相同的牌，则为“单张”:  
>  **步骤2、** 对上述组合牌进行由大到小排列，规则如下:不同类型组合牌之间由大到小排列规则:“炸弹” >"葫芦”>"三张”>"对子”>
> “单张”:相同类型组合牌之间，除“葫芦”外，按组合牌全部牌面数字加总由大到小排列:"葫芦”则先按3张相同牌面数字加总由大到小排列，3张相同牌面数字加总相同时，再按另外2张牌面数字加总由大到小排列;  
>  **由于“葫芦”
> >“三张”，因此如果能形成更大的组合牌，也可以将“三张”拆分为2张和1张，其中的2张可以和其它“三张”重新组合成“葫芦”，剩下的1张为“单张”**
>
> **步骤3、** 当存在多个可能组合方案时，按如下规则排序取最大的一个组合方案:依次对组合方案中的组合牌进行大小比较，规则同上:当组合方案A中的
> **第n个组合牌** 大于组合方案B中的第n个组合牌时，组合方案A大于组合方案B;  
>  **输入描述:**  
>  第一行为空格分隔的N个正整数，每个整数取值范围[1,13]，N的取值范围[1,1000]
>
> **输出描述:**  
>  经重新排列后的扑克牌数字列表，每个数字以空格分隔
>
> **示例1**  
>  输入:  
>  1 3 3 3 2 1 5  
>  输出:  
>  3 3 3 1 1 5 2  
>  示例2  
>  输入:  
>  4 4 2 1 2 1 3 3 3 4  
>  输出:  
>  4 4 4 3 3 2 2 1 1 3

# 思路

> 1：虽然题目很长，但是还是比较简单的一道题。
>
> 2：就是张数多的在前面，张数一样的，点数大的在前面。单牌的话按点数大小排序
>
> 3：还有一个特殊情况就是葫芦（3张+2张）在前面，就像在示例2中，不是 4 4 4 3 3 3， 因为4 4 4 3 3是一个葫芦，所以要把3拆开。
>
> 4：考察的还是数据结构+排序。

# 考点

> 1：数据结构
>
> 2：排序

# Code

code1:这能满分我是没想到，连用例都过不了。。。

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    def cmp1(a, b):
        return b[0] * b[1] - a[0] * a[1]
    
    
    def cmp2(a, b):
        return int(b)-int(a)
     
    #处理输入
    nums = [int(x) for x in input().split(" ")]
     
    cards =[0 for i in range(14)]
    for num in nums:
        cards[num]+=1
    
    boomb = []
    i = 13
    while (i >= 1):
        if (cards[i] >= 4):
            cards[i] -= 4
            temp_str = str(i)
            boomb.append(temp_str + temp_str + temp_str + temp_str)
            continue
        i-=1
    
    boomb.sort(key=functools.cmp_to_key(cmp2))
    
    three_cards = []
    i = 13
    while (i >= 1):
        if (cards[i] >= 3):
            cards[i] -= 3
            temp_str = str(i)
            three_cards.append(temp_str + temp_str + temp_str)
            continue
        i-=1
    
    
    two_cards = []
    i = 13
    while (i >= 1):
        if (cards[i] >= 2):
            cards[i] -= 2
            temp_str = str(i)
            two_cards.append(temp_str + temp_str)
            continue
        i-=1
    
    
    single_cards = []
    i = 13
    while (i >= 1):
        if (cards[i] >= 1):
            cards[i] -= 1
            temp_str = str(i)
            single_cards.append(temp_str)
            continue
        i-=1
    
    hulu = []
    size = min(len(three_cards), len(two_cards))
    for j in range(size):
        hulu.append(three_cards[0] + two_cards[0])
        three_cards.pop(0)
        two_cards.pop(0)
    
    
    result = []
    
    for item in boomb + hulu + three_cards + two_cards + single_cards:
        for single_char in item:
            result.append(single_char)
    print(" ".join(result))
        
    

code2:

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    def cmp1(a, b):
        return b[0] * b[1] - a[0] * a[1]
    
    
    def cmp2(a, b):
        return b-a
     
    #处理输入
    nums = [int(x) for x in input().split(" ")]
     
    #key为牌面点数，value为该点数的张数
    card_info = {}
    for num in nums:
        if num in card_info:
            card_info[num] += 1
        else:
            card_info[num] = 1
     
    
    card_type = {"4": [],"3+2": [],"3": [],"2": [],"1": []}
        
    for card in card_info:
        if (card_info[card] == 3): 
            card_type["3"].append(card)
        elif (card_info[card] == 2):
            card_type["2"].append(card)
        elif (card_info[card] == 1):
            card_type["1"].append(card)
        else:
            card_type["4"].append([card, card_info[card]]) 
    
        
        
    # 排序
    card_type["4"] = sorted(card_type["4"], key=functools.cmp_to_key(cmp1))
    card_type["3"] = sorted(card_type["3"], key=functools.cmp_to_key(cmp2))
    card_type["2"] = sorted(card_type["2"], key=functools.cmp_to_key(cmp2))
    
    while (len(card_type["3"])):
        if (len(card_type["2"]) == 0 and  len(card_type["3"]) == 1):
            break
    
        san_top = card_type["3"][0]
        card_type["3"].pop(0)
    
        if (len(card_type["2"]) == 0  or (len(card_type["3"]) >= 1 and card_type["3"][0] > card_type["2"][0])):
            tmp = card_type["3"][0]
            card_type["3"].pop(0)
            card_type["1"].append(tmp)
        else:
            tmp = card_type["2"][0]
            card_type["2"].pop(0)
        
        card_type["3+2"].append([san_top, tmp])
    
    card_type["1"] = sorted(card_type["1"], key=functools.cmp_to_key(cmp2))
    
    result = []
    
    for card in card_type["4"]:
        result.append([card[0] for x in range(card[1])])
    
    for card in card_type["3+2"]:
        [san, er] = card
        result.append([card[0] for x in range(3)])
        result.append([card[1] for x in range(2)])
    
    for card in card_type["3"]:
        result.append([card for x in range(3)])
    
    
    for card in card_type["2"]:
        result.append([card for x in range(2)])
    
    
    result.append(card_type["1"])
    
    
    print(" ".join([str(",".join([str(i) for i in x])) for x in result]))

