**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**  
>
> 有一个二维的天线矩阵，每根天线可以向其他天线发射信号也能接收其他天线的信号，为了简化起见，我们约定每根天线只能向东和向南发射信号，换言之，每根天线只能接收东向或南向发送的信号。
>
> 每根天线有自己的高度anth，各根天线的高度存储在一个二维数组中，各个天线的位置用[r,
> c]表示，r代表天线的行位置(从0开始编号)，c代表天线的列位置(从0开始编号)  
>
> 在某一方向(东向或南向)，某根天线可以收到多根其他天线的信号(也可能收不到任何其他天线的信号)，对任一天线X和天线Y，天线X能接收到天线Y的信号的条件是:
>
> **(1)天线X在天线Y的东边或南边;**
>
> **(2)天线X和天线Y之间的其他天线的高度都低于天线X和天线Y，或天线X和天线Y之间无其他天线，即无遮挡。**  
>  如下图示意:在天线矩阵的第0行上，
> 天线[0,0]接收不到任何其他天线的信号，天线[0,1]可以接收到天线[0.0]的信号，天线[02]可以接收到天线[0,1]的信号，天线[0,3]可以接收到天线[0,1]和天线10.2]的信号，天线[0.4l可以接收到天线[0.3l的信号，天线10.51可以接收到天线[0.4l的信号;在天线矩阵的第0列上，天线[0,0]接收不到任何其他天线的信号，天线[1,0]可以接收到天线[0,0]的信号,天线[2.0]可以接收到天线[1.0]的信号，天线[3.0]可以接收到天线[1.0]和天线[2.0]的信号，天线[4.0]可以接收到天线[3,0]的信号，天线[5,0]可以接收到天线[3,0]和天线[4,0]的信号
>
> ![](https://img-blog.csdnimg.cn/732617c4447241b4aea2ea62a9647c8c.jpeg)
>
> 给一个m行n列的矩阵(二维数组)，矩阵存储各根天线的高度 求出每根天线可以收到多少根其他天线的信号，结果输出到m行n列的矩阵(二维数组)中。
>
> **输入描述:**  
>  输入为1个m行n列的矩阵(二维数组)anthh[m][n]，矩阵存储各根天线的高度，高度值anthh[r][c]为大于0的整数。具体示例如下:  
>  第1行为输入矩阵的行数和列数
>
> m n  
>  第2行为输入矩阵的元素值，按行输入
>
> anth[0][0]anth[0][1]…anth[0][n-1] anth[1][0]anth[1][1] … anth[1]n-1] .…
> anth[m-1][0] .…. anth[m-1][n-1]  
>  **输出描述:**  
>  输出1个m行n列的矩阵(二维数组)ret[m][n]，矩阵存储每根天线能收到多少根其他天线的信号，根数为ret[r][c]。具体示例如下:
>
> 第1行为输出矩阵的行数和列数
>
> m n  
>  第2行为输出矩阵的元素值，按行输出
>
> ret[0][0] ret[0][1] … ret[0][n-1] ret[1][0] ret[1][1] .… ret[1][n-1] .…
> ret[m-1][0] ... ret[m-1][n-1]  
>  补充说明:  
>  1 <= m <= 500  
>  1 <= n <= 500  
>  0 <ant[r][c] < 10^5
>
> **示例1**
>
> 输入:  
>  1 6  
>  2 4 1 5 3 3
>
> 输出:  
>  1 6  
>  0 1 1 2 1 1
>
> **示例2**
>
> 输入:  
>  2 6  
>  2 5 4 3 2 8 9 7 5 10 10 3  
>  输出:  
>  2 6  
>  0 1 1 1 1 4 1 2 2 4 2 2

# 思路

> 1：m,n 都不大，应该可以直接暴力法解决问题。
>
> 2：本题的核心就是接受到信号的两个条件，那么我们就按照向题目要求的东向和南向直接暴力遍历每一对天线组合，判定是否能够接收到信号即可。
>
> 3：题目有点长，耐心看完。

# 考点

> 1：数组

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
    
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    origin_anth = [int(x) for x in input().split(" ")]
    row_count = params[0]
    col_count = params[1]
        
    anth = []
    for i in range(row_count):
        temp = []
        for j in range(col_count):
            temp.append(origin_anth[i*col_count + j])
        anth.append(temp)
    #print(anth)
    
    #东向判断,其实是以当前天线向西遍历判断
    def east(anth, i, j):
        #第0根天线肯定无法接收信号
        if(j==0):
            return 0
        
        max_height = anth[i][j-1] 
        # 当前天线的西侧第一根天线必然可以接收
        count = 1 
    
        k = j-2 
        while(k>=0):
            if(max_height >= anth[i][j]): 
                break
            if(anth[i][k]>max_height):  
                count+=1
                max_height = anth[i][k]
            k -= 1
        return count
    
    
    #南向判定，其实是以当前天线向北遍历判断
    def south(anth, i, j):
        #第0根天线肯定无法接收信号
        if(i==0):
            return 0
    
        max_height = anth[i-1][j]  
        # 当前天线的北侧第一根天线必然可以接收
        count = 1    
    
        k = i-2 
        while(k>=0):
            if(max_height >= anth[i][j]):  
                break
            if(anth[k][j]>max_height):   
                count+=1
                max_height = anth[k][j]
            k-=1
        return count
    
    
    #遍历每一个天线
    res = []
    for i in range(row_count):
        for j in range(col_count):
            res.append(str(south(anth,i,j) + east(anth,i,j))) 
    
    
    # 输出
    print(str(row_count) + " " + str(col_count))
    print(" ".join(res))
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

