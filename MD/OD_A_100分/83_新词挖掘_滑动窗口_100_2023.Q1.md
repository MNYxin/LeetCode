**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述：**
>
> 小华负责公司知识图谱产品，现在要通过新词挖掘完善知识图谱新词挖掘:
> 给出一个待挖掘问题内容字符串Content和一人词的字符串word，找到content中所有word的新词。新词:
> 使用词word的字符排列形成的字符串。  
>  请帮小华实现新词挖掘，返回发现的新词的数量。  
>  **输入描述**  
>  第一行输入为待挖掘的文本内容content;  
>  第二行输入为词word;  
>  **输出描述**  
>  在content中找到的所有word的新词的数量
>
> 备注  
>  0 ≤ content的长度 ≤10000000。
>
> 1 ≤ word的长度≤2000。
>
> **示例1：**
>
> 输入  
>  qweebaewqd  
>  qwe
>
> 输出  
>  2
>
> 说明  
>  起始索引等于0的子串是“qwe”，它是word的新词起始索引等于6的子串是“ewg”，它是word的新词
>
> **示例2：**
>
> 输入
>
> abab  
>  ab
>
> 输出  
>  3
>
> 说明  
>  起始索引等于0的子串是”ab“它是word的新词它是word的新词起始索引等于1的子串是”ba“起始索引等于2的子串是”ab“，它是word的新词

# 思路

> 1：和[leetcode76 ](https://leetcode.cn/problems/minimum-window-substring/
> "leetcode76 ")上面的这一道题很像，但是输出要求有所区别。
>
> 2：其实考察的就是hash的数据结构，很直观的做法是：
>
> 1）先分析word中的字符有有哪些，每种字符出现了多少次。用一个hashmap结构来保存
>
> 2）遍历content中每个长度为m的子串（滑动窗口），统计字符，然后与word的统计结果对照。
>
>
> 这种解法时间复杂度是O（2*n+m），但要做统计的对照，所以时间复杂度还与字符种类有关。若只有26个小写字母，时间复杂度就是O（26*2n+m）。其实也是常数级别
>
> 但是，这个 26 的系数可以优化掉：
>
> 用一个整数N表示word中字符的种类数；用整数M表示，在content中长度为m的子串出现次数不少于在word中出现次数的字符的种数。  
>  遍历content中每个长度为m的子串时，当前子串的统计结果，只是在上一次统计结果的基础上添加和去掉一个元素。
>
> 去掉一个字符ch，若去掉前，ch出现的次数正好等于在word中出现的次数，那么--M。
>
>
> 添加一个字符ch，若添加后，ch出现的次数正好等于在word中出现的次数，（表示content子串中这个字符出现的次数和word中出现次数一致）那么++M。
>
> 若M == N，那么就在content中找到了一个word的全排列子串。
>
> 这样，不论字符的总类有多少，时间复杂度总是O（2n+m）。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def contin(content, word):
        if(len(content) < len(word)):
            return 0
        if(len(word) == 0):
            return 0
        content_map = {}
        word_map = {}
        #先统计出word中的字符组成
        for ch in word:
            if ch in word_map:
                word_map[ch] += 1
            else:
                word_map[ch] = 1
    
        word_char_kind = len(word_map.keys())
        right = 0
        content_child_char_kind = 0
        result = 0
        while(right < len(content)):
            if(right >= len(word)):
                left = right - len(word)
                if content[left] in word_map and content_map[content[left]] == word_map[content[left]]:		
                    content_child_char_kind -= 1
                content_map[content[left]] -= 1
            if content[right] in content_map:
                content_map[content[right]] += 1
            else:
                content_map[content[right]] = 1
    
            if content[right] in word_map and content_map[content[right]] == word_map[content[right]]:
                content_child_char_kind+=1
            right += 1
            if (content_child_char_kind == word_char_kind):
                result += 1
    
        return result
    
    
    #处理输入
    content = input()
    word = input()
    
    print(contin(content, word))
    
    
    
    
    
    

