**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 某公司研发了一款高性能AI处理器。每台物理设备具备8颗 **AI** 处理器，编号分别为0、1、2、3、4、5、6、7。
>
> **编号0-3的处理器处于同一个链路中，编号4-7的处理器处于另外一个链路中** ，不同链路中的处理器不能通信。
>
> 现给定服务器可用的处理器编号数组array，以及任务申请的处理器数量num，找出符合下列亲和性调度原则的芯片组合。
>
> 如果不存在符合要求的组合，则返回 **空列表** 。
>
> **亲和性调度原则：**
>
> -如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。
>
> -如果申请处理器个数为2，则选择同一链路剩余可用的处理器数量2个的为最佳，其次是剩余4个，最后是剩余3个。
>
> -如果申请处理器个数为4，则必须选择同一链路剩余可用的处理器数量为4个。
>
> -如果申请处理器个数为8，则申请节点所有8个处理器。
>
> **提示：**
>
>   1. **任务申请的处理器数量只能是1、2、4、8。**
>   2. 编号0-3的处理器处于一个链路，编号4-7的处理器处于另外一个链路。
>   3. 处理器编号唯一，且不存在相同编号处理器。
>

>
> **输入描述**
>
> 输入包含可用的处理器编号数组array，以及任务申请的处理器数量num两个部分。
>
> 第一行为array，第二行为num。例如：
>
> `[0, 1, 4, 5, 6, 7]`
>
> 表示当前编号为0、1、4、5、6、7的处理器可用。任务申请1个处理器。
>
> `0 <= array.length <= 8`
>
> `0 <= array[i] <= 7`
>
> `num in [1, 2, 4, 8]`
>
> **输出描述**
>
> 输出为组合列表，当array=[0，1，4，5，6，7]，num=1 时，输出为[[0], [1]]。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `[0, 1, 4, 5, 6, 7]`
>
> `1`
>
> **输出**
>
> `[[0], [1]]`
>
> **说明**
>
> 根据第一条亲和性调度原则，在剩余两个处理器的链路（0, 1, 2, 3）中选择处理器。
>
> 由于只有0和1可用，则返回任意一颗处理器即可。

# 思路

> 1：喜欢出语文阅读理解题。。。。
>
> ![](https://img-blog.csdnimg.cn/0805d64ff759416a93c5f3b665f776c4.jpeg)
>
> 2：先分析下题目和用例，0~3属于链路1，4~7属于链路2。
>
> 如果选1个处理器，则需要按照亲和性调度原则
>
> 如果申请处理器个数为1，则选择同一链路， **剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个** 。
>
> 最佳的是，找剩余可用1个处理器的链路，发现没有，link1剩余可用2，link2剩余可用4
>
> 其次的是，找剩余可用3个处理器的链路，发现没有
>
> 再次的是，找剩余可用2个处理器的链路，link1符合要求，即从0和1处理器中任选一个。
>
> 返回0和1的数组
>
> 3：对于这么几个规则，需要逐个写分支来实现，使劲儿写 if else 吧。

# 考点

> 1：耐心
>
> 2：耐心
>
> 3：耐心

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
    
    # 处理输入
    v = [int(x) for x in input()[1:-1].split(",")]
    
    #初始化两个链路剩余可用的处理器
    processors_1 = []
    processors_2 = []
    for x in v:
        if (x >= 4):
            processors_2.append(x)
        else:
            processors_1.append(x)
        
    
    
    length_1 = len(processors_1)
    length_2 = len(processors_2)
    
    # 申请的处理器个数
    apply_num = int(input())
    
    #满足条件结果组合
    result = []
    
    def dfs(batch_processor,index, level, path):
        if (len(path) == level):
            result.append(copy.copy(path))
            return 
        
        
        for i in range(index, len(batch_processor)):
            path.append(batch_processor[i])
            # 逐个往后找合适的组合
            dfs(batch_processor, i + 1, level, path)
            path.pop()
        
    
    
    def get_combo(batch_processor, num):
        path=[]
        dfs(batch_processor, 0, num, path)
    
    
    if (apply_num == 1):
        # 原则1
        if (length_1 == 1 or length_2 == 1):
            if (length_1 == 1): 
                get_combo(processors_1, 1)
            if (length_2 == 1): 
                get_combo(processors_2, 1)
        elif (length_1 == 3 or length_2 == 3):
            if (length_1 == 3): 
                get_combo(processors_1, 1)
            if (length_2 == 3): 
                get_combo(processors_2, 1)
        elif (length_1 == 2 or length_2 == 2):
            if (length_1 == 2): 
                get_combo(processors_1, 1)
            if (length_2 == 2): 
                get_combo(processors_2, 1)
        elif (length_1 == 4 or length_2 == 4):
            if (length_1 == 4): 
                get_combo(processors_1, 1)
            if (length_2 == 4): 
                get_combo(processors_2, 1)
    
    elif (apply_num == 2):
        # 原则2
        if (length_1 == 2 or length_2 == 2):
            if (length_1 == 2): get_combo(processors_1, 2)
            if (length_2 == 2): get_combo(processors_2, 2)
        elif (length_1 == 4 or length_2 == 4):
            if (length_1 == 4): get_combo(processors_1, 2)
            if (length_2 == 4): get_combo(processors_2, 2)
        elif (length_1 == 3 or length_2 == 3):
            if (length_1 == 3): get_combo(processors_1, 2)
            if (length_2 == 3): get_combo(processors_2, 2)
        
    elif (apply_num == 4):
        # 原则3
        if (length_1 == 4 or length_2 == 4):
            if (length_1 == 4): result.append(processors_1)
            if (length_2 == 4): result.append(processors_2)
        
    elif (apply_num == 8):
        # 原则4
        if (length_1 == 4 and length_2 == 4):
            processors_2 = processors_2 + processors_1
            result.append(processors_2)
        
    result = [str(x) for x in result]
    print("[" +", ".join(result)+ "]")
    
    
    

