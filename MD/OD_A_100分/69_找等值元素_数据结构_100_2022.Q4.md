**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**  
>  给一个二维数组nums，对于每一个元素num[i]，找出距离最近的且值相等的元素，输出横纵坐标差值的绝对值之和，如果没有等值元素，则输出-1。  
>  例如:  
>  输入数组nums为  
>  0 3 5 4 2  
>  2 5 7 8 3  
>  2 5 4 2 4  
>  对于 num[0][0] = 0，不存在相等的值。  
>  对于 num[0][1] = 3，存在一个相等的值，最近的坐标为num[1][4]，最小距离为4.  
>  对于 num[0][2] = 5，存在两个相等的值，最近的坐标为num[1][1]，故最小距离为2.  
>  对于 num[1][1] = 5，存在两个相等的值，最近的坐标为num[2][1]，故最小距离为1。  
>  故输出为  
>  -1 4 2 3 3  
>  1 1 -1 -1 4  
>  1 1 2 3 2
>
> **输入描述:**  
>  输入第一行为二维数组的行，输入第二行为二维数组的列输入的数字以空格隔开。  
>  **输出描述:**  
>  数组形式返回所有坐标值。  
>  补充说明:  
>  1.针对数组num[i][j]，满足0<i<=100: 0<i<=100.  
>  2.对于每个数字，最多存在100个与其相等的数字
>
> **示例1**  
>  输入:  
>  3  
>  5  
>  0 3 5 4 2  
>  2 5 7 8 3  
>  2 5 4 2 4  
>  输出:  
>  [-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]]  
>  解题思路:  
>  1.将二维数组中的值和坐标转化为map对象.  
>  2.遍历二维数组中的值，找出其值的所有坐标，求出其中距离最短的值

# 思路

> 1：目标就是找同值元素，怎么找的快呢，那肯定是map结构啊，key保存元素值，value保存所处位置的list。最后求出最短距离即可。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    n = int(input())
    m = int(input())
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
    
    num_map = {}
    for i in range(n):
        for j in range(m):
            #将坐标转化为数组
            pos = [i, j]  
            if(matrix[i][j] in num_map):
                num_map[matrix[i][j]].append(pos)
            else:
                num_map[matrix[i][j]] = []
                num_map[matrix[i][j]].append(pos)
    
    
    resList = [];
    for i in range(n):
        temp_list = []
        for j in range(m):
            pos_list = num_map[matrix[i][j]]
            #无相等值
            if(len(pos_list) == 1):  
                temp_list.append(-1);
                continue;
            
    
            min_distance = float("inf");
            for k in range(len(pos_list)):
                pos = pos_list[k]
                distance = abs(pos[0]-i) + abs(pos[1]-j);  
                #距离为0则跳过
                if(distance == 0): 
                    continue
                min_distance = min(min_distance, distance);
            
    
            temp_list.append(min_distance)
    
        resList.append(temp_list);
    
    
    print(resList);
    
    

