**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 游戏里面，队伍通过匹配实力相近的对手进行对战。但是如果匹配的队伍实力相差太大，对于双方游戏体验都不会太好。  
>
> 给定n个队伍的实力值，对其进行两两实力匹配，两支队伍实例差距在允许的最大差距d内，则可以匹配。要求在匹配队伍最多的情况下匹配出的各组实力差距的总和最小。
>
> **输入描述**  
>  第一行两个整数，n，d。队伍个数n。允许的最大实力差距d。  
>  2<=n <=50  
>  0<=d<=100
>
> 第二行，n个整数，表示队伍的实力值，以空格分割。  
>  0<=各队伍实力值<=100
>
> **输出描述**  
>  输出一个整数，表示各组对战的实力差值的总和。若没有队伍可以匹配，则输出-1。
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> 输入
>
> 6 30  
>  81 87 47 59 81 18
>
> 输出
>
> 57
>
> **示例2：输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> 输入
>
> 6 20  
>  81 87 47 59 81 18
>
> 输出
>
> 12
>
> **示例3：输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> 输入
>
> 4 10
>
> 40 51 62 73
>
> 输出
>
> -1
>
> ![](https://img-blog.csdnimg.cn/95b1302dd34b401ebf8417c80d44420f.webp)

# 思路

> ~~1：题目中两个要求：~~
>
> ~~『匹配队伍最多』~~
>
> ~~『匹配出的各组实力差距的总和最小』~~
>
> ~~首先要满足条件1，再最大限度的满足条件2.~~
>
> ~~2：为了满足条件1，肯定是要找到每一个队伍实力最相近的队伍，这个简单，直接从小到大排序即可，每个数字两边的数，就代表了实力最接近的队伍实力值。~~
>
>
> ~~3：为了满足条件2，实力差距的总和最小，那么疑问就是在中间的队伍到底匹配左边还是匹配右边的队伍，这也简单，要么都匹配左边，要么都匹配右边，因为队伍不能重复匹配。两个遍历结果就有了。~~
>
>
> 4：感谢评论区大佬提供的[动态规划](https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1001.2101.3001.7020
> "动态规划")版本！

# 考点

> 1：逻辑思维能力

# Code

**动态规划版本：**

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
     
    
    # 读取第一行的n
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    target = params[1]
    data = [int(x) for x in input().split(" ")]
    
    data.sort()
    
    dp1 = [0]*(n+1) #pair个数
    dp2 = [0]*(n+1) #最小和
    
    for i in range(2,n+1):
        tmp = 0
        if data[i-1] - data[i-2] <= target:
            tmp += 1
    
        if dp1[i-2]+tmp>dp1[i-1]:
            dp1[i] = dp1[i-2] + tmp
            dp2[i] = dp2[i-2] + data[i-1] - data[i-2]
        elif dp1[i-2]+tmp<dp1[i-1]:
            dp1[i] = dp1[i-1]
            dp2[i] = dp2[i-1]
        else:
            if tmp == 1:
                dp2[i] = min(dp2[i-1], dp2[i-2]+data[i-1]-data[i-2])
            else:
                dp2[i] = min(dp2[i-1], dp2[i-2])
            dp1[i] = dp1[i-1]
    
    if dp1[n] == 0:
        print(-1)
    else:
        print(dp2[n])
     
     
     
     

逻辑分析版本：

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
     
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    d = params[1]
    teams = [int(x) for x in input().split(" ")]
    
    # 按照大小排序
    teams.sort()
    
    # 都选左边或者右边（端点额外考虑）
    sum_d_left = 0
    left_pair = 0
    i = 0
    while(i<n-1):
        if (teams[i+1] - teams[i] <= d):
            sum_d_left += teams[i+1] - teams[i]
            left_pair +=1
        i+=2
    
    sum_d_right = 0
    right_pair = 0
    i = 1
    while(i<n-1):
        if (teams[i+1] - teams[i] <= d):
            sum_d_right += teams[i+1] - teams[i]
            right_pair += 1
        
        i+=2
    
    
    if (sum_d_right == 0 and sum_d_left == 0):
        print(-1)
    else:
        if (left_pair > right_pair):
            print(sum_d_left)
        elif (left_pair < right_pair):
            print(sum_d_right)
        else:
            print(min(sum_d_right, sum_d_left))
        
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

