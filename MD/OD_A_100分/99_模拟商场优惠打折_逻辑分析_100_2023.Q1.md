**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 模拟商场优惠打折，有三种优惠券可以用，满减券、打折券和无门槛券。
>
> 满减券：满100减10，满200减20，满300减30，满400减40，以此类推不限制使用；
>
> 打折券：固定折扣92折，且打折之后向下取整，每次购物只能用1次；
>
> 无门槛券：一张券减5元，没有使用限制；
>
>
> 每个人结账使用优惠券时有以下限制：每人每次只能用两种优惠券，并且同一种优惠券必须一次用完，不能跟别的穿插使用（比如用一张满减，再用一张打折，再用一张满减，这种顺序不行）。
>
> 求不同使用顺序下每个人用完券之后得到的最低价格和对应使用优惠券的总数；如果两种顺序得到的价格一样低，就取使用优惠券数量较少的那个。
>
> **输入描述：**
>
> 第一行三个数字m,n,k，分别表示每个人可以使用的满减券、打折券和无门槛券的数量
>
> 第二行一个数字x, 表示有几个人购物
>
> 后面x行数字，依次表示是这几个人打折之前的商品总价
>
> **输出描述：**
>
> 输出每个人使用券之后的最低价格和对应使用优惠券的数量
>
> 示例：
>
> 输入：
>
> 3 2 5
>
> 3
>
> 100
>
> 200
>
> 400
>
> 输出：
>
> 65 6
>
> 135 8
>
> 275 8
>
> 说明:
>
> 第一个人使用 1 张满减券和5张无门槛券价格最低。
>
> 第二个人使用 3 张满减券和5张无门槛券价格最低。
>
> 第二个人使用 3 张满减券和5张无门槛券价格最低。

# 思路

> 1：暴力遍历即可，因为不能交叉使用且只能使用两种，那么所有的可能性都可以暴力枚举出来：假设为A、B、C
>
> AB
>
> BA
>
> AC
>
> CA
>
> BC
>
> CB
>
> 总共六种使用的可能性。
>
> ![](https://img-blog.csdnimg.cn/64a9bfba99214604b0d2e4a8d35baf54.jpeg)
>
> 2：其次按照常识，先使用无门槛优惠券，把总价的基数变小之后，再用别的优惠券肯定得不到最大的优惠，所以还剩4种方案。
>
> 3：按照4种可能行算出结果，比对出最小值即可。
>
> 4：感觉题目设计是不是有问题，打折券只能用一张，为啥要给出打折券的个数，难道是迷惑项？
>
> **5：几种特殊情况：**
>
> **//满减券大于0且价格大于100判断**
>
> **//打折券大于0判断**
>
> **//无门槛用了为负数是直接置0**

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    #先满减后打折
    def mode_a(price, m, n):
        count = 0
        while(m > 0):
            if (price < 100):
                break
            
            price -= (int(price/100) * 10)
            count += 1
            m-=1
        if n>0:
            price *= 0.92
            count += 1
        return (price, count)
    
     
    #先打折后满减
    def mode_b(price, m, n):
        count = 0
     
        if n>0:
            price *= 0.92
            count += 1
     
        while(m > 0):
            if (price <100):
                break
            
            price -= (int(price/100) * 10)
            count += 1
            m-=1
        return (price, count)
     
    
     
    #先满减后无门槛
    def mode_c(price, m, k):
        count = 0
     
        while(m > 0):
            if (price <100):
                break
            
            price -= (int(price/100) * 10)
            count += 1 
            m-=1
        
     
        for i in range(k):
            price -= 5
            count += 1
            if (price <0):
                price=0
                break
        return (price, count)
    
     
    #先打折后无门槛
    def mode_d(price, n, k):
        count = 0
        if n>0:
            price *= 0.92
            count += 1
     
        for i in range(k):
            price -= 5
            count += 1
            if (price < 0):
                price=0
                break
        return (price, count)
    
     
    def comp(a, b):
        if (a[0] > b[0]):
            return 1
        elif (a[0] == b[0]):
            if (a[1] > b[1]):
                return 1
            else:
                return -1
        return -1
    
     
    
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    k = params[2]
    
    x = int(input())
    
    
    for i in range(x):
        price = int(input())
    
        result = []
        result.append(mode_a(price, m, n))
        result.append(mode_b(price, m, n))
        result.append(mode_c(price, m, k))
        result.append(mode_d(price, n, k))
    
        #按照价格降序，用券数降序排序
        result = sorted(result, key = functools.cmp_to_key(comp))
        print(str(int(result[0][0])) + " "+str(result[0][1]))
        
    

