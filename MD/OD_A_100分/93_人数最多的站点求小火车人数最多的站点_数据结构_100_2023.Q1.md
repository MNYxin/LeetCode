**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> **题目描述**  
>  公园园区提供小火车单向通行，从园区站点编号最小到最大通行如1~2~3~4~1，然后供员工在各个办公园区穿梭，  
>  通过对公司N个员工调研统计到每个员工的坐车区间，包含前后站点，请设计一个程序计算出小火车在哪个园区站点时人数最多。  
>  **输入描述：**  
>  输入的第1个行，为调研员工人数
>
> 第2行开始，  
>  为每个员工的开始上车站点和下车站点。  
>  使用数字代替每个园区用空格，分割如3 5表示从第3个园区上车，在第5个园区下车  
>  **输出描述:**
>
> 人数最多时的园区站点编号，最多人数相同时返回编号最小的园区站点
>
> **示例1** ：
>
> 输入：
>
> 3
>
> 1 3
>
> 2 4
>
> 1 4
>
> 输出：
>
> 2
>
> 说明：1号员工，在1站台上车，3站台下车。
>
> 2号员工，在2站台上车，4站台下车。
>
> 3号员工，在1站台上车，4站台下车。
>
> 综上，2站台时，人数最多。

# 思路

> 1：其实如说明里的描述，输入的信息是非常明确的，我们只需要一个数据结构map<int, int>保存每个站台的人数即可。比如：在2站台上车，4站台下车，
> 那么map[2] += 1, map[3] += 1, map[4] += 1。最后排序输出最大的哪一个站台即可。
>
> 2：如何用map结构统计信息，再自定义map结构的排序，老生常谈的问题了。
>
>
> **3：经评论区老哥提醒，可能会存在起点比终点大的情况，因为是环线。所以改进方法的第一步就是求出最大的站点（题目也没说最大的站点是哪个，有点烦）。然后比如最大站点是5，将[4,2]拆成[4,5]
> 和 [1,2]。（最小站点必然是1）**

# 考点

> 1：数据结构
>
> 2：过程模拟

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def comp(a, b):
        if (a[1] == b[1]):
            return a[0]-b[0]
        return b[1] - a[1]
    
    
    #人数
    n = int(input())
    
    
    nums = []
    max_site = 0
    for i in range(n):
        params = [int(x) for x in input().split(" ")]
        max_site = max(max_site, max(params[0],params[1]))
        nums.append([params[0],params[1]])
    
    
    sites = []
    for i in range(len(nums)):
        if (nums[i][0] > nums[i][1]):
            sites.append([nums[i][0], max_site])
            sites.append([1, nums[i][1]])
        else:
            sites.append([nums[i][0], nums[i][1]])
    
    
    #创建人数的数据结构
    site_map ={};
    for i in range(len(sites)):
        start = sites[i][0]
        end = sites[i][1]
        for j in range(start, end+1):
            if(j in site_map):
                site_map[j] += 1
            else:
                site_map[j] = 1
    
    
    # 将map信息转到list中，以便后续排序
    sites = []
    for key in site_map:
        sites.append([key, site_map[key]]);
    
    sites = sorted(sites, key=functools.cmp_to_key(comp));
    
    #输出
    print(sites[0][0])
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

