**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。农夫有一艘容量固定的船，能够承载固定数量的动物。
>
> 要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。
>
> 备注：农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊。
>
> 农夫自身不占用船的容量。
>
> **输入描述**
>
> 第一行输入为M，N，X， 分别代表羊的数量，狼的数量，小船的容量。
>
> **输出描述**
>
> 输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。
>
> （若无法满足条件则输出0）
>
> **示例1：**
>
> 输入： 5 3 3
>
> 输出： 3
>
> 说明： 第一次运2只狼 第二次运3只羊 第三次运2只羊和1只狼
>
> **示例2：**
>
> 输入：
>
> 5 4 1
>
> 输出： 0
>
> 说明： 如果找不到不损失羊的运送方案，输出0

# 思路

> 1：首先几个边界条件要清楚
>
> 第一、羊的数量不能小于狼的数量
>
> 第二、农夫自身不占用船的容量。
>
> 第三、回程时农夫不会运送羊和狼。
>
> 2：不管在河的两岸都需要满足羊的数量不能小于狼的数量。
>
> 3：这样的话明显一个DFS 就可以解决问题，因为 **有重复的子问题就是运送多少只动物的情况下是否满足不损失动物的条件** 。
>
> 4：DFS的解法如果遇到递归过深的情况，大概率是超时的。因此下面给出另外一个贪心的解法：根据之前的思路2中的信息，
>
> **分支1** ：初始情况下，羊个数小于狼个数，则直接无解。
>
> **分支2** ：初始情况下，羊个数大于等于狼个数。
>
> **分支2.1** ：狼的个数小于船的容量，可以直接一次运走所有狼。
>
> **分支2.1.1** ：狼的个数小于船的一半容量，那么在穿上就既可以运羊也可以运狼。
>
> **分支2.2** ：狼的个数大于船的容量，那么第一次应该运
> X-1个狼过去，然后再运X个羊过去。这样可以保证对岸羊的数量不能小于狼的数量。后续运输的规则就是保证（船上的羊多于狼1个）
>
> int sheep_boat = Math.ceil(X / 2) + (X % 2 == 0 ? 1 : 0);
>
> int wolf_boat = X - sheep_boat;
>
> **分支2.2.1** ：与此同时，还需要保证本岸剩余的羊还是多于狼，或者羊、狼其中一方已经都运走了。
>
> **分支2.2.2**
> ：如果不能保证2.2.1，则需要将本岸的狼运一点到对岸（不能多于对岸羊的个数），如果此时对岸狼的个数已经=羊的个数-1，那么无解。
>
>
> **5：根据前方机考同学反馈，第一，此题机考的测试用例很少。第二，将贪心解法的分支1删除后，通过率是100%。非常诡异，只能推断出测试用例全部是羊小于狼。第三，DFS暴力的方法也可100%通过率**

# 考点

> 1：DFS

# Code

DFS

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
    
    
    #处理输入
    input_nums = [int(x) for x in input().split(" ")]
    M = input_nums[0]
    N = input_nums[1]
    X = input_nums[2]
    
    min_times = []
    
    # m0, n0 分别表示剩余的羊、狼个数， x为船容量
    #m1, n1 分别表示运输到对岸的羊、狼个数，times为次数
    def transport(m0, n0, x, m1, n1, times):
        global min_times
        if m0 == 0 and n0 == 0:
            min_times.append(times)
            return
     
        if m0 + n0 <= x:
            min_times.append(times + 1)
            return
     
        for i in range(min(x, m0) + 1):
            for j in range(min(x, n0) + 1):
                if i + j == 0:
                    continue
                if i + j > x:
                    break
                if m0 - i <= n0 - j and m0 - i != 0:
                    continue
                if m1 + i <= n1 + j and m1 + i != 0:
                    break
                if m1 + i == 0 and n1 + j >= x:
                    break
     
                transport(m0 - i, n0 - j, x, m1 + i, n1 + j, times + 1)
        
    # 表示已运输到对岸的羊、狼个数
    m_temp=0;
    n_temp=0;
    
    transport(M, N, X, m_temp, n_temp, 0);
    
    if(len(min_times)>0):
        print (min(min_times))
    else :
        print (0)
    
    
    
    

贪心：

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def comp(a, b):
        return int(a[1]) - int(b[1])
     
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
    
    
    #处理输入
    input_nums = [int(x) for x in input().split(" ")]
    M = input_nums[0]
    N = input_nums[1]
    X = input_nums[2]
    
    # 分支1.1 （机考时删除此分支）
    if (M <= N):
        print(0)
    # 分支2.1
    elif (N < X):
        # 分支2.1.1
        if (N < math.ceil(X / 2)):
            M -= X - N
        
        print(int(math.ceil(M / X)) + 1)
    else:
        # 分支2.2
        N -= X - 1
        N_opposite = X - 1
        M -= X
        M_opposite = X
    
        # 第一轮已经两次了
        result = 2
    
        # 后续运输的初始规则（船上的羊多于狼1个）
        if X % 2 == 0:
            sheep_boat = int(math.ceil(X / 2)) +  1
        else:
            sheep_boat = int(math.ceil(X / 2))
        wolf_boat = X - sheep_boat
    
        #无解标记
        flag = False
        while (M > 0):
            # 分支2.2.1
            if (M - sheep_boat > N - wolf_boat or (M == sheep_boat and N == wolf_boat)):
                M -= sheep_boat
                M_opposite += sheep_boat
                N -= wolf_boat
                N_opposite += wolf_boat
                result+=1
            # 分支2.2.2
            else:
                tmp = M_opposite - N_opposite - 1
                if (tmp == 0):
                    print(0)
                    flag = True
                    break
                
                N -= tmp
                N_opposite += tmp
                result+=1
        if not flag: 
            print(result)
    

