**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>  公司某部门软件教导团正在组织新员工每日打卡学习活动，他们开展这项学习活动已经一个月了，所以想统计下这个月优秀的打卡员工。  
>  每个员工会对应一个id，每天的打卡记录记录当天打卡员工的id集合，，一共30天。  
>  请你实现代码帮助统计出打卡次数tp5的员工。加入打卡次数相同，将较早参与打卡的员工排在前面，如果开始参与打卡的时间还是一样，将id较小的员工排在前面。  
>  注:不考虑并列的情况，按规则返回前5名员工的id即可，如果当月打卡的员工少于5人，按规则排序返回所有有打卡记录的员工id.
>
>  
> **输入描述**  
>  第一行输入为新员工数量N，表示新员工编号id为0到N-1，N的范围为[1,100]
>
> 第二行输入为30个整数，表示每天打卡的员工数量，每天至少有1名员工打卡.
>
> 之后30行为每天打卡的员工id集合，id不会重复。
>
> **输出描述**  
>  按顺序输出打卡top5员工的id，用空格隔开。
>
> 示例1：  
>  输入
>
> 11  
>  4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2  
>  0 1 7 10  
>  0 1 6 10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  10  
>  6 10  
>  7 10
>
> 输出：  
>  10 0 1 7 6
>
> 说明：  
>
> 员工编号范围为0~10，id为10的员工连续打卡30天，排第一，id为0,1,6,7的员工打卡都是两天，id为0,1,7的员工在第一天就打卡，比id为6的员工早，排在前面，0,1,7按id升序排列，所以输出[10,0,1,7,6]

# 思路

> 1：典型的排序类问题，自定义排序，先按照打卡次数，再按照打卡先后进行排序即可。
>
> 2：写个输入解析都写一大堆。。。
>
> 3：第一行输入的新员工个数好像没什么鸟用？

# 考点

> 1：自定义排序

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def comp(a, b):
        if (a[1] == b[1]):
            if (a[2] == b[2]):
                return a[0] - b[0]
            else:
                return a[2] - b[2]
        else:
            return b[1] - a[1]
    
    
    #新员工数量
    n = int(input())
    #每天打卡的员工数量
    employee_count = [int(x) for x in input().split(" ")]
    #打卡记录
    employee_ids = []
    for i in range(30):
        employee_ids.append([int(x) for x in input().split(" ")])
    
    #key为员工ID， value为其打卡的记录信息：[打卡次数，首次打卡index]
    employee_info = {}
    for i in range(30):
        for j in employee_ids[i]:
            if(j in employee_info):
                employee_info[j][0] += 1
            else:
                employee_info[j] = [1, i]
    
    # 将map信息转到list中，以便后续排序
    employee_list = []
    for key in employee_info:
        employee_list.append([key, employee_info[key][0], employee_info[key][1]]);
    
    employee_list = sorted(employee_list, key=functools.cmp_to_key(comp));
    
    res = []
    for i in range(5 if len(employee_list)>=5 else len(employee_list)):
        res.append(str(employee_list[i][0]))
    
    #输出
    print(" ".join(res))
    
    

