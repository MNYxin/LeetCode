**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")**************** ​​​​​​​

# 题目

>
>     给定一个N行M列的二维矩阵，矩阵中每个位置的数字取值为0或1。矩阵示例如：
>     1100
>     0001
>     0011
>     1111
>     现需要将矩阵中所有的1进行反转为0，规则如下：
>     1） 当点击一个1时，该1便被反转为0，同时相邻的上、下、左、右，以及左上、左下、右上、右下8 个方向的1（如果存在1）均会自动反转为0；
>     2）进一步地，一个位置上的1被反转为0时，与其相邻的8个方向的1（如果存在1）均会自动反转为0；
>  
>     按照上述规则示例中的矩阵只最少需要点击2次后，所有值均为0。请问，给定一个矩阵，最少需要点击几次后，所有数字均为0？
>
> **输入描述：**
>
> 第一行为两个整数N和M，分别代表矩阵的行数和列数。
>
> 接下来的N行为矩阵的初始值，每行M个整数
>
> **输出描述：**
>
> 输出一个整数，表示最少需要点击的次数
>
> **示例1：**
>
> 输入：
>
> 3 3  
>  1 0 1  
>  0 1 0  
>  1 0 1
>
> 输出：
>
> 1
>
> **示例2：**
>
> 输入：
>
> 4 4  
>  1 1 0 0  
>  0 0 0 1  
>  0 0 1 1  
>  1 1 1 1
>
> 输出：
>
> 2

# 思路

> 1：和之前有一个特别像的题目，[机器人](https://renjie.blog.csdn.net/article/details/128319475
> "机器人")，只不过改动有一点，四个方向改成了8个方向，逻辑也变成了反转数字。
>
> 2：核心解法依然是BFS。

# 考点

> 1：BFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
     
    directions = [[0, 1], [0, -1], [1, 0], [-1, 0],[1, 1], [1, -1], [-1, -1], [-1, 1]]
     
    
    def bfs(n, m, matrix, flipped):
        global directions
        if (len(flipped) ==0):
          return;
    
        pos = flipped.pop(0)
        for d in directions:
            newX = pos[0] + d[0]
            newY = pos[1] + d[1]
            if (newX >= 0 and newX < n and
                newY >= 0 and newY < m and
                matrix[newX][newY] == 1):
                matrix[newX][newY] = 0
                flipped.append([newX, newY])
    
        bfs(n, m, matrix, flipped)
    
      
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    n =params[0]
    m = params[1]
    matrix = []
    for i in range(n):
        matrix.append([int(x) for x in input().split(" ")])
     
    #起点可以是每一个位置
    result = 0;
    for i in range(n):
        for j in range(m):
            if (matrix[i][j] == 1):
                result += 1
                flipped = []
                flipped.append([i,j])
                bfs(n, m, matrix, flipped)
     
    print(result)

