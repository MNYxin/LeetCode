**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 快递业务范围有 N 个站点，A 站点与 B 站点可以中转快递，则认为 A-B 站可达，  
>  如果 A-B 可达，B-C 可达，则 A-C 可达。  
>  现在给 N 个站点编号 0、1、…n-1，用 s[i][j]表示 i-j 是否可达，  
>  s[i][j] = 1表示 i-j可达，s[i][j] = 0表示 i-j 不可达。  
>  现用二维数组给定N个站点的可达关系，请计算至少选择从几个主站点出发，才能可达所有站点（覆盖所有站点业务）。  
>  说明：s[i][j]与s[j][i]取值相同。
>
> **输入描述**
>
> 第一行输入为 N，N表示站点个数。 1 < N < 10000  
>  之后 N 行表示站点之间的可达关系，第i行第j个数值表示编号为i和j之间是否可达。
>
> **输出描述**
>
> 输出站点个数，表示至少需要多少个主站点。
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4`  
> `1 1 1 1`  
> `1 1 1 0`  
> `1 1 1 0`  
> `1 0 0 1`
>
> **输出**
>
> `1`
>
> **说明**
>
> 选择 0 号站点作为主站点， 0 站点可达其他所有站点，  
>  所以至少选择 1 个站点作为主站才能覆盖所有站点业务。
>
> **示例2** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `4`  
> `1 1 0 0`  
> `1 1 0 0`  
> `0 0 1 0`  
> `0 0 0 1`
>
> **输出**
>
> **3**
>
> **说明**
>
> 选择 0 号站点可以覆盖 0、1 站点，  
>  选择 2 号站点可以覆盖 2 号站点，  
>  选择 3 号站点可以覆盖 3 号站点，  
>  所以至少选择 3 个站点作为主站才能覆盖所有站点业务。

# 思路

> ~~1：先理解题意，s[i][j] = 1表示 i-j可达，那么第i行的每一位数字，都代表着第i个站点与其他站点是否相连。~~
>
> ~~2：这样我们就可以遍历每一个站点与其他站点的相连信息（其实就是遍历每一行），利用一个set来保存当前站点是否已经覆盖。~~
>
> 3：还是并查集吧，这个应该最直接。

# 考点

> 1：数据结构

# Code

100%

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def check(site_set,n,matrix):
        for i  in range(len(matrix)):
            if(i in site_set):    
                continue        
            if(n != i and matrix[n][i] == 1):
                site_set.add(i)
                check(site_set, i,matrix)
    
    
    
    #处理输入
    N = int(input())
    matrix = []
    for i in range(N):
        matrix.append([int(x) for x in input().split(" ")])
     
    #已经有连通的站点
    site_set = set()  
    #需要遍历的次数  
    res = 0   
    for i in range(N):
        #当前站点已经可以达到
        if(i in site_set):
            continue
        temp = set()
        temp.add(i)
        check(temp, i, matrix)
        site_set = set.union(site_set, temp)
        res +=1
    
    print(res)

新解法

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n+1):
                self.item[i] = i
    
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count -= 1
     
    n = int(input())
    sites = []
    for i in range(n):
        sites.append([int(x) for x in input().split(" ")])
    
    uf = UF(n)
     
    for i in range(n):
        for j in range(i+1,n):
            if sites[i][j] == 1:
                uf.union_connect(i, j)
     
    print(uf.count)
        
     

