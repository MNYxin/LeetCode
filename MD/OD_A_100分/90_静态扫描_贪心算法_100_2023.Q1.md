**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>  静态扫描可以快速识别源代码的缺陷，静态扫描的结果以扫描报告作为输出:
>
> 1、文件扫描的成本和文件大小相关，如果文件大小为N，则扫描成本为N个金币
>
> 2、扫描报告的缓存成本和文件大小无关，每缓存一个报告需要M个金币
>
> 3、扫描报告缓存后，后继再碰到该文件则不需要扫描成本，直接获取缓存结果给出源代码文件标识序列和文件大小序列，
> **求解采用合理的缓存策略，最少需要的金币数**
>
> **输入描述**  
>  第一行为缓存一个报告金币数M，L<= M <= 100  
>  第二行为文件标识序列: F1,F2,F3,....,Fn。  
>  第三行为文件大小序列: S1,S2,S3,....,Sn。  
>  备注:  
>  1 <= N <= 10000  
>  1 <= Fi <= 1000  
>  1 <= Si <= 10  
>  **输出描述**  
>  采用合理的缓存策略，需要的最少金币数
>
> **示例1：**  
>  5  
>  1 2 2 1 2 3 4
>
> 1 1 1 1 1 1 1  
>  输出  
>  7  
>  说明  
>  文件大小相同，扫描成本均为1个金币。缓存任意文件均不合算，因而最少成本为7金币。
>
> **示例2：**
>
> 输入
>
> 5  
>  2 2 2 2 2 5 2 2 2  
>  3 3 3 3 3 1 3 3 3  
>  输出  
>  9

# 思路

> 1：典型的贪心算法，对于每一种大小的文件，需要判断的是 **每次都重新扫描的成本** 和 **扫描一次加上缓存的成本** ，选择其中最小的即可。

# 考点

> 1：贪心算法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def comp(a, b):
        return b[1] - a[1]
    
    
    #处理输入
    m = int(input())
    
    file_ids = [int(x) for x in input().split(" ")]
    sizes = [int(x) for x in input().split(" ")]
                   
    
    # key为文件标识 value为文件出现的次数
    file_map = {}
    # key为文件标识 value为扫描成本
    file_cost = {}
    
    for i in range(len(file_ids)):
        if(file_ids[i] in file_map):
            file_map[file_ids[i]] += 1
        else:
            file_map[file_ids[i]] = 1
        file_cost[file_ids[i]] = sizes[i]
    
    result = 0
    for key in file_map:
        result += min(file_map[key] * file_cost[key], file_cost[key] + m)
    
    print(result)
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

