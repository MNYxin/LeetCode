**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 幻方(Magic Square)
> 是一个由1~N^2，共N^2个整数构成的N*N矩阵，满足每行、列和对角线上的数字和相等.上回你已经帮助小明将写错一个数字的幻方进行了修复，小明在感谢之余也想进一步试试你的水平，于是他准备了
> **有两个数字发生了位置交换** 的幻方。  
>  你可以把这两个交换的数字找出来并且改正吗?  
>  **输入描述**  
>  第一行输入一个整数N，代表带校验幻方的阶数 (3 <= N < 50)  
>  接下来的N行，每行N个整数，空格隔开 (1<=每个整数 <= N^2)  
>  **输出描述**  
>  输出两行，代表两条纠正信息，注意先输出行号小的，若行号相同则先输出列好小的每行输出空格隔开的三个整数，分别是:
> 出错行号、出错列号、应填入的数字(末尾无空格)
>
> **示例1：  
>  输入**
>
> 3  
>  8 1 9  
>  3 5 7  
>  4 6 2  
>  **输出**  
>  1 3 6
>
> 3 2 9

# 思路

> 1：直接暴力破解，首先根据幻方的性质，可以得到每行每列的和都是N*(N^2+1)/2。
>
> 2：根据性质找到两行或者两列出错的位置，然后两个for循环，找到任意两个可能出错的点，进行交换，然后计算能否满足幻方条件。
>
> 3：O(n^2)的时间复杂度，最多也就2500次循环。

# 输入输出

>
> 1：Python输入数据主要通过`input()`函数实现，`input()`会读取控制台一行的输入，如果输入有多行的话，需要多次使用`input()`。
>  
>  
>     # 输入为: 1 2 3 4 5
>     a = input()
>     # a = '1 2 3 4 5'
>
>
> 2：与Python2中不同，Python3中的`input()`会将接受的数据返回为一个`string`类型，如果一行中有多个数据的话，则需要使用`split()`进行切割。`split()`切割后返回一个列表。
>  
>  
>     # 输入为： 1 2 3 4 5
>     a = input().split() # split()默认以空字符为分隔符，包括空格、换行(\n)、制表符(\t)等
>     # a = ['1', '2', '3', '4', '5']
>  
>     # 输入为：1,2,3,4,5
>     b = input().split(',') # 以逗号为分隔符
>     # b = ['1', '2', '3', '4', '5']
>
>
> 3：因为`input()`返回的是`string`，分割后也是一个字符列表，如果输入数据是数字则需要进行类型转换。可以单个转换或是用列表批量转换，或者是使用`map()`并行转换。`map()`函数返回的是一个迭代器，不能改变值，如果需要改变值的话还需要转换成列表
>  
>  
>     # 输入为： 1
>     a = int(input()) # 单个转换
>  
>     # 输入为：1 2 3 4 5
>     b = input().split() # b = ['1', '2', '3', '4', '5']
>     c = [int(i) for i in b] # 使用列表进行批量转换 c = [1, 2, 3, 4, 5]
>     d = [int(i) for i in input().split()] # 当然可以一步倒位
>  
>     # 使用map进行并行转换
>     e = map(int, input().split()) # 此时e是一个map迭代器，不能赋值，也不能索引
>     f = list(e) # 转换为列表，e = [1, 2, 3, 4, 5]
>     g = list(map(int, input().split())) # 一步到位

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
    def comp(a, b):
        if a[0] == b[0]:
            return a[1] - b[1]
        else:
            return a[0] - b[0]
     
     
    # 处理输入
    n = int(input())
    line_sum = []
    col_sum = [0 for x in range(n)]
    matrix = []
    for i in range(n):
        temp = [int(x) for x in input().split(" ")]
        matrix.append(temp)
        line_sum.append(sum(temp))
        for j in range(n):
            col_sum[j] += temp[j]
    
    
    # 必然只有两行或者两列的和不等于target
    lines = []
    cols = []
    target = n*(n*n+1)/2;
    for i in range(n):
        if (line_sum[i] != target):
            lines.append(i)
        if (col_sum[i] != target):
            cols.append(i)
    
    
    if (len(lines)==2):
        for i in range(n):
            for j in range(n):
                if(line_sum[lines[0]]-matrix[lines[0]][i] + matrix[lines[1]][j] == target):
                    print(str(lines[0] + 1) + " " + str(i + 1) + " " + str(matrix[lines[1]][j]))
                    print(str(lines[1] + 1) + " " + str(j + 1) + " " + str(matrix[lines[0]][i]))
    elif (len(cols)==2):
        for i in range(n):
            for j in range(n):
                if(col_sum[cols[0]]-matrix[i][cols[0]] + matrix[j][cols[1]] == target):
                    print(str(i + 1) + " " + str(cols[0] + 1) + " " + str(matrix[j][cols[1]]))
                    print(str(j + 1) + " " + str(cols[1] + 1) + " " + str(matrix[i][cols[0]]))
     

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

