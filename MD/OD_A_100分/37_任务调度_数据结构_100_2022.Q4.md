**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 现有一个CPU和一些任务需要处理，已提前获知每个任务的任务ID、优先级、所需执行时间和到达时间。  
>  CPU同时只能运行一个任务，请编写一个任务调度程序，采用“可抢占优先权调度”调度算法进行任务调度，规则如下：  
>
> 1：如果一个任务到来时，CPU是空闲的，则CPU可以运行该任务直到任务执行完毕。但是如果运行中有一个更高优先级的任务到来，则CPU必须暂停当前任务去运行这个优先级更高的任务；  
>  2：如果一个任务到来时，CPU正在运行一个比他优先级更高的任务时，信道大的任务必须等待；  
>  3：当CPU空闲时，如果还有任务在等待，CPU会从这些任务中选择一个优先级最高的任务执行，相同优先级的任务选择到达时间最早的任务。  
>  **输入描述**  
>  输入有若干行，每一行有四个数字（ **均小于10^8** ）,分别为任务ID，任务优先级，执行时间和到达时间。每个任务的任务ID不同，
> **优先级数字越大优先级越高** ，并且相同优先级的任务不会同时到达。  
>  输入的任务已按照到达时间从小到大排序，并且保证在任何时间，处于等待的任务不超过10000个。  
>  **输出描述**  
>  按照任务执行结束的顺序，  
>  **示例一**  
>  输入
>
> 1 3 5 1  
>  2 1 5 10  
>  3 2 7 12  
>  4 3 2 20  
>  5 4 9 21  
>  6 4 2 22  
>  输出
>
> 1 6  
>  3 19  
>  5 30  
>  6 32  
>  4 33  
>  2 35

# 思路

> 1：核心还是看懂题目中的几个规则，看了之后其实就是自定义排序。。。

# 考点

> 1：排序

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    
    
    def comp(a, b):
        if a[1] > b[1]:
            return -1
        elif a[1] == b[1]:
            return 0
        else:
            return 1
    
    def find(tasks, time):
        for task in tasks:
            if (task[3] == time):
                return task
        return None
    
     
     
    # 处理输入
    # 不确定多少行输入
    tasks = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        tasks.append([int(x) for x in line.split(" ")])
    
    #print (tasks)
    
    time = 0;
    waiting = []
    while (len(tasks) > 0):
        cur = find(tasks, time)
        
        if (cur is not None):
            waiting.append(cur);
            #按照优先级排序
            waiting = sorted(waiting, key= functools.cmp_to_key(comp))
            #print (tasks)
            cur = waiting[0]
        else:
            if (len(waiting) != 0):
                cur = waiting[0]
                
    
        if (cur is not None):
            cur[2] -= 1
            if (cur[2] == 0):
                print(str(cur[0]) + " " + str(time + 1))
                tasks.remove(cur)
                waiting.remove(cur)
    
        time+=1
    
    

