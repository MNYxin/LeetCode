**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> **题目描述：**
>
> 当小区通信设备上报告警时，系统会自动生成待处理的工单，华为工单调度系统需要根据不同的策略，调度外线工程师（FME）上站去修复工单对应的问题。
> 根据与运营商签订的合同，不同严重程度的工单被处理并修复的时长要求不同，这个要求被修复的时长我们称之为SLA时间。
>
> 假设华为和运营商A签订了运维合同，部署了一套调度系统，只有1个外线工程师（FME），每个工单根据问题严重程度会给一个评分，
> **在SLA时间内完成修复的工单，华为获得工单评分对应的积分** ， **超过SLA完成的工单不获得积分**
> ，但必须完成该工单。运营商最终会根据积分进行付款。
>
> 请你设计一种调度策略，根据现状得到调度结果完成所有工单， **让这个外线工程师处理的工单获得的总积分最多**
> 。假设从某个调度时刻开始，当前工单数量为N，不会产生新的工单， **每个工单处理修复耗时为1小时**
> ，请设计你的调度策略，完成业务目标。不考虑外线工程师在小区之间行驶的耗时。 假设有7个工单的SLA时间（小时）和积分如下：
>
> ![](https://img-blog.csdnimg.cn/dcb2393b75194b9f8c2441f4e83f4f67.png)
>
> **输入描述：**
>
> 第一行为一个整数N，表示工单的数量。
>
> 接下来N行，每行包括两个整数。第一个整数表示工单的SLA时间（小时），第二个数表示该工单的积分。
>
> **输出描述：**
>
> 输出一个整数表示可以获得的最大积分。
>
> 备注：
>
> 工单数量N ≤ 10
>
> SLA时间 ≤ 7×10
>
> 答案的最大积分不会超过2147483647。
>
> **示例1： 输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> **输入：**
>
> 7
>
> 1 6
>
> 1 7
>
> 3 2
>
> 3 1
>
> 2 4
>
> 2 5
>
> 6 1
>
> **输出：**
>
> 15

# 思路

> 1：题目长的很，要挖掘出有用的信息，认真读题。
>
> 2：每个任务有SLA时间和积分两个属性，在SLA内完成可以获得积分，在SLA外完成不得积分，但是也必须完成。每个任务耗时为固定1小时，求最大可获得积分。
>
> 3：看到网上有一个比较tricky的方法，对应代码中的maxScore，表示每一个SLA时间点可以获得的积分大小。遍历所有的任务去给每一个时间点赋值。

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
    
     
    # 处理输入
    n = int(input())
    tasks = []
    for i in range(n):
        tasks.append([int(x) for x in input().split(" ")])
    
    
    #按照积分大小先排序
    tasks.sort(key=lambda x: -x[1])
    
    #每个SLA任务可获得的积分
    maxScore = [0 for i in range(n+1)]
    for i in range(len(tasks)):
        #如果当前这个SLA任务为0, 那么优先处理最大积分
        if (maxScore[tasks[i][0]] == 0) :
            maxScore[tasks[i][0]] = tasks[i][1]
        else:
            #SLA 减去 工单处理耗时1小时
            t = tasks[i][0] - 1
            #查看下一个SLA有没有被使用过
            while (t > 0 and maxScore[t] != 0) :
                t-=1;
            
            #若找到下一个SLA没有被使用过的，可以直接处理当前工单
            if (t > 0) :
                maxScore[t] = tasks[i][1]
    
    print(sum(maxScore))
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

