**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 题目描述:  
>  给定一个 m xn 的矩阵，由若干字符 和0构成，X表示该处已被占据，0"表示该处空闲，请找到最大的单入口空闲区域.  
>  解释:  
>  空闲区域是由连通的O组成的区域，位于边界的0可以构成入口，单入口空闲区域即有目只有一个位于边界的0作为入口的由连通的'O"组成的区域。  
>  如果两个元素在水平或垂直方向相邻，则称它们是“连通”的。
>
> **输入描述:**  
>  第一行输入为两个数字，第一个数字为行数m，第二个数字列数n，两个数字以空格分隔，1 <= m,n <= 200,剩余各行为矩阵各行元素，元素为'X'
> 或O，各元素间以空格分隔。  
>  **输出描述**  
>  若有唯一符合要求的最大单入口空闲区域，输出三个数字，第一个数字为入口行坐标(范围为0-行数-1)，第二个数字为入口列坐标(范围为0~列数-1)
> ，第三个数字为区域大小，三个数字以空格分隔;若有多个符合要求的最大单入口空闲区域，输出一个数字，代表区域的大小;若没有，输出NULL。
>
> **示例1**  
>  输入:  
>  4 4  
>  X X X X
>
> X O O X  
>  X O O X  
>  X O X X  
>  输出:  
>  3 1 5  
>  说明:  
>  存在最大单入口区域，入口行坐标3，列坐标1，区域大小5
>
> **示例2**  
>  输入:  
>  4 5  
>  X X X X X
>
> O O O O X
>
> X O O O X
>
> X O X X O  
>  输出:  
>  3 4 1  
>  说明:  
>  存在最大单入口区域，入口行坐标3，列坐标4，区域大小1
>
> **示例3**  
>  输入:  
>  54  
>  X X X X  
>  X O O O  
>  X O O O  
>  X O O X  
>  X X X X  
>  输出:  
>  NULL  
>  说明:  
>  不存在最大单入口区域
>
> **示例4**  
>  输入:  
>  5 4  
>  X X X X  
>  X O O O  
>  X X X X  
>  X O O O  
>  X X X X  
>  输出:  
>  3  
>  说明:  
>  存在两个大小为3的最大单入口区域，两个入口横纵坐标分别为1,3和3,3

# 思路

> 1：回溯法就可以解决，和之前的岛屿体积很像，只是需要额外在回溯的同时记录其入口坐标，如果入口个数大于1则不符合要求;入口个数等于1时，判断其区域大小;
> 如果存在多个区域，且区域大小相同，则只需记录其大小，其他情况则需要记录区域最大值和横纵坐标。

# 考点

> 1：回溯法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #处理输入
    m , n = map(int, input().split(" "))
    matrix = []
    for i in range(m):
        matrix.append(input().split(" "))
    
    def calc_area(matrix, i,j, flag):
        if( not flag):
            if (i == 0 or i == len(matrix) - 1 or j == 0 or j == len(matrix[0]) - 1):
                return 0
    
        
        matrix[i][j] = 'X'
        count = 1
        
        directions =[[0, 1],[0, -1],[1, 0],[-1, 0]]
        for  direction in directions:
            newX = i + direction[0]
            newY = j + direction[1]
            if (newX >= 0 and newX < len(matrix) and newY >= 0 and newY < len(matrix[0]) and 
                    matrix[newX][newY] == 'O'):
                count1 = calc_area(matrix, newX, newY, False)
                if (count1 == 0):
                    return 0
    
                count += count1
    
        return count
    
        
    #最大的区域大小  
    max_area = 0
    zones ={}
    for i in range(m):
        for j in range(n):
            if(matrix[i][j]=="O" and (i==0 or j==0 or i==m-1 or j==n-1)):
                #先假定当前可以为入口
                area = calc_area(matrix, i, j, True)
                if (area > 0):
                    key = str(i) + " " + str(j)
                    zones[key]= area
                    if (area > max_area):
                        max_area = area
    
    #输出
    max_entrace = ""
    for key in zones:
        if (zones[key] == max_area):
            if (max_entrace == "") :
                max_entrace = key
            else:
                max_entrace = "more"
                break
    
    
    if (max_area == 0):
        print("NULL")
    elif (max_entrace == "more"):
        print(max_area)
    else:
        print(max_entrace + " " + str(max_area))
    

## **要求：**

> * * *
>
> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> * * *
>
> **语言限定：**  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

