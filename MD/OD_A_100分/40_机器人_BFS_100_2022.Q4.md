**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 现有一个机器人，可放置于M×N的网格中任意位置，  
>  每个网格包含一个非负整数编号，  
>  当相邻网格的数字编号差值的绝对值小于等于1时，机器人可以在网格间移动  
>  问题：求机器人可活动的最大范围对应的网格点数目。说明：  
>  .网格左上角坐标为(0,0),右下角坐标为(m−1,n−1)  
>  .机器人只能在相邻网格间上下左右移动  
>  输入描述  
>
> 第1行输入为M和N，M表示网格的行数N表示网格的列数之后M行表示网格数值，每行N个数值（数值大小用k表示），数值间用单个空格分隔，行首行尾无多余空格M、N、k均为整数，且1≤M,N≤150，0≤k≤50  
>  输出描述  
>  输出1行，包含1个数字，表示最大活动区域的网格点数目行首行尾无多余空格  
>  示例一  
>  输入
>
> 4 4  
>  1 2 5 2  
>  2 4 4 5  
>  3 5 7 1  
>  4 6 2 4  
>  输出
>
> 6
>
> 示例二  
>  输入
>
> 2 3  
>  1 3 5  
>  4 1 3  
>  输出
>
> 1

# 思路

> 1：题目说机器人可以放在任意位置，那么说明，起点要遍历所有的点。
>
> 2：其实起点确定好，其余的就很好做了，从起点去判断上下左右是否可到达，一个简单的BFS。

# 考点

> 1：BFS

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    
    direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]
    
    k = 0
    def bfs(matrix, visited, x, y):
        global k
        visited[x][y] = True
        #四个方向查看是否可行
        for d in direction:
            newX = x + d[0]
            newY = y + d[1]
            if (newX >= 0 and newX < len(matrix) and newY >= 0 and newY < len(matrix[0])):
                if ( not visited[newX][newY] and abs(matrix[x][y] - matrix[newX][newY]) <= 1):
                    k+=1
                    bfs(matrix, visited, newX, newY)
    
    
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    X =params[0]
    Y = params[1]
    matrix = []
    for i in range(X):
        matrix.append([int(x) for x in input().split(" ")])
    
    #起点可以是每一个位置
    result = 0;
    for i in range(X):
        for j in range(Y):
            visited = [[False for y in range(Y)] for x in range(X)]
            k = 1
            bfs(matrix, visited, i, j)
            result = max(k, result)
    
    print(result)

