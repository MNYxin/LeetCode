**所有题目均有四种语言实现。 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> **题目描述**  
>  有N个快递站点用字符串标识，某些站点之间有道路连接。  
>  每个站点有一些包裹要运输，每个站点间的包裹不重复，路上有检查站会导致部分货物无法通行，计算哪些货物无法正常投递?  
>  **输入描述**  
>  1、第一行输入M N，M个包裹N个道路信息，0<=M.N<=100。
>
> 2、后面M行分别输入包裹名、包裹起点、包裹终点。
>
> 3、后面N行分别表示两个站点之间不能通过的包裹名。检查站禁止通行的包裹如果有多个以空格分开  
>  **输出描述**  
>  1、输出不能送达的包裹，如: package2 package4  
>  如果所有包惠都可以送达则输出: none,  
>  输出结果按照升序排列
>
> **示例1：**  
>  4 2  
>  package1 A C  
>  package2 A C  
>  package3 B C
>
> package4 A C
>
> A B package1
>
> A C package2  
>  输出  
>  package2
>
> 说明
>
> 4个包裹，2个禁止通行信息。
>
> 接下来的4行是每个包裹的名称, 起点, 终点。
>
> 最后2行是两个站点之间无法通行的包裹名称。

# 思路

> 1：简单题，将包裹的起点和重点组装作为key， value为所有发送的包裹。构成一个map结构。
>
> 2：后面遍历所有的检查站不让过的包裹，如果key匹配，则删除value中对应的包裹（如果有的话），放到一个数组中，最后排序输出。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    def comp(a, b):
        return int(a[1]) - int(b[1])
    
    
    #处理输入
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    
    #包裹信息
    package_info = []
    for i in range(m):
        package_info.append(input().split(" "))
    
    #检查站信息
    checkpoint = []
    for i in range(n):
        checkpoint.append(input().split(" "))
    
    
    package_map = {}
    checkpoint_map = {}
    
    for single_package in package_info:
        path = single_package[1] + "-" + single_package[2]
        #合并起点终点作为key
        if path in package_map:
            package_map[path].add(single_package[0])
        else:
            package_map[path] = set()
            package_map[path].add(single_package[0])
    
    
    for single_checkpoint in checkpoint:
        path = single_checkpoint[0] + "-" + single_checkpoint[1]
        #合并起点终点作为key
        if path in checkpoint_map:
            for item in single_checkpoint[2:]:
                checkpoint_map[path].add(item)
        else:
            checkpoint_map[path] = set()
            for item in single_checkpoint[2:]:
                checkpoint_map[path].add(item)
        
    result = set()
    for key in package_map:
        packages = package_map[key]
        if key not in checkpoint_map:
            continue
        banned_package = checkpoint_map[key]
    
        for single_package in packages:
            if single_package in banned_package:
                result.add(single_package)
            
        
    
    
    if (len(result) == 0):
        print("none")
    else:
        result = list(result)
        sorted(result, key=functools.cmp_to_key(comp))
    
        print(" ".join(result))
            
        
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

