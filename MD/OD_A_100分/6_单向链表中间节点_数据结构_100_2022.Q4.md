**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")**************** ​​​​​​​

# 题目

> **题目描述**
>
> 求单向链表中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。
>
> **输入描述：**
>
> 第一行 链表头节点地址path 后续输入的节点数n
>
> 后续输入每行表示一个节点，格式: "节点地址 节点值 下一个节点地址(-1表示空指针)“
>
> 输入保证链表不会出现环，并且可能存在一些节点不属于链表。
>
> **输出描述：**
>
> 链表中间节点值。
>
> **测试用例:**
>
> 输入:
>
> 00010 4  
>  00000 3 -1  
>  00010 5 12309  
>  11451 6 00000  
>  12309 7 11451
>
> 输出:
>
> 6

# 思路

> 1：第一步，根据输入，构建一个 输入节点的列表，用dict来保存。
>
> 2：第二步，根据输入的头节点，先遍历一次，剔除无效节点并记录链表长度size。
>
> 3：第三步，找下标为size/2的节点。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
    
    # 链表节点类
    class ListNode:
        def __init__(self, val="", next=None):
            self.val = val
            self.next = next
    
    
    #处理输入
    head = input().split(" ")
    head_addr = head[0]
    list_count = int(head[1])
    
    #构造节点信息map
    node_info = {}
    for i in range(list_count):
        #节点信息
        input_node_info = input().split(" ")
        addr = input_node_info[0]
        val = int(input_node_info[1])
        next_addr = input_node_info[2]
        temp_node = ListNode(val, next_addr)
        node_info[addr] = temp_node
    
    # 构造链表，剔除无效节点
    size = 1
    cur = 0
    head_node = node_info[head_addr]
    thead = copy.copy(head_node)
    while (thead.next != '-1'):
        size += 1
        thead = node_info[thead.next]
    
    #找中间节点
    while (head_node.next != -1):
        if (int(size / 2) == cur):
            print (head_node.val)
            break;
        head_node = node_info[head_node.next]
        cur += 1
    
    
    
    
    

