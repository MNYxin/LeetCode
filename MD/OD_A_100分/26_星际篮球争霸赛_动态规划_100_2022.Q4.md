**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 在星球争霸篮球赛对抗赛中，最大的宇宙战队希望每个人都能拿到MVP，MVP的条件是单场最高分得分获得者。  
>  可以并列所以宇宙战队决定在比赛中尽可能让更多队员上场，并且让所有得分的选手得分都相同，  
>  然而比赛过程中的每1分钟的得分都只能由某一个人包揽。输出有得分的队员都是MVP时，最少得MVP得分。
>
> **输入描述**
>
> 输入第一行为一个数字 t ，表示为有得分的分钟数 1 ≤ t ≤ 50  
>  第二行为 t 个数字，代表每一分钟的得分 p， 1 ≤ p ≤ 50
>
> **输出描述**
>
> 输出有得分的队员都是MVP时，最少得MVP得分。
>
> **示例1：**
>
> 输入：
>
> 9  
>  5 2 1 5 2 1 5 2 1
>
> 输出：
>
> 6  
>  说明：
>
> 4人MVP，每个人都是6分。

# 思路

> 1：和 [等和子数组最小和](https://renjie.blog.csdn.net/article/details/128062049
> "等和子数组最小和") 一摸一样，就是变了个说法。
>
> 2：首先第一个目标，将数组拆分，每个子数组的和相等。
>
> 比如[2,2,4] 拆分为[2,2] [4]
>
> 3：其次第二个目标，要求所有的可能拆分条件下，子数组的和最小。
>
> 比如 [1,1,1,1] 可以拆分为[1] [1] [1] [1] 和 [1,1] [1,1]
>
> 明显最小的子数组元素之和是1.
>
> 4：和 [leetcode 698](https://leetcode.cn/problems/partition-to-k-equal-sum-
> subsets/solution/hua-fen-wei-kge-xiang-deng-de-zi-ji-by-l-v66o/ "leetcode
> 698") 很像，首先要判定是否能拆分成等和子数组。这里也给出动态规划解法的官方描述：
>
> 用一个整数 S 来表示当前可用的数字集合：从低位到高位，第 i 位为 0 则表示数字 nums[i] 可以使用，否则表示nums[i]
> 已被使用。然后我们用 dp[S] 来表示在可用的数字状态为 S 的情况下是否可能可行，初始全部状态为记录为不可行状态False，只记
> dp[0]=True
> 为可行状态。同样我们每次对于当前状态下从可用的数字中选择一个数字，若此时选择全部数字取模后小于等于per。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终dp[U]
> 即可，其中 U 表示全部数字使用的集合状态。

# 考点

> 1：动态规划

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
     
    def canPartitionKSubsets(nums, k):
        all = sum(nums)
        if all % k:
            return False
        per = all // k
        nums.sort()
        if nums[-1] > per:
            return False
        n = len(nums)
        dp = [False] * (1 << n)
        dp[0] = True
        cursum = [0] * (1 << n)
        for i in range(0, 1 << n):
            if not dp[i]:
                continue
            for j in range(n):
                if cursum[i] + nums[j] > per:
                    break
                if (i >> j & 1) == 0:
                    next = i | (1 << j)
                    if not dp[next]:
                        cursum[next] = (cursum[i] + nums[j]) % per
                        dp[next] = True
        return dp[(1 << n) - 1]
     
     
    #处理输入
    n = int(input())
    nums = [int(x) for x in input().split(" ")]
     
     
    for i in reversed(range(n+1)):
        #从最大的可能行开始，满足条件即为为最小的情况
        if (canPartitionKSubsets(nums, i)):
            print (sum(nums) / i)
            break;
     

