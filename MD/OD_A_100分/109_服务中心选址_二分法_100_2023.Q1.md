**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
>
> 一家快递公司希望在一条街道建立新的服务中心。公司统计了该街道中所有区域在地图上的位置，并希望能够以此为依据为新的服务中心选址：使服务中心到所有区域的距离的总和最小。
>
> 给你一个数组 positions ，其中 positions []=[ left , right ]表示第1个区域在街道上的位置，其中 left
> 代表区域的左侧的起点， right 表示区域的右侧终点，设择服务中心的位置为 location ,
>
> 如果第1个区城的右侧起点 right 满足 right < location ，则第1个区域到服务中心的距离为 location - right ;
> ．如果第 i 个区域的左侧起点 left 满足 left > location ，则第 i 个区城到服务中心的距离为 left - location ;
>
> 如果第 i 个区域的两侧 left , right 满足 left <= location <= right ，则第1个区域到 服务中心的距离为0;
> 选择最佳的服务中心的位置为 location ，请返回最佳的服务中心位置到所有区域的距离总和的最小值。
>
> **输入描述：**  
>  第一行，一个整数N表示区域个数。  
>  后面N行，每行两个整数，表示区域的左右起点终点。  
>  **输出描述：**
>
> 运行结果输出一个整数，表示服务中心位置到所有区域的距离总和的最小值
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> 输入
>
> 3
>
> 1 2
>
> 3 4
>
> 10 20
>
> 输出
>
> 8
>
> ![](https://img-blog.csdnimg.cn/01c98a219e2746039c4ce63cb44a1208.jpeg)

# 思路

> ~~1：这个题目和[新学校选址](https://renjie.blog.csdn.net/article/details/128319419
> "新学校选址") 这个很类似，只不过点变成了区间。~~
>
> ~~2：首先就是要 **将区间的左右起点，转成一个点** 。~~
>
> ~~以示例1为例子，~~
>
> ~~**首先是第一个区域，选择右终点，距离其他的区域肯定更近。**~~
>
> ~~**其次是最后一个区域，选择左起点，距离其他的区域肯定更近。**~~
>
> ~~**对于中间的区域，如果当前区域在左边，那么选择右端点，如果当前区域在右边，那么选择左端点。**~~
>
>
> ~~3：想象一数轴，任意找一个点，它左边有4个点，右边有2个点，把该点往左移动一点点，不要移动太多，以免碰到其他输入点。假设移动了d单位距离，则该点到左边4个点的距离各减少d，该点都右边2个点的距离各增加d,但总的来说，距离之和减少了2d。~~
>
> ~~同理，该点的左边有2个点，右边有4个点时，类似，不过此时应该是向右移动。~~
>
>
> ~~换句话说，只要该点的左右两边的输入点个数不一样多，就不是最优解。那什么情况下，左右点一样多勒？如果输入点有奇数个，则最优解应该是中间那个点即中位数。如果有偶数个，则可以位于最中间两个点的任意位置（还是中位数）。~~
>
> ~~凡是可以转换为这个模型的问题都能用中位数求解。~~
>
> ~~4：最后的话，排序求中位数即可。~~
>
> ~~5：唯一一个不明确的地方就是，如果这些区域有重叠，好像就不适用这个方法了，不过直接暴力双循环，求一下应该也能过个30%、40%。~~
>
> 6：确实有重叠。。。二分求解。

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
    
     
    # 处理输入
    # 处理输入
    n = int(input())
    
    
    def cal(pos,centers):
        dis = 0
        for center in centers:
            if (center[1] < pos):
                dis += pos - center[1]
            elif (pos < center[0]) :
                dis += center[0] - pos
        return dis
    
    
    centers = []
    center_points = []
    for i in range(n):
        center = [float(x) for x in input().split(" ")]
        centers.append(center)
        for i in range(len(center)):
            center_points.append(center[i])
    center_points.sort()
    min_pos = center_points[0]
    max_pos = center_points[-1]
    
    
    flag = False
    while (min_pos < max_pos):
        mid_pos = math.ceil((min_pos + max_pos) / 2)
    
        distance = cal(mid_pos, centers)
        distance_left = cal(mid_pos - 0.5, centers)
        distance_right = cal(mid_pos + 0.5, centers)
    
        if (distance <= distance_left and distance <= distance_right):
            print(int(distance))
            flag = True
            break
    
        if (distance < distance_left):
            min_pos = mid_pos + 0.5
            continue
    
        if (distance < distance_right):
            max_pos = mid_pos - 0.5
    
    
    if (not flag):
        print(0)
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

