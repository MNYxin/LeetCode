**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 有N条线段，长度分别为a[1]-a[n]。  
>  现要求你计算这N条线段最多可以组合成几个直角三角形。  
>  **每条线段只能使用一次** ，每个三角形包含三条线段。
>
> **输入描述**  
>  第一行输入一个正整数T(1<=T<=100)，表示有T组测试数据.  
>  对于每组测试数据，接下来有T行，  
>  每行第一个正整数N，表示线段个数(3<=N<=20)，接着是N个正整数，表示每条线段长度，(0<a[i]<100)。
>
> **输出描述**  
>  对于每组测试数据输出一行，每行包括一个整数，表示最多能组合的直角三角形个数
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**  
>  输入
>
> 1
>
> 7 3 4 5 6 5 12 13  
>  输出
>
> 2
>
> ![](https://img-blog.csdnimg.cn/9bd3845cf20c4a8f8420d420cf885ef4.jpeg)

# 思路

>
> 1：简单题，直接全组合就可以了，leetcode上也有类似的题目：[leetcode40](https://leetcode.cn/problems/combination-
> sum-ii/solution/ "leetcode40")

# 考点

> 1：全组合

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    def dfs( lines, index):
        maxVal = 0
        a=0
        b=0
        c=0
        for i in range(index, len(lines)-2) :
            a = lines[i]
            if (a == 0):
                continue
            
            for j in range(i+1, len(lines)-1) :
                b = lines[j]
                if (b == 0):
                    continue
                
                for k in range(j+1, len(lines)) :
                    c = lines[k]
                    if (c == 0):
                        continue
                    
                    if ((a*a + b*b) == c*c):
                        lines[i]=0
                        lines[j]=0
                        lines[k]=0
                        maxVal = max(maxVal, dfs(lines,i+1) +1)
                        lines[i]=a
                        lines[j]=b
                        lines[k]=c
        return maxVal
    
    # 处理输入
    n = int(input())
    for i in range(n):
        #先进行去重
        params = [int(x) for x in input().split(" ")]
        N = params[0]
        nums = params[1:]
        nums.sort()
    
        print(dfs(nums, 0))
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

