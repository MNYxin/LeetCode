**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
**[C++ 实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")** 、
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****

# 题目

> 数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母。
>
> 0 关联 "a","b","c"
>
> 1 关联 "d","e","f"
>
> 2 关联 "g","h","i"
>
> 3 关联 "j","k","l"
>
> 4 关联 "m","n","o"
>
> 5 关联 "p","q","r"
>
> 6 关联 "s","t"
>
> 7 关联 "u","v"
>
> 8 关联 "w","x"
>
> 9 关联 "y","z"
>
> 例如7关联"u","v"，8关联"x","w"，输入一个字符串例如“78”，
>
>
> 和一个屏蔽字符串“ux”,那么“78”可以组成多个字符串例如：“ux”，“uw”，“vx”，“vw”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。
>
> **示例：**
>
> 输入：
>
> 78
>
> ux
>
> 输出：
>
> uw vx vw
>
> 说明：ux完全包含屏蔽字符串ux，因此剔除

# 思路

> 1：重点在于递归求出字符的排列组合
>
>
> **2：感谢评论区提醒，【完全包含屏蔽字符串的每一个字符的字符串】之前对这句话的理解有误，只要包含屏蔽字符串中的每一个字符即可，顺序和数量都不用考虑，所以应该单独写一个判断函数，利用set来找到每一个字符，并做过滤判断。**

# 考点

> 1：递归法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
    #保存排列组合字符串
    res_str_list = []
    
    #预设值
    num_char_map = {}
    num_char_map['0'] = "abc"
    num_char_map['1'] = "def"
    num_char_map['2'] = "ghi"
    num_char_map['3'] = "jkl"
    num_char_map['4'] = "mno"
    num_char_map['5'] = "pqr"
    num_char_map['6'] = "st"
    num_char_map['7'] = "uv"
    num_char_map['8'] = "wx"
    num_char_map['9'] = "yz"
    
    #递归求排列组合
    def dfs(num_str, temp_list, index):
        if(index == len(num_str)):
            res_str_list.append("".join(temp_list))
            return
        temp_list_back_up = copy.copy(temp_list)
        for single_char in num_char_map[num_str[index]]:
            temp_list.append(single_char)
            dfs(num_str, temp_list, index+1)
            temp_list.pop()
    
    
    #处理输入
    num_str = input()
    block_str = input()
    dfs(num_str, [], 0)
    
    def check(string1, string2):
        set1 = set()
        for x in string1:
            set1.add(x)
    
        set2 = set()
        for x in string2:
            set2.add(x)
    
        for x in set2:
            if x not in set1:
                return False
        return True
    
    #过滤
    for single_str in res_str_list:
        if check( single_str,block_str):
            res_str_list.remove(single_str)
    
    print (" ".join(res_str_list))
    
    

