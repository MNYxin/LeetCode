**所有题目均有五种语言实现。
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")** 、 ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")****** 、 ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")****** 、 ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****** 、 ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")********

# 题目

> 给定两个字符串 s1 和 s2 和正整数k，其中 s1 长度为 n1，s2 长度为 n2，  
>  在s2中选一个子串，满足:
>
> 1：该子串长度为n1+k  
>  2：该子串中包含s1中全部字母，  
>  3：该子串每个字母出现次数不小于s1中对应的字母，  
>  我们称s2以长度k冗余覆盖s1，  
>  给定s1，s2，k,  
>  求最左侧的s2以长度k冗余覆盖s1的子串的首个元素的下标，  
>  如果没有返回-1。
>
> **输入描述：**
>
> 输入为三行
>
> 第一行为 s1
>
> 第二行为 s1
>
> 第三行为 k
>
> s1和s2都只包含小写字母
>
> **输出描述：**
>
> 最左侧的 s2 以长度 k 冗余覆盖 s1 的子串的首个元素下标，若不存在，则返回-1.
>
> **示例1：**
>
> 输入：
>
> ab  
>  aabcd  
>  1
>
> 输出：
>
> 0  
>  **示例2：**
>
> 输入：
>
> abc  
>  dfs  
>  10  
>  输出：
>
> -1

# 思路

> 1：比较简单的题目了，核心就是实现那三条满足条件。
>
> 2：核心数据结构就是用 数组来保存统计好的字符出现次数来判断满足条件。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
     
    def get_char_count(input_str):
        char_count_dict = {}
        for i in input_str:
            if i in char_count_dict:
                char_count_dict[i] += 1
            else: 
                char_count_dict[i] = 1
        return char_count_dict
     
    #处理输入
    s1 = input()
    s2 = input()
    k = int(input())
     
    def cal(s1, s2, k):
    	# 数组的下标就是字母的ASCII码
    	s1_char_count = [0 for x in range(128)]
    	for i in range(len(s1)):
    		s1_char_count[ord(s1[i])]+=1
     
     
    	# s1字符总数
    	total = len(s1)
     
    	# s2中出现s1字符的个数，先统计固定长度
    	for j in range(len(s1)+k):
    		
    		if (s1_char_count[ord(s2[j])] > 0):
    			total-=1
    		s1_char_count[ord(s2[j])]-=1
    		
     
    		if (total == 0):
    			return 0
     
    	#滑动窗口求解
    	for i in range(1, len(s2)-len(s1)-k):
    		
    		if (s1_char_count[ord(s2[i-1])] >= 0):
    			total+=1
    		s1_char_count[ord(s2[i-1])]+=1;
     
    		if (s1_char_count[ord(s2[i - 1 + len(s1) + k])] > 0):
    			total-=1
    		s1_char_count[ord(s2[i - 1 + len(s1) + k])]-=1
     
    		if (total == 0):
    			
    			return i
    	return -1
     
    #长度限制，不可能存在覆盖子串
    if (len(s2) < len(s1) + k):
        print (-1)
    else:
        print(cal(s1, s2, k))
     
     
     

