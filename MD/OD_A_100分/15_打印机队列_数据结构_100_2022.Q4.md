**所有题目均有五种语言实现。 ** **
**[C语言实现目录](https://renjie.blog.csdn.net/article/details/129190260
"C语言实现目录")****** 、 ** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 有5台打印机打印文件，每台打印机有自己的待打印队列。因为打印的文件内容有轻重缓急之分，
>
> 所以队列中的文件有1~10不同的代先级，其中 **数字越大优先级越高** 。
>
> 打印机会从自己的待打印队列中选择 _ **优先级最高**_ 的文件来打印。
>
> 如果存在两个优先级一样的文件，则选择 _ **最早进入队列**_ 的那个文件。
>
> 现在请你来模拟这5台打印机的打印过程。
>
> **输入描述**
>
> 每个输入包含1个测试用例，每个测试用例第一行给出发生事件的数量N（0 < N < 1000）。  
>  接下来有 N 行，分别表示发生的事件。  
>  共有如下两种事件：  
>  1\. “IN P NUM”，表示有一个拥有优先级 NUM 的文件放到了打印机 P 的待打印队列中。（0< P <= 5, 0 < NUM <=
> 10)；  
>  2\. “OUT P”，表示打印机 P 进行了一次文件打印，同时该文件从待打印队列中取出。（0 < P <= 5）。
>
> **输出描述**
>
> 对于每个测试用例，每次”OUT P”事件，请在一行中 **输出文件的编号** 。  
>  如果此时没有文件可以打印，请输出” **NULL** “。  
>  文件的编号定义为”IN P NUM”事件发生第 x 次，此处待打印文件的编号为x。编号从 **1** 开始。
>
> **示例1** 输入输出示例仅供调试，后台判断数据一般不包含示例
>
> **输入**
>
> `7`  
> `IN 1 1`  
> `IN 1 2`  
> `IN 1 3`  
> `IN 2 1`  
> `OUT 1`  
> `OUT 2`  
> `OUT 2`
>
> **输出**
>
> `3`  
> `4`  
> `NULL`

# 思路

> 1：考察的重点是数据结构 + 自定义排序
>
> 2：每OUT一次之前就排序一次，说实话我这个解法也不一定能够过100%用例。
>
> 3：放一个评论区大佬的最小堆解法，应该能避免超时问题。

# 考点

> 1：数据结构 + 自定义排序

# Code

100%通过率 优先级队列

    
    
    import queue
    import functools
    
    #文件的定义
    class File:
        def __init__(self, file_id, priority, index):
            self.file_id = file_id
            self.priority = priority
            self.index = index
     
        def __lt__(self, other):
            if self.priority != other.priority:
                return self.priority > other.priority
            else:
                return self.index < other.index
     
     
    # 输入处理
    count = int(input())
    files = []
    for i in range(count):
        files.append(input().split())
    printer = {}
    
    file_id = 1
    for i in range(len(files)):
        file = files[i]
    
        type = file[0]
        print_id = file[1]
    
        if type == "IN":
            priority = file[2]
            if printer.get(print_id) is None:
                printer[print_id] = queue.PriorityQueue()
            printer[print_id].put(File(file_id, int(priority), i))
            file_id += 1
        else:
            if printer.get(print_id) is None or printer[print_id].qsize() == 0:
                print("NULL")
            else:
                t = printer[print_id].get()
                print(t.file_id)

之前模拟的方法，不确定通过率

    
    
    # coding:utf-8
    import functools
    
    def comp(a, b):
        if a[0] == b[0]:
            return b[1] - a[1]
        else:
            return b[0] - a[0]
    
    
    #处理输入
    count = int(input())
    print_machines = []
    for i in range(6):
        print_machines.append([])
    
    file_count = 0
    for i in range(count):
        input_info = input().split(" ")
        if input_info[0] == "IN":
            file_count += 1
            print_machines[int(input_info[1])].append((int(input_info[2]), file_count))
        else:
            #排序
            for i in range(6):
                print_machines[i] = sorted(print_machines[i], key= functools.cmp_to_key(comp))
            if len(print_machines[int(input_info[1])]) > 0 :
                print (print_machines[int(input_info[1])][0][1])
                print_machines[int(input_info[1])] = print_machines[int(input_info[1])][1:]
            else:
                print ("NULL")
    
    
    

