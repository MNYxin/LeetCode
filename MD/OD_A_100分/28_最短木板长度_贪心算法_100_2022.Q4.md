**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 小明有 n 块木板，第 i ( 1 ≤ i ≤ n ) 块木板长度为 ai。  
>  小明买了一块长度为 m 的木料，这块木料可以切割成任意块，  
>  拼接到已有的木板上，用来加长木板。  
>  小明想让最短的木板尽量长。  
>  请问小明加长木板后，最短木板的长度可以为多少？
>
> **输入描述**  
>  输入的第一行包含两个正整数，n(1≤n≤10^3),m(1≤m≤10^6)  
>  n表示木板数，m表示木板长度。输入的第二行包含n个正整数，a1,a2,...an(1≤ai≤10^6)。  
>  **输出描述**  
>  输出的唯一一行包含一个正整数，表示加长木板后，最短木板的长度最大可以为多少？
>
> 示例一：  
>  输入：
>
> 5 3  
>  4 5 3 5 5  
>  输出：
>
> 5
>
> 说明：  
>  给第1块木板长度增加1，给第3块木板长度增加2后，  
>  这5块木板长度变为[5,5,5,5,5]，最短的木板的长度最大为5。
>
> 示例二：  
>  输入：
>
> 5 2  
>  4 5 3 5 5  
>  输出：
>
> 4
>
> 给第3块木板长度增加1后，  
>  这5块木板长度变为[4,5,4,5,5]，剩余的木料长度为1。此时剩余木料无论给哪块木板加长，最短木料的长度都为4。

# 思路

> 1：还是贪心的思想，遍历给的木料长度，每次都补一下最短的木板（只拿出1m的长度），每次补完之后重新排序，找到最短继续补1m, 重复此步骤，直到木料用完。
>
>
> 2：但是第一步中，每一次补完都需要重新排序，按照题目中给出的数量级，肯定达不到100%通过率。什么数据结构能够在每次修改之后都能够自己完成最快的排序呢，没错，就是最大堆/最小堆，具体的实现就是优先级队列。可以从O(M*N*logN)
> 减为 O(M*logN)

# 考点

> 1：贪心算法

# Code

暴力排序：

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    #处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    m = params[1]
    woods = [int(x) for x in input().split(" ")]
    
    woods = sorted(woods)
    result = 0;
    
    #遍历给的木料长度，每次都补一下最短的木板，每次补完之后重新排序，重复此步骤。
    for i in range(m):
        woods[0] = woods[0] + 1
        woods = sorted(woods)
        result = max(result, woods[0])
    
    print(result)
    
    
    
    
    

优先级队列实现方法：

    
    
    import queue
    import math
    
    # 并查集
    class UnionFindSet:
        def __init__(self, n):
            self.fa = [idx for idx in range(n)]
            self.count = n
     
        def find(self, x):
            if x != self.fa[x]:
                self.fa[x] = self.find(self.fa[x])
                return self.fa[x]
            return x
     
        def union(self, x, y):
            x_fa = self.find(x)
            y_fa = self.find(y)
     
            if x_fa != y_fa:
                self.fa[y_fa] = x_fa
                self.count -= 1
     
    
    #处理输入
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    m = params[1]
    woods = [int(x) for x in input().split(" ")]
    
    woods_count = {}
    for wood in woods:
        if wood not in woods_count:
            woods_count[wood] = 1
        else:
            woods_count[wood] += 1
    
    #用木板的长度作为优先级队列的排序键 <length, count>
    pq = queue.PriorityQueue()
    for length in woods_count.keys():
        pq.put((length, woods_count[length]))
    
    flag = False
    
    
    while m > 0:
        # 特殊情况：只有一种板长度
        if pq.qsize() == 1:
            print(pq.queue[0][0] + math.floor(m / pq.queue[0][1])) 
            flag = True
            break
        else:
            wood_kind_1 = pq.get()
            wood_kind_2 = pq.queue[0]
    
            diff = wood_kind_2[0] - wood_kind_1[0]
            total = diff * wood_kind_1[1]
    
            if total > m:
                print(wood_kind_1[0] + math.floor(m / wood_kind_1[1]))
                flag = True
                break
            elif total == m:
                print(wood_kind_2[0])
                flag = True
                break
            else:
                m -= total
                pq.queue[0] = (wood_kind_2[0],wood_kind_1[1]+wood_kind_2[1])
    
    if not flag:
        print(pq.queue[0][0])
    
    
    
    
    

