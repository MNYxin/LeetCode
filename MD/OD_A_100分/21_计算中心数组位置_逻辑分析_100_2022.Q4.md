**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 给你一个整数数组nums，请计算数组的中心位置，数组的中心位置是数组的一个下标，
>
> 其左侧所有元素相乘的积等于右侧所有元素相乘的积。数组第一个元素的左侧积为1，最后一个元素的右侧积为1。
>
> 如果数组有多个中心位置，应该返回最靠近左边的那一个，如果数组不存在中心位置，返回 **-1** 。
>
> **输入描述**
>
> 输入只有一行，给出N个正整数用空格分隔：nums = 2 5 3 6 5 6
>
> 1 <= nums.length <= 1024
>
> 1 <= nums[i] <= 10
>
> **输出描述**
>
> **输出**
>
> 3
>
> 解释：中心位置是3
>
> **示例1** 输入输出示例仅供调试，后台判题数据一般不包含示例
>
> **输入**
>
> `2 5 3 6 5 6`
>
> **输出**
>
> `3`

# 思路

> 1：明显的用空间换时间的题，创建两个数组，分别保存当前位置的左边数组的乘积和右边数组的乘积。
>
> 可得左边数组乘积
>
> left[i] = left[i-1] * v[i-1]
>
> 明显有一个递归的关系，这样就不用重复的算乘积了。同理可推到右边数组的乘积
>
> 2：根据当前数组的位置来取出左右数组的乘积进行对比即可。复杂度O(n)

# 考点

> 1：空间换时间

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    def comp(a, b):
        if a[0] == b[0]:
            return a[1] - b[1]
        else:
            return a[0] - b[0]
    
     
    # 处理输入
    nums = [int(x) for x in input().split(" ")]
    
    if len(nums) == 1:
        print(0)
    else:
        left_result =1
        right_result = 1
        flag = False
        for i in nums:
            right_result = right_result*i
    
        for i in range(len(nums)):
            if(i!=0):
                left_result = left_result * nums[i-1]
            
            right_result = right_result / nums[i]   
            if(left_result == right_result):
                print(i)
                flag = True
                break
    
        if not flag:
            print(-1)
    
    

