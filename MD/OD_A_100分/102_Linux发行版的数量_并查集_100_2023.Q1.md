**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述:**
>
>
> Linux操作系统有多个发行版，distrowatch.com提供了各个发行版的资料。这些发行版互相存在关联，例如Ubuntu基于Debian开发，而Mint又基于Ubuntu开发，那么我们认为Mint同Debian也存在关联。
>
> 发行版集是一个或多个相关存在关联的操作系统发行版，集合内不包含没有关联的发行版。给你一个nxn的矩阵 isConnected
> ，其中isConnected[i][i]=1表示第i个发行版和第j个发行版直接关联，而 isConnected[illi]=0 表示二者不直接相连。
>
> 返回最大的发行版集中发行版的数量![](https://img-
> blog.csdnimg.cn/1b8216610bfc41a8ae9a877948bf8587.jpeg)
>
> **输入描述:**  
>  第一行输入发行版的总数量N，之后每行表示各发行版间是否直接相关  
>  **输出描述:**  
>  输出最大的发行版集中发行版的数量  
>  补充说明:  
>  1 <= N <= 200
>
> **示例1**
>
> 输入:  
>  4  
>  1 1 0 0
>
> 1 1 1 0
>
> 0 1 1 0
>
> 0 0 0 1
>
> 输出:  
>  3

# 思路

>
> 1：注意审题，有小伙伴表示看不懂题目的。关键在于输入描述，每一行代表一个发行版，而每一行的数字代表其与其他发行版之间的关联。比如第二行的第三个数字为1，就表示第二个发行版与第三个发行版之间直接关联。
>
> 2：类似 [计算快递业务主站点](https://renjie.blog.csdn.net/article/details/128418116
> "计算快递业务主站点")
> 哪个题目，同样是用回溯法，代码几乎完全一致。从每一个版本出发，将直接相连的置为已关联(可以用一个集合或者map来保存已到达的站点)，最后统计各个发行版本集的版本个数。

# 考点

> 1：回溯法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
    import copy
    
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
    
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
    
    
    
    def check(site_set,n,matrix):
        for i  in range(len(matrix)):
            if(i in site_set):    
                continue        
            if(n != i and matrix[n][i] == 1):
                site_set.add(i)
                check(site_set, i,matrix)
     
     
     
    #处理输入
    N = int(input())
    matrix = []
    for i in range(N):
        matrix.append([int(x) for x in input().split(" ")])
     
    uf = UF(N)
     
    for i in range(N):
        for j in range(i + 1, N):  
            if matrix[i][j] == 1:
                uf.union_connect(i, j)
    res_map = {}
     
    for i in range(N):
        item = uf.find(uf.item[i])
        res_map[item] = res_map.get(item, 0) + 1
     
    print(max(res_map.values()))
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

