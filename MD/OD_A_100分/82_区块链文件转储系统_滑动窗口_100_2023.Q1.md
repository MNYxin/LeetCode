**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>  区块链底层存储是一个链式文件系统，由顺序的N个文件组成，每个文件的大小不一，依次为F1.F2...Fn。随着时间的推移，所占存储会越来越大。  
>  云平台考虑将区块链按文件转储到廉价的SATA盘，只有连续的区块链文件才能转储到SATA盘上，且转的文件之和不能超过SATA盘的容量。  
>  假设每块SATA盘容量为M，求能转储的最大连续文件之和。  
>  **输入描述**  
>  第一行为SATA盘容量M，1000 <= M <= 1000000  
>  第二行为区块链文件大小序列F1,F2,...,Fn。其中 1<= n <=100000，1<= Fis <= 500  
>  **输出描述**  
>  求能转储的最大连续文件大小之和
>
> **示例1：**
>
> 输入
>
> 1000  
>  100 300 500 400 400 150 100  
>  输出  
>  950  
>  说明  
>  最大序列和为950，序列为[400,400,150]
>
> **示例2：**
>
> 输入：  
>  1000  
>  100 500 400 150 500 100
>
> 输出：  
>  1000
>
> 说明：  
>  最大序列和为1000，序列为[100,500,400]

# 思路

> 1：本质上就是求解连续子数组的和，如果满足最接近最大值M，则输出这个连续子数组。
>
> 2：几乎和 [leetcode209](https://leetcode-cn.com/problems/minimum-size-subarray-
> sum "leetcode209") 逻辑一样，就是输出条件换了下。
>
> 3：不过还是比较简单的滑动窗口题目，
>
>   * 窗口内总和大了，sum减去左边界，左端边界+1
>   * 窗口内总和小了，右边界+1，sum加上右边界
>   * 窗口内总和==M，直接return
>

# 考点

> 1：滑动窗口法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
    
    
    #处理输入
    M = int(input())
    
    F = [int(x) for x in input().split(" ")]
    
    # 窗口左右边界
    left = 0
    right = 0
    #窗口和
    window_sum = 0
    #最大窗口和
    window_max = 0
    
    find_M_flag = False
    while (right < len(F)):
        temp = window_sum + F[right]
    
        # 窗口内总和大了，sum减去左边界，左端边界+1
        if (temp > M):
            window_sum -= F[left] 
            left += 1
        
        # 窗口内总和小了，右边界+1，sum加上右边界
        elif (temp < M):
            window_sum += F[right]
            window_max = max(window_sum, window_max)
            right += 1
        
        # 窗口内总和==M，直接return
        else:
            print(M)
            find_M_flag = True
            break
        
    
    if not find_M_flag:
        print(window_max)
    
    
    
    
    
    

