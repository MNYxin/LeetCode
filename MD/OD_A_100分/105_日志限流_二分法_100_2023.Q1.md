**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 某软件系统会在运行过程中持续产生日志，系统每天运行N单位时间，运行期间每单位时间产生的日志条数保行在数组
> records中。records[i]表示第i单位时间内产生日志条数。  
>  由于系统磁盘空间限制，每天可记录保存的日志总数上限为total条。
>
>   *
> 如果一天产生的日志总条数大于total，则需要对当天内每单位时间产生的日志条数进行限流后保存，请计算每单位时间最大可保存日志条数limit，以确保当天保存的总日志条数不超过total。
>

>
> 1：对于单位时间内产生日志条数不超过limit的日志全部记录保存:  
>  2：对于单位时间内产生日志条数超过limit的日志，则只记录保存limit条日志;
>
>   * 如果一天产生的日志条数总和小干等于total，则不需要启动限流机制，result为-1。请返回result的最大值或者-1。
>

>
> **输入描述**  
>  第一行为系统某一天运行的单位时间数N.1<=N<=10^5  
>  第二行为表示这一天每单位时间产生的日志数量的数组records，0<= records[i]<=
> 10^5第三行为系统一天可以保存的总日志条数total。1 <= total <= 10^9
>
> **输出描述**  
>  每单位时间内最大可保存的日志条数limit，如果不需要启动限流机制，返回-1。
>
> **示例1：输入输出示例仅供调试，后台判题数据一般不包含示例**  
>  输入
>
> 6  
>  3 3 8 7 10 15
>
> 40  
>  输出
>
> 9

# 思路

> 1：纯逻辑分析题目，将两种情况实现即可。
>
> 2：对于一天产生的日志总条数大于total，可以使用 **二分法** 来找到对应的limit结果。
>
> ![](https://img-blog.csdnimg.cn/4eae5ec4b93d47d1a2e000cec31631e9.png)

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
    
     
    # 处理输入
    N = int(input())
    records = [int(x) for x in input().split(" ")]
    total = int(input())
    single_total = sum(records)
     
    find_flag = False
    
    # 一天产生的日志总条数小于等于total
    if(single_total <= total):
        print(-1)
    else:
        records.sort()
        #二分法初始化
        left = total / N
        right = records[N - 1]
        result = left
        while (right > left+1):
            mid = int((right + left) / 2)
        
            temp_total = 0
            for i in range(N):
                temp_total += min(records[i], mid)
            
        
            if (temp_total > total):
                right = mid
            elif (temp_total < total):
                left = mid
                result = mid
            else:
                print(mid)
                find_flag = True
            
        if not find_flag:
            print(result)
    
    
    
    

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

