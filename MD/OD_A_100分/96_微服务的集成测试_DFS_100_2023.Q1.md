**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 现在有n个容器服务，服务的启动可能有一定的依赖性(有些服务启动没有依赖)，其次服务自身启动加载会消耗些时间。  
>  给你一个nxn 的二维矩阵 useTime，其中 useTime[i][i]=10
> 表示服务i自身启动加载需要消耗10s，useTime[i][j]=1 表示服务i 启动依赖服务i 启动完成，useTime[i][k]=0，表示服务i
> 启动不依赖服务 k其实 0<= i,j，k<
> n。服务之间启动没有循环依赖(不会出现环)，若想对任意一个服务i进行集成测试(服务追身也需要加载)，求最少需要等待多少时间。  
>  **输入描述**  
>  第一行输入服务总量 n.
>
> 之后的 n 行表示服务启动的依赖关系以及自身启动加载耗时
>
> 最后输入 k 表示计算需要等待多少时间后可以对服务 k 进行集成测试
>
> 其中 1 <= k <=n. 1<=n<=100  
>  **输出描述**  
>  最少需要等待多少时间(s)后可以对服务 k 进行集成测试
>
> 示例1
>
> 输入:
>
> 3
>
> 5 0 0
>
> 1 5 0
>
> 0 1 5
>
> 3  
>  输出:  
>  15

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

# 考点

> 1：递归

# Code

    
    
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    import sys
     
    num = int(input())
    maps = []
    for i in range(num):
        maps.append(list(map(int, input().split())))
    res_num = int(input()) - 1
    dp = [0 for i in range(num + 1)]
    
    def dfs(k, maps):
        time = 0
    
        for i in range(len(maps[k])):
            if i != k and maps[k][i] == 1:
                if dp[i + 1] > 0:
                    time = max(time, dp[i + 1])
                else:
                    time = max(time, dfs(i, maps))
            dp[k + 1] = time + maps[k][k]
    
        return time + maps[k][k]
    
    print(dfs(res_num, maps))

