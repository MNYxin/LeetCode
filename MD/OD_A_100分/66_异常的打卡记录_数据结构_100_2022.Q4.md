**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**  
>
> 考勤记录是分析和考核职工工作时间利用情况的原始依据，也是计算职工工资的原始依据，为了正确地计算职工工资和监督工资基金使用情况，公司决定对员工的手机打卡记录进行异常排查。  
>  如果出现以下两种情况，则认为打卡异常  
>  1.实际设备号与注册设备号不一样  
>  2.或者，同一个员工的两个打卡记录的时间小于60分钟并且打卡距离超过5km。  
>  给定打卡记录的字符串数组clockRecords (每个打卡记录组成为: 工号:时间
> (分钟);打距离(km);实际设备号;注册设备号)，返回其中异常的打卡记录(按输入顺序输出)。  
>  **输入描述**  
>  第一行输入一个数字N，为打卡记录的条数。
>
> 后续N行记录分别表示打卡记录：工号:时间 (分钟);打距离(km);实际设备号;注册设备号，以逗号间隔。  
>  **输出描述**  
>  输出异常的打卡记录，以 **分号** 间隔。若无异常打卡记录，则输出字符串null
>
> **示例1：**  
>  输入
>
> 2  
>  100000,10,1,ABCD,ABCD  
>  100000,50,10,ABCD,ABCD  
>  输出
>  
>  
>     100000,10,1,ABCD,ABCD;100000,50,10,ABCD,ABCD
>
> 说明  
>  无
>
> **示例2：**
>
> 输入
>
> 2  
>  100000,10,1,ABCD,ABCD  
>  100001,80,10,ABCE,ABCE  
>  输出
>
> null  
>  说明  
>  无异常打卡记录，所以返回null

# 思路

> 1：算是比较简单的一个题目了，直接实现两种异常即可。
>
> 2：两个for循环搞定。

# 考点

> 1：数据结构

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    def comp(a, b):
        return int(a[1]) - int(b[1])
     
    #处理输入
    n = int(input())
    clock_records = []
    for i in range(n):
        clock_records.append(input().split(","))
    
    # 存放每位员工的打卡记录
    record_map = {}
    result = set()
    
    # 初始化map时实现异常规则1
    for i in range(n):
        # 题目要求按输入顺序输出，加一个索引 i 
        single_record = clock_records[i]
        clock_records[i].append(str(i));
    
        if (single_record[3]!=(single_record[4])):
            result.add(i); 
        else:
            if (single_record[0] in record_map):
                record_map[single_record[0]].append(single_record)
            else:
                record_map[single_record[0]] = []
                record_map[single_record[0]].append(single_record)
    
    # 异常规则2
    for key in record_map:
        records = record_map[key];
    
        #用打卡时间来排序，以加速后续的双层循环。
        records = sorted(records, key=functools.cmp_to_key(comp))
        #records.sort((a, b) -> Integer.parseInt(a[1]) - Integer.parseInt(b[1]));
    
        for i in range(len(records)):
            time1 = int(records[i][1])
            dist1 = int(records[i][2])
            for j in range(i+1, len(records)):
                time2 = int(records[j][1])
                dist2 = int(records[j][2])
        
                # 如果当前的两次打卡时间超过60分, 那么后面的肯定也超过60分钟了
                if (time2 - time1 >= 60):
                    break
                else:
                    if (abs(dist2 - dist1) > 5):
                        result.add(int(records[i][5]))
                        result.add(int(records[j][5]))
    
    
    # 输出
    if (len(result) == 0):
        print("null")
    else:
        res_str = "";
        for index in result:
            clock_records[index].pop()
            res_str += ",".join(clock_records[index]) + ";"
        print(res_str[0:len(res_str)-1]);
    
    
    
    
    

