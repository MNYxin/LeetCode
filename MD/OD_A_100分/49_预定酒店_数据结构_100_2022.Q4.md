**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 放暑假了，小明决定到某旅游景点游玩，他在网上搜索到了各种价位的酒店(长度为n的 数组A)，他的心理价位是x元，请帮他筛选出k个最接近x元的酒店
> (n>=k>0) ,并由低到高打印酒店的价格  
>  **输入描述**  
>  第一行: n,k，x  
>  第二行: A[o] A[1] A[2]...A[n-1]  
>  **输出描述**  
>  从低到高打印筛选出的酒店价格  
>  **示例一**  
>  输入
>
> 10 5 6  
>  1 2 3 4 5 6 7 8 9 10  
>  输出
>
> 4 5 6 7 8
>
> **示例二**
>
> 输入
>
> 10 4 6  
>  10 9 8 7 6 5 4 3 2 1  
>  输出
>
> 4 5 6 7
>
> 说明  
>  数组长度n = 10，筛选个数 k = 4，目标价位x = 6  
>  当4 和8 距离x 相同时，优先选择价格低的4  
>  **示例三**  
>  输入  
>  6 3 1000  
>  30 30 200 500 70 300  
>  输出  
>  200 300 500  
>  备注  
>  1.酒店价格数组A和小明的心理价位x均为整型数据;(0<n,k,x<10000)  
>
> 2.优先选择价格最接近心理价位的酒店，若两家酒店和心理价位差价相同，则选择价格较低的酒店。(比如100元和300元距离心理价位200元同样接近，此时选择100元)  
>  3.酒店价格可能相同重复

# 思路

> 1：核心就是实现备注中的那条排序规则，本质考察的还是自定义排序。

# 考点

> 1：排序

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import sys
    from collections import Counter, defaultdict
    import copy
    from itertools import permutations
    import re
    import math
    
    def comp(a, b):
        if a[1] == b[1]:
            return a[0] - b[0]
        return a[1] - b[1]
        
    
    params = [int(x) for x in input().split(" ")]
    n = params[0]
    k = params[1]
    x = params[2]
    
    #先对价格排序
    prices = [int(x) for x in input().split(" ")]
    prices = sorted(prices)
    
    price_rating = [];
    for i in range(len(prices)):
        temp = []
        temp.append(prices[i])
        temp.append(abs(prices[i] - x))
        price_rating.append(temp)
    
    
    #自定义排序
    sorted_prices = sorted(price_rating, key= functools.cmp_to_key(comp))
    
    picked_price = []
    for i in range(k):
        picked_price.append(sorted_prices[i][0])
    
    picked_price = sorted(picked_price)
    
    print (" ".join([str(x) for x in picked_price]))
              
    
    

