**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **一、题目**
>
> 输入一个长度为4的倍数的字符串，字符串中仅包含WASD四个字母。
>
>
> 将这个字符串中的连续子串用同等长度的仅包含WASD的字符串替换，如果替换后整个字符串中WASD四个字母出现的频数相同，那么我们称替换后的字符串是“完美走位”。
>
> 求子串的最小长度。
>
> 如果输入字符串已经平衡则输出0。
>
> **二、输入**  
>  一行字符表示给定的字符串s
>
> 数据范围：  
>  1<=n<=10^5且n是4的倍数，字符串中仅包含WASD四个字母。
>
> **三、输出**  
>  一个整数表示答案
>
> **四、样例输入输出**
>
> 示例1：
>
> 输入：  
>  WASDAASD
>
> 输出：  
>  1
>
> 说明：  
>  将第二个A替换为W，即可得到完美走位 。
>
> 示例2：
>
> 输入：  
>  AAAA
>
> 输出：  
>  3
>
> 说明：  
>  将其中三个连续的A替换为WSD，即可得到完美走位

# 思路

> 1：先用一个map统计出字符串所有的字符个数，然后先看是否”完美“。
>
> 2：再利用经典的尺取法。  
>  从左往右移动区间，当满足条件时，左端点右移，缩小区间，当不满足条件时，右端点右移，扩大区间，这样可以找到每个满足条件的区间，从而可以找到最小区间。  
>  记录不包含该区间时 WASD 的数量，先判断能否通过替换区间内的元素使 WASD 数量一致，再判断剩余位置是否是４的倍数。

# 考点

> 1：尺取法

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import copy
    
    #处理输入
    input_str = input()
    
    char_count = {'W':0,'A':0,'S':0,'D':0}
    
    #频次统计
    for single_char in input_str:
        char_count[single_char] += 1
    
    #特殊情况
    if char_count['W'] == char_count['A'] and \
        char_count['W'] == char_count['S'] and \
        char_count['W'] == char_count['D'] :
            print (0)
    else:
        # 左右区间位置 
        left = 0;
        right = 0;
        length = 0;
        
        # 替换的最小长度
        res = len(input_str);
        # 出现次数最多的字母
        max_char_num = 0;
        # 可替换字母个数, 随着指针移动，如果free_char_num 大于0且能被4整除，当前范围满足条件，左指针右移一格，否则右指针右移
        free_char_num = 0;
        
        char_count[input_str[0]] -= 1
        while (True):
            max_char_num = max(max((max(char_count['W'], char_count['S'])), char_count['A']), char_count['D']);
            length = right - left + 1;
            free_char_num = length - ((max_char_num - char_count['W']) + (max_char_num - char_count['S']) + (max_char_num - char_count['A']) + (max_char_num - char_count['D']));
            if (free_char_num >= 0 and free_char_num % 4 == 0):
                if(length<res) :
                    res = length
                
                char_count[input_str[left]] += 1
                left += 1
    
            else:
                right += 1
                if (right>= len(input_str)):
                    break
                char_count[input_str[right]] -= 1
            
    
            if (right >= len(input_str)):# 越界即结束
                break;
    
    
        print (res)
    
    
    

