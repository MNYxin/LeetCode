**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 在系统，网络均正常的情况下组织核酸采样员和志愿者对人群进行 核酸检测筛查。  
>  每名采样员的效率不同，采样效率为N人/小时，
>
> 由干外界变化，采样品的效率会以M人1小时为粒度发生变化，M为采样效率浮动粒度，M=N*10%，输入保证N*10%的结果为整数
>
>
> 采样员效率浮动规则:采样员需要一名志愿者协助组织才能发挥正常效率，在此基础上，每增加一名志愿者，效率提升1M，最多提升3M;如果没有志愿者协助组织，效率下降2M。  
>  怎么安排速度最快?求 **总最快检测效率** (总检查效率为各采样人员效率值相加)。
>
> **输入描述**
>
> 第一行:第一个值，采样品人数，取值范围[1, 100]:第一个值。志愿者人数:取值范围[1, 500]  
>  第二行:各采样员基准效率值(单位人/小时)，取值范围[60，600]，保证序列中每项值计算10%为整数。
>
> **输出描述**  
>  总最快检测效率(单位人1小时)
>
> **示例1：**  
>  输入：
>
> 2 2
>
> 200 200  
>  输出：
>
> 400  
>  说明：
>
> 输入保证采样员基准效率值序列的每个值*10%为整数。

# 思路

> 1：首先读题，感觉绕的很，主要是理解【效率浮动规则】，采样员最少一个志愿者才能保证100%效率，增加一个志愿者多10%效率，不给的话只有80%效率。
>
> 2：志愿者多于采样员，超过4倍则大家都满效率了。不超过四倍则需要逐个分配。不管多于还是少于，肯定先分配给采样效率最高的采样员。
>
> 3：剥夺效应，假设 最高效率的采样员上升10%的效率 > 最低效率的采样员下降20%的效率 这个条件满足了，那么低效率采样员的志愿者就可以剥夺。
>
> 4：1~4倍的四种情况直接枚举，使用简单的DP即可。

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    def comp(a, b):
        return b-a
     
    #处理输入
    params = [int(x) for x in input().split(" ")]
    sample_num = params[0]
    volunteer_num = params[1]
    efficiencys = [int(x) for x in input().split(" ")]
    
    range_efficiencys=[]
    for i in range(sample_num):
        range_efficiencys.append(efficiencys[i]/10)
    
    dp = [[0 for x in range(volunteer_num+1)] for y in range(sample_num+1)]
    count = 0
    for i in range(1, sample_num+1):
        count += (efficiencys[i-1] - 2*range_efficiencys[i-1])
        dp[i][0] = count   
    
    
    for i in range(1, sample_num+1):
        for j in range(1, volunteer_num+1):
            dp[i][j] = max( dp[i-1][j]+efficiencys[i-1]-2*range_efficiencys[i-1], dp[i-1][j-1]+efficiencys[i-1])     #志愿者大于等于1
            dp[i][j] = max(dp[i][j],  dp[i-1][j-2]+efficiencys[i-1]+range_efficiencys[i-1] if j-2 >= 0 else 0)    #志愿者大于等于2
            dp[i][j] = max(dp[i][j], dp[i-1][j-3]+efficiencys[i-1]+2*range_efficiencys[i-1] if j-3 >= 0 else 0)  #志愿者大于等于3
            dp[i][j] = max(dp[i][j], dp[i-1][j-4]+efficiencys[i-1]+3*range_efficiencys[i-1] if j-4 >= 0 else 0)  #志愿者大于等于4
    
    
    print(dp[sample_num][volunteer_num])
    
    
    

