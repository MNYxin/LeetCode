**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 对称就是最大的美学，现有一道关于对称字符串的美学。  
>  已知：  
>  第1个字符串：R
>
> 第2个字符串：BR
>
> 第3个字符串：RBBR  
>  第4个字符串：BRRBRBBR  
>  第5个字符串：RBBRBRRBBRRBRBBR相信你已经发现规律了，没错！  
>  就是第i个字符串=第i-1号字符串的取反+第i-1号字符串。取反即(R->B,B->R);  
>  现在告诉你n和k，让你求得第n个字符串的第k个字符是多少。(k的编号从0开始)  
>  **输入描述**  
>  第一行输入一个T，表示有T组用例：  
>  接下来输入T行，每行输入两个数字，表示n，k1 <= T <= 100;  
>  1 <= n <= 64;  
>  0 <= k < 2^(n-1);  
>  **输出描述**  
>  输出T行表示答案：  
>  输出blue表示字符是B；输出red表示字符是R；  
>  **示例一**  
>  输入
>
> 5  
>  1 0  
>  2 1  
>  3 2  
>  4 6  
>  5 8  
>  输出
>
> red  
>  red  
>  blue  
>  blue  
>  blue
>
> 说明  
>  第1个字符串：R ->第0个字符为R
>
> 第2个字符串：BR ->第1个字符为R
>
> 第3个字符串：RBBR ->第2个字符为B  
>  第4个字符串：BRRBRBBR ->第6个字符为B  
>  第5个字符串：RBBRBRRBBRRBRBBR ->第8个字符为B  
>  **示例二**  
>  输入
>
> 1  
>  64 73709551616  
>  输出：
>
> red  
>  备注  
>  输出字符串区分大小写，请注意输出小写字符串，不带双引号

# 思路

> 1：考察的就是题目意思的理解。
>
> 2：第i个字符串=第i-1号字符串的取反+第i-1号字符串
> 从这个公式可以得知，如果k在前半串，则与前一个字符串相反，如果k在后半串，则与前一个字符串的对应的 k 位置相同。
>
> 3：由于当前字符串与前一个字符串存在依赖关系，明显可以用递归的方法去找上一个字符串在对应位置上的字符。

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import math
    
    def find(n, k):
        if (n == 1) :
            return 'R'
        if (n == 2):
            if (k == 0): 
                return 'B'
            else: 
                return 'R'
    
        len = math.pow(2, n - 2)
        
        # 如果 k 在后半段，则与前一个字符串相同
        if (k >= len):
            pos = k - len
            return find(n - 1, pos)
        else:
            # 如果 k 在前半段，则与前一个字符串相反
            if (find(n - 1, k) == 'R'):
                return 'B'
            else:
                return 'R'
    
    
    #处理输入
    t = int(input())
    input_case = []
    for i in range(t):
        input_case.append([float(x) for x in input().split(" ")])
    
    for i in range(t):
        n = input_case[i][0]
        k = input_case[i][1]
        if (find(n, k) == 'R'):
            print("red")
        else:
            print("blue")
        
    
    

