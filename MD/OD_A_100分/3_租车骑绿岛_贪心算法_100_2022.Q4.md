**所有题目均有四种语言实现。 **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++ 实现目录")** 、
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")** 、
**[JavaScript实现目录](https://renjie.blog.csdn.net/article/details/128974467
"JavaScript实现目录")** 、
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")****

# 题目

> 【租车骑绿岛】100分  
>  部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，做最大载重M。  
>  给出部门每个人的体重，请问最多需要租用多少双人自行车。  
>  输入描述：  
>  第一行两个数字m、n，分别代表自行车限重，部门总人数。
>
> 第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。  
>  0<m<=200  
>  0<n<=1000000  
>  输出描述：  
>  最小需要的双人自行车数量。
>
> 示例1 输入输出示例仅供调试，后台判题数据一般不包含示例  
>  输入
>
> 3 4  
>  3 2 2 1
>
> 输出
>
> 3  
>

# 思路

> 1：背包问题，贪心算法应该就可以解决了
>
> 第一步 先给人的体重排序
>
> 第二步 逐个按照贪心的思想去分配自行车

# 考点

> 1：贪心算法

# Code

    
    
    # coding:utf-8
    import functools
    
    
    #处理输入
    input_param = [int(x) for x in input().split(" ")]
    m = input_param[0]
    n = input_param[0]
    weights = [int(x) for x in input().split(" ")]
    
    #第一步，单词内部调整
    weights = sorted(weights, reverse=False)
    
    #第二步，左右指针向中间移动
    left=0;
    right = len(weights)-1
    
    #结果
    min_bikes = 0
    
    #当前重量
    temp_weight = weights[right] + weights[left]
    
    #题目中有两个隐含的条件
    # 1: 一辆车最多骑两个人
    #2：人的重量不可能大于车的载重
    
    while(left<right):
        if (temp_weight > m):
            right -= 1
            min_bikes += 1
            temp_weight = weights[right] + weights[left]
        else:
            right -= 1
            left += 1
            min_bikes += 1
            temp_weight = weights[right] + weights[left]
    
    
    #感谢评论区老铁点拨
    if (left == right):
        min_bikes += 1
    
    
    print (min_bikes)

