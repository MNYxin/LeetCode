**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> 给定一个数组nums,将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中，组内元素和的最小值
>
> **输入描述：**  
>  第一行输入 m  
>  接着输入m个数，表示此数组  
>  数据范围:1<=M<=50, 1<=nums[i]<=50
>
> **输出描述：**
>
> 最小拆分数组和。
>
> **示例：**
>
> 输入：
>
> 7  
>  4 3 2 3 5 2 1
>
> 输出：
>
> 5
>
> 说明：可以等分的情况有：
>
> 4 个子集（5），（1,4），（2,3），（2,3）
>
> 2 个子集（5, 1, 4），（2,3, 2,3）
>
> 但最小的为5。

# 思路

> 1：首先第一个目标，将数组拆分，每个子数组的和相等。
>
> 比如[2,2,4] 拆分为[2,2] [4]
>
> 2：其次第二个目标，要求所有的可能拆分条件下，子数组的和最小。
>
> 比如 [1,1,1,1] 可以拆分为[1] [1] [1] [1] 和 [1,1] [1,1]
>
> 明显最小的子数组元素之和是1.
>
> 3：和 [leetcode 698](https://leetcode.cn/problems/partition-to-k-equal-sum-
> subsets/solution/hua-fen-wei-kge-xiang-deng-de-zi-ji-by-l-v66o/ "leetcode
> 698") 很像，首先要判定是否能拆分成等和子数组。这里也给出动态规划解法的官方描述：
>
> 用一个整数 S 来表示当前可用的数字集合：从低位到高位，第 i 位为 0 则表示数字 nums[i] 可以使用，否则表示nums[i]
> 已被使用。然后我们用 dp[S] 来表示在可用的数字状态为 S 的情况下是否可能可行，初始全部状态为记录为不可行状态False，只记
> dp[0]=True
> 为可行状态。同样我们每次对于当前状态下从可用的数字中选择一个数字，若此时选择全部数字取模后小于等于per。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终dp[U]
> 即可，其中 U 表示全部数字使用的集合状态。

# 考点

> 1：动态规划

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    
    def canPartitionKSubsets(nums, k):
        all = sum(nums)
        if all % k:
            return False
        per = all // k
        nums.sort()
        if nums[-1] > per:
            return False
        n = len(nums)
        dp = [False] * (1 << n)
        dp[0] = True
        cursum = [0] * (1 << n)
        for i in range(0, 1 << n):
            if not dp[i]:
                continue
            for j in range(n):
                if cursum[i] + nums[j] > per:
                    break
                if (i >> j & 1) == 0:
                    next = i | (1 << j)
                    if not dp[next]:
                        cursum[next] = (cursum[i] + nums[j]) % per
                        dp[next] = True
        return dp[(1 << n) - 1]
    
    
    #处理输入
    n = int(input())
    nums = [int(x) for x in input().split(" ")]
    
    
    for i in reversed(range(n+1)):
        #从最大的可能行开始，满足条件即为为最小的情况
        if (canPartitionKSubsets(nums, i)):
            print (sum(nums) / i)
            break;
    
    

