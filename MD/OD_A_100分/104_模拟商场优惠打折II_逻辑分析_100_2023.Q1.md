**所有题目均有五种语言实现。
**[C实现目录](https://renjie.blog.csdn.net/article/details/129190260 "C实现目录")** 、
** ** ** ** ** ** **[C++
实现目录](https://blog.csdn.net/misayaaaaa/category_12036814.html "C++
实现目录")************** 、 ** ** ** ** ** **
**[Python实现目录](https://blog.csdn.net/misayaaaaa/category_12111005.html
"Python实现目录")************** 、 ** ** ** ** ** **
**[Java实现目录](https://blog.csdn.net/misayaaaaa/category_12111006.html
"Java实现目录")************** 、 ** ** ** ** ** **
**[JavaScript实现目录](https://blog.csdn.net/misayaaaaa/category_12199270.html
"JavaScript实现目录")****************

# 题目

> **题目描述**
>
> 某网上商场举办优惠活动，发布了满减、打折、无门槛3种 优惠券，分别为:  
>  1：每满100元优惠10元，无使用数限制，如100~199元可以使用1张减10元，200~299可使用2张减20元，以此类推;  
>  2：92折券，1次限使用1张，如100元，则优惠后为92元，  
>  3：无门槛5元优惠券，无使用数限制，直接减5元。
>
> **优惠券使用限制** ：每次最多使用2种优惠券，2种优惠可以叠加(优惠叠加时以优惠后的价格计算)。
>
>
> 以购物200元为例，可以先用92折券优惠到184元，再用1张满减券优惠10元，最终价格是174元，也可以用满减券2张优惠20元为180元，再使用92折券优惠到165(165.6向下取整)，不同使用顺序的优惠价格不同，以最优惠价格为准。在一次购物种，同一类型优惠  
>  券使用多张时必须一次性使用，不能分多次拆开使用(不允许先使用1张满减券，再用打折券，再使用一张满减券)。  
>
> 请设计实现一种解决方法，帮助购物者以最少的优惠券获得最优的优惠价格。优惠后价格越低越好，同等优惠价格，使用的优惠券越少越好，可以允许某次购物不使用优惠券。
>
> 约定：优惠活动每人只能参加一次，每个人的优惠券种类和数量是一样的。
>
> **输入描述**  
>  1：第一行:每个人拥有的优惠券数量(数量取值范围为[0,10]，按满减、打折、无门槛的顺序输入  
>  2：第二行:表示购物的人数n(1≤n≤10000)  
>  3：最后n行:每一行表示某个人优惠前的购物总价格(价格取值范围(0,1000]，都为整数)。
>
> **输出描述**  
>  1：每行输出每个人每次购物优惠后的最低价格以及使用的优惠券总数量。每行的输出顺序和输入的顺序保持一致
>
> **备注**  
>  1.优惠券数量都为整数，取值范围为[0.10]  
>  2.购物人数为整数，取值范围为[1,10000]  
>  3.优惠券的购物总价为整数，取值范围为(0.1000]  
>  4.优惠后价格如果是小数，则向下取整，输出都为整数。
>
> **示例1： 输入输出示例仅供调试，后台判题数据一般不包含示例**
>
> **输入**
>
> 3 2 5
>
> 3  
>  100
>
> 200
>
> 400  
>  **输出**
>
> 65 6
>
> 155 7
>
> 338 4

# 思路

> 0：有一个姐妹题目，但是细节上有略微不同。整体逻辑不变， **微调下满减券的条件即可** 。
>
> 1：暴力遍历即可，因为不能交叉使用且只能使用两种，那么所有的可能性都可以暴力枚举出来：假设为A、B、C
>
> AB
>
> BA
>
> AC
>
> CA
>
> BC
>
> CB
>
> 总共六种使用的可能性。
>
> 2：其次按照常识，先使用无门槛优惠券，把总价的基数变小之后，再用别的优惠券肯定得不到最大的优惠，所以还剩4种方案。
>
> 3：按照4种可能行算出结果，比对出最小值即可。
>
> 4：感觉题目设计是不是有问题，打折券只能用一张，为啥要给出打折券的个数，难道是迷惑项？
>
> ![](https://img-blog.csdnimg.cn/64a9bfba99214604b0d2e4a8d35baf54.jpeg)

# 考点

> 1：逻辑思维能力

# Code

    
    
    # coding:utf-8
    #JSRUN引擎2.0，支持多达30种语言在线运行，全仿真在线交互输入输出。 
    import functools
    import collections
    import math
    from itertools import combinations
    from re import match
     
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right
     
    #并查集模板
    class UF:
        def __init__(self, n=0):
            self.count = n
            self.item = [0 for x in range(n+1)]
            for i in range(n):
                self.item[i] = i
        def find(self, x):
            if (x != self.item[x]):
                self.item[x] = self.find(self.item[x])
                return 0
            return x
        
     
        def union_connect(self, x, y):
            x_item = self.find(x)
            y_item = self.find(y)
        
            if (x_item != y_item):
                self.item[y_item] = x_item
                self.count-=1
     
    #先满减后打折
    def mode_a(price, m, n):
        count = 0
        count += min(m, int(price / 100))
        price -= count * 10
        price *= 0.92
        count += 1
        return (price, count)
     
     
    #先打折后满减
    def mode_b(price, m, n):
        count = 0
     
        price *= 0.92
        count += 1
     
        count += min(m, int(price / 100))
        price -= (count-1) * 10
        return (price, count)
     
     
     
    #先满减后无门槛
    def mode_c(price, m, k):
        count = 0
     
        count += min(m, int(price / 100))
        price -= count * 10
        
     
        for i in range(k):
            price -= 5
            count += 1
            if (price <0):
                break
        return (price, count)
     
     
    #先打折后无门槛
    def mode_d(price, n, k):
        count = 0
     
        price *= 0.92
        count += 1
     
        for i in range(k):
            price -= 5
            count += 1
            if (price < 0):
                break
        return (price, count)
     
     
    def comp(a, b):
        if (a[0] > b[0]):
            return 1
        elif (a[0] == b[0]):
            if (a[1] > b[1]):
                return 1
            else:
                return -1
        return -1
     
     
     
    # 处理输入
    params = [int(x) for x in input().split(" ")]
    m = params[0]
    n = params[1]
    k = params[2]
     
    x = int(input())
     
     
    for i in range(x):
        price = int(input())
     
        result = []
        result.append(mode_a(price, m, n))
        result.append(mode_b(price, m, n))
        result.append(mode_c(price, m, k))
        result.append(mode_d(price, n, k))
     
        #按照价格降序，用券数降序排序
        result = sorted(result, key = functools.cmp_to_key(comp))
        print(str(int(result[0][0])) + " "+str(result[0][1]))
        

## 要求

> 时间限制：C/C++ 1秒，其他语言 2秒
>
> 空间限制：C/C++262144K，其他语言524288K
>
> 64bit IO Format：%lld
>
> 语言限定：  
>  C（clang11）, C++（clang++11）, Pascal（fpc 3.0.2）, Java（javac 1.8）,
> Python2（2.7.3）,  
>  PHP(7.4.7), C#(mcs5.4), ObjC(gcc 5.4), Pythen3(3.9), JavaScript
> Node(12.18.2), JavaScript V8(6.0.0),  
>  Sqlite(3.7.9), R(4.0.3), Go(1.14.4), Ruby(2.7.1), Swift(5.3), matlab(Octave
> 5.2), Pypy2(pypy2.7.13),  
>  Pypy3(pypy3.6.1), Rust(1.44), Scala(2.11.12), Kotlin(1.4.10),
> Groovy(3.0.6), TypeScript(4.1.2), Mysql(8.0)

